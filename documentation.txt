Next.js E-commerce - Build a Shopping Platform From Scratch


Section 01: Introduction

01. Welcome To The Course

02. The Stack

03. The Project

04. The Environment

05. Premium Docs

06. Final Code & Demo


Section 02: App Creation & Basics Layout

07. Section Intro

08. Create Next App & Assets
-preuzemo folder resources
-otvorimo web stranicu: https://nextjs.org/
-u terminalu ukucamo komandu npx create-next-app@latest .
-ukucamo komandu npm run dev 
-u komponentu layout.tsx importujemo funkciju Inter iz paketa next/font/google
-kreiramo varijablu const inter
-u jsx-u, u prop className proslijedujemo dinamicku vrijednost varijable inter
-brisemo globals.css fajl
-kreiramo folder assets
-u folder assets dodajemo starter folder styles sa globals.css fajlom i loader.gif sliku
-u komponentu layout.tsx importujemo globals.css fajl
-u komponenti app/page.tsx kreiramo i eksportujemo funkciju Homepage() kao default
-u folder app dodajemo logo favicon.ico
-u folder public dodajemo folder images

09. ShadCN UI Setup
-otvorimo web stranicu: https://ui.shadcn.com/
-u terminalu ukucamo komandu: npx shadcn@latest init
-odaberemo opciju Use --legacy-peer-deps
-nakon instalacije paketa Shadcn generisan folder lib i utils.ts fajl
-nakon instalacije paketa Shadcn generisan components.json fajl
-ukucamo komandu: npx shadcn@latest add button
-nakon instalacije komponente button generisan folderi components, ui i komponenta button.tsx
-otvorimo link: https://ui.shadcn.com/docs/react-19
-otvorimo link: https://www.npmjs.com/package/clsx
-u terminalu ukucamo komandu: npx i clsx
-otvorimo link: https://www.npmjs.com/package/tailwind-merge
-u terminalu ukucamo komandu: npm i tailwind-merge
-otvorimo link: https://www.npmjs.com/package/tailwindcss-animate
-u terminalu ukucamo komandu: npx i tailwindcss-animate

10. Root Layout & Constants
-u folderu app kreiramo folder (root) i komponentu layout.tsx
-u komponenti (root)/layout.tsx kreiramo i eksportujemo funkciju RootLayout() kao default
-u jsx-u kreiramo HTML elemente sa Tailwind CSS klasama
-u main element dodajemo prop children
-komponentu app/page.tsx premjestamo u folder (root)
-u folderu lib kreiramo folder constants i index.ts fajl
-u constants/index.ts fajlu kreiramo i eksportujemo varijable const APP_NAME, APP_DESCRIPTION i const SERVER_URL
-kreiramo .env fajl
-u .env fajlu kreiramo tri env varijable NEXT_PUBLIC_APP_NAME, NEXT_PUBLIC_APP_DESCRIPTION i NEXT_PUBLIC_SERVER_URL
-kreiramo example.env fajl u koji dodajemo primjer env varijabli koje je potrebno kreirati
-u komponentu app/layout.tsx importujemo varijable APP_NAME, APP_DESCRIPTION i SERVER_URL iz utils.ts fajla
-u eslint.config.mjs fajl dodajemo objekt rules
-uobjekt rules dodajemo opciju: @typescript-eslint/no-empty-interface": "off"

11. Header & Footer Components
-u eslint.config.mjs fajl dodajemo opciju: @typescript-eslint/no-unused-vars": "warn"
-u folderu components kreiramo foldere shared i header
-u folderu header kreiramo komponentu index.tsx
-u komponentu (root)/layout.tsx importujemo komponentu Header iz komponente header/index.tsx
-u komponenti header/index.tsx kreiramo i eksportujemo funkciju Header() kao default
-otvorimo link: https://www.npmjs.com/package/lucide-react
-u terminalu instaliramo paket Lucide React sa komandom npm i lucide-react
-u komponentu header/index.tsx importujemo React ikonice ShoppingCart i UserIcon iz paketa Lucide React
-importujemo komponentu Image iz paketa next/image
-otvorimo link: https://nextjs.org/docs/pages/api-reference/components/image
-importujemo komponentu Link iz paketa next/link
-otvorimo link: https://nextjs.org/docs/pages/api-reference/components/link
-importujemo komponentu Button iz komponente ui/button.tsx
-otvorimo link: https://ui.shadcn.com/docs/components/button
-importujemo varijablu APP_NAME iz lib/constants.ts fajla
-u funkciji Header(), u jsx-u kreiramo header element kao roditelj element
-elementu header dodajemo Tailwind CSS klase w-full i border-b
-u header elementu kreiramo div element sa Tailwind CSS klasama wrapper i flex-between
-u div elementu sa klasama wrapper i flex-between kreiramo dva div elementa
-u prvi div element dodajemo komponentu Link
-komponenti Link dodajemo prop href i className
-u komponentu Link dodajemo komponentu Image i kreiramo span element
-komponenti Image dodajemo prop priority, src, width, height i alt
-span elementu dodajemo Tailwind CSS klase
-u drugi div element dodajemo dvije komponente Button
-komponentama Button dodajemo prop asChild i variant
-u komponente Button dodajemo komponente Link sa prop href
-u komponentama Link kreiramo po dva span elementa
-u prvi span element dodajemo React ikonicu, dok u drugi span element dodajemo opis
-u folderu components kreiramo komponentu footer.tsx
-u komponenti footer.tsx kreiramo i eksportujemo funkciju Footer() kao default
-u komponentu (root)/layout.tsx importujemo komponentu Footer iz komponente footer.tsx
-u komponentu footer.tsx importujemo varijablu APP_NAME iz lib/constants.ts fajla
-u funkciji Footer() kreiramo varijablu const currentYear
-u jsx-u kreiramo footer element kao roditelj element
-u footer elementu kreiramo div element sa Tailwind CSS klasama p-5 i flex-center
-u div elementu kreiramo tri span elementa
-u span elementima dinamicki prikazujemo vrijednost varijabli currentYear i APP_NAME

12. Theme Mode Toggle
-otvorimo link: https://ui.shadcn.com/docs/dark-mode/next
-otvorimo link: https://ui.shadcn.com/themes
-otvorimo link: https://www.npmjs.com/package/next-themes
-u globals.css fajl dodajemo kod iz dokumentacije za Shadcn teme
-u globals.css fajl dodajemo direktivu @layer base 
-u direktivu @layer base dodajemo objekte :root i .dark
-u terminalu ukucamo komandu: npm i next-themes
-otvorimo link: https://ui.shadcn.com/docs/components/dropdown-menu
-u terminalu ukucamo komandu: npx shadcn@latest add dropdown-menu
-u komponentu app/layout.tsx importujemo komponentu ThemeProvider iz paketa next-themes
-u jsx-u dodajemo komponentu ThemeProvider sa otvorenim i zatvorenim tagom
-komponenti ThemeProvider dodajemo prop attribute, defaultTheme, enableSystem i disableTransitionOnChange
-u komponentu ThemeProvider dodajemo prop {children}
-html roditelj elementu dodajemo atribut suppressHydrationWarning>
-u folderu components/header kreiramo komponentu mode-toggle.tsx
-u komponenti mode-toggle.tsx kreiramo i eksportujemo funkciju ModeToggle() kao default
-u komponentu header/index.tsx importujemo komponentu ModeToggle iz komponente mode-toggle.tsx
-otvorimo link: https://nextjs.org/docs/app/building-your-application/rendering/client-components
-u komponentu mode-toggle.tsx dodajemo direktivu 'use client'
-importujemo funkciju useTheme iz paketa next-themes
-u funkciji ModeToggle() pozivamo funkciju useTheme()
-vrijednost funkcije useTheme() pohranjujemo u destruktuirane varijable const { theme, setTheme }
-importujemo sest komponenti: 
DropdownMenu, DropdownMenuTrigger, DropdownMenuLabel, DropdownMenuSeparator, DropdownMenuContent i DropdownMenuCheckboxItem iz komponente ui/dropdown-menu.tsx
-importujemo komponentu Button iz komponente ui/button.tsx
-importujemo React ikonice SunIcon, Moon i SunMoon iz paketa lucide-react
-u jsx-u dodajemo komponentu DropdownMenu kao roditelj komponentu
-u komponentu DropdownMenu dodajemo komponentu DropdownMenuTrigger sa prop asChild
-u komponentu DropdownMenuTrigger dodajemo komponentu Button sa prop variant
-u komponentu Button dodajemo uslov ternarni operator theme === 'system'
-importujemo funkcije useState i useEffect iz paketa react
-u funkciji ModeToggle() pozivamo funkciju useState(false)
-vrijednost funkcije useState(false) pohranjujemo u varijable const [mounted, setMounted]
-pozivamo funkciju useEffect()
-u funkciji useEffect() pozivamo funkciju setMounted(true)
-dodajemo uslov if (!mounted) return null
-u komponentu DropdownMenu dodajemo komponentu DropdownMenuContent sa otvorenim i zatvorenim tagom
-u komponentu DropdownMenuContent dodajemo komponentu DropdownMenuLabel sa otvorenim i zatvorenim tagom
-dodajemo komponentu DropdownMenuSeparator sa samozatvarajucim tagom
-dodajemo tri komponente DropdownMenuCheckboxItem sa otvorenim i zatvorenim tagom
-komponentama DropdownMenuCheckboxItem dodajemo prop checked i dogadaj onClick
-u prop checked proslijedujemo dinamicku vrijednost varijable theme
-u dogadaj onClick proslijedujemo funkcije () => setTheme()

13. Loading & Not Found Pages
-otvorimo link: https://nextjs.org/docs/app/building-your-application/routing/loading-ui-and-streaming
-u folderu app kreiramo komponentu loading.tsx
-u komponenti app/loading.tsx kreiramo i eksportujemo funkciju LoadingPage() kao default
-importujemo komponentu Image iz paketa next/image
-importujemo sliku loader iz foldera assets
-u jsx-u roditelj div elementu dodajemo Tailwind CSS Flex klase
-u div element dodajemo komponentu Image sa prop src, alt, width i height
-u komponenti (root)/page.tsx kreiramo funkciju delay()
-otvorimo link: https://nextjs.org/docs/pages/building-your-application/routing/custom-error
-u folderu app kreiramo komponentu not-found.tsx
-u komponenti not-found.tsx kreiramo i eksportujemo funkciju NotFoundPage() kao default
-dodajemo direktivu 'use client'
-importujemo komponentu Image iz paketa next/image
-importujemo varijablu APP_NAME iz lib/constants.ts fajla
-importujemo komponentu Button iz komponente ui/button.tsx
-u jsx-u dodajemo roditelj div elementu Tailwind CSS Flex klase
-u div element dodajemo komponentu Image sa prop src, width, width, height i priority
-kreiramo HTML elemente h2 i p sa Tailwind CSS klasama
-importujemo komponentu Link iz paketa next/link
-u div element dodajemo komponentu Link sa prop href i className

14. Responsive Sheet Menu
-otvorimo link: https://ui.shadcn.com/docs/components/sheet
-u terminalu ukucamo komandu: npx shadcn@latest add sheet
-u folderu header kreiramo komponentu menu.tsx
-u komponenti menu.tsx kreiramo i eksportujemo funkciju Menu() kao default
-u jsx-u roditelj div elementu dodajemo Tailwind CSS klase
-u div elementu kreiramo nav element sa Tailwind CSS klasama
-iz komponente header/index.tsx prebacujemo komponente ModeToggle.tsx i Button u komponentu menu.tsx
-u komponentu header/index.tsx importujemo komponentu Menu iz komponente menu.tsx
-u komponentu menu.tsx importujemo React ikonicu EllipsisVertical iz paketa lucide/react
-importujemo komponente Sheet, SheetContent, SheetTitle i SheetTrigger iz komponente ui/sheet.tsx
-kreiramo jos jedan nav element sa Tailwind CSS klasom md:hidden
-u element nav dodajemo komponentu Sheet sa otvorenim i zatvorenim tagom
-u komponentu Sheet dodajemo komponentu SheetTrigger sa otvorenim i zatvorenim tagom
-u komponentu SheetTrigger dodajemo komponentu React ikonicu EllipsisVertical
-u komponentu Sheet dodajemo komponentu SheetContent sa otvorenim i zatvorenim tagom
-komponenti SheetContent dodajemo Tailwind CSS Flex klase
-u komponentu SheetContent dodajemo komponentu SheetTitle sa otvorenim i zatvorenim tagom
-u komponentu SheetContent dodajemo komponentu ModeToggle
-u komponentu SheetContent dodajemo komponentu Button sa prop asChild i variant
-u komponentu Button dodajemo komponentu Link sa prop href
-u komponentu Link dodajemo React ikonicu ShoppingCart
-u komponentu SheetContent dodajemo komponentu SheetDescription sa otvorenim i zatvorenim tagom
-u komponentu SheetContent dodajemo jos jednu komponentu Button sa prop asChild

15. Sample Products & Product List
-u eslint.config.mjs fajl dodajemo, u objekt rules dodajemo opciju: "@typescript-eslint/no-explicit-any": "off"
-kreiramo folder db i sample-data.ts fajl
-u sample-data.ts fajlu kreiramo i eskportujemo niz sampleData kao default
-u komponentu (root)/page.tsx importujemo niz sampleData
-u folderu components/shared kreiramo folder product i komponentu product-list.tsx
-u komponenti product/product-list.tsx kreiramo i eksportujemo funkciju ProductList() kao default
-u komponentu (root)/page.tsx importujemo komponentu ProductList.tsx iz komponenta product-list.tsx
-u jsx-u dodajemo prazan fragment kao roditelj element
-u element prazan fragment dodajemo komponentu ProductList sa prop data, title i limit
-u komponenti product-list.tsx, funkciji ProductList() dodajemo parametre destruktuirane prop sa tipovima
-u jsx-u div roditelj elementu dodajemo Tailwind CSS klasu my-10
-u div elementu kreiramo h2 element sa Tailwind CSS klasama
-u div elementu dodajemo uslov ternarni operator data?.length > 0
-kreiramo varijablu const limitedData
-u prvi dio ternarnog uslova dodajemo metodu limitedData?.map()
-u drugi dio ternarnog uslova dodajemo elemente div i p sa porukom da proizvodi nisu pronadeni

16. Product Card Component
-otvorimo link: https://ui.shadcn.com/docs/components/card
-u terminalu ukucamo komandu: npx shadcn@latest add card
-u folderu components/product kreiramo komponentu product-card.tsx
-u komponenti product-card.tsx kreiramo i eksportujemo funkciju ProductCard() kao default
-u komponentu product-card.tsx importujemo komponente Link i Image iz paketa next
-importujemo komponente Card, CardHeader i CardContent iz komponente ui/card.tsx
-funkciji ProductCard() dodajemo parametar destruktuirani prop product sa tipom
-u jsx-u dodajemo komponentu Card kao roditelj element sa Tailwind CSS klasama
-u komponentu Card dodajemo komponentu CardHeader sa otvorenim i zatvorenim tagom
-komponenti CardHeader dodajemo Tailwind CSS klase
-u komponentu CardHeader dodajemo komponente Link i Image
-u komponentu Card dodajemo komponentu CardContent sa otvorenim i zatvorenim tagom
-komponenti CardContent dodajemo Tailwind CSS klase
-u komponenti CardContent kreiramo div element
-dodajemo komponentu Link sa prop href 
-u prop href dodajemo dinamicki link
-u komponenti Link kreiramo h2 element sa Tailwind CSS klasama
-u komponentu product-list.tsx importujemo komponentu ProductCard iz komponente product-card.tsx
-u funkciju map() dodajemo komponentu ProductCard umjesto div elementa
-u komponenti CardContent kreiramo div element sa Tailwind CSS klasama
-u div elementu kreiramo p element
-u p elementu kreiramo dva span elementa
-dodajemo uslov ternarni operator product?.stock > 0
-u prvi dio ternarnog operatora dodajemo p element u kojem dinamicki prikazujemo cijenu artikla
-u drugi dio ternarnog operatora dodajemo p element sa klasom text-destructive u kojem prikazujemo poruku kako artikl nije dostupan

17. Product Price Component
-u folderu components/product kreiramo komponentu product-price.tsx
-u komponenti product-price.tsx kreiramo i eksportujemo funkciju ProductPrice() kao default
-funkciji ProductPrice() dodajemo parametre destruktuirane prop value i className sa tipovima
-u funkciji ProductPrice() kreiramo varijablu const stringValue
-dodajemo metodu stringValue.split('.')
-vrijednost metode stringValue.split('.') pohranjujemo u varijable const [intValue, floatValue]
-importujemo funkciju cn iz lib/utils.ts fajla
-u jsx-u kreiramo p element kao roditelj element
-p elementu dodajemo prop className
-u prop className proslijedujemo funkciju cn()
-u p elementu kreiramo tri span elementa
-u komponentu product-card.tsx importujemo komponentu ProductPrice iz komponente product-price.tsx
-u prvi dio ternarnog uslova dodajemo komponentu ProductPrice umjesto p elementa
-komponenti ProductPrice dodajemo prop value
-u prop value proslijedujemo funkciju Number(product.price)


Section 03: Database, Prisma & Product Display

18. Section Intro

19. PostgreSQL & Prisma Setup
-otvorimo web stranicu: https://vercel.com/
-na web stranici Vercel odaberemo opciju Storage i kreiramo bazu podataka
-otvorimo web stranicu: https://www.prisma.io/
-u terminalu ukucamo komandu: npm install -D prisma @prisma/client
-ukucamo komandu npx prisma init
-nakon komande npx prisma init generise se folder prisma i schema.prisma fajl
-u .env fajlu se generise env varijabla DATABASE_URL
-varijabli DATABASE_URL dodajemo link za konekciju baze podataka (connection string) sa web stranice Vercel
-instaliramo VS Code ekstenziju za Prismu
-u example.env dodajemo primjer za varijablu DATABASE_URL koju je potrebno kreirati 

20. Prisma Models & Migrations
-otvorimo link: https://www.prisma.io/docs/orm/prisma-schema/data-model/models
-u schema.prisma fajlu kreiramo model Product
-u package.json fajl, u objekt scripts dodajemo komandu "postinstall": "prisma generate"
-u terminalu ukucamo komandu: npx prisma generate
-ukucamo komandu: npx prisma migrate dev --name init
-nakon ove komande u folderu prisma se generise folder migrations
-ukucamo komandu: npx prisma studio

21. Seed Sample Data
-otvorimo link: https://www.npmjs.com/package/tsx
-u terminalu instaliramo paket tsx sa komandom npm i tsx
-otvorimo link: https://www.npmjs.com/package/colors
-u terminalu instaliramo paket colors sa komandom npm i colors
-otvorimo link: https://www.prisma.io/docs/orm/reference/prisma-client-reference
-u folderu db kreiramo seed.ts fajl
-u seed.ts fajl importujemo funkciju PrismaClient iz paketa prisma/client
-importujemo nit sampleData iz sample-data.ts fajla
-kreiramo asinhronu funkciju main()
-u funkciji main() pozivamo funkciju new PrismaClient()
-vrijednost funkcije new PrismaClient() pohranjujemo u varijablu const prisma
-pozivamo funkciju await prisma.product.deleteMany()
-pozivamo funkciju await prisma.product.createMany()
-u terminalu ukucamo komandu: npx tsx ./db/seed

22. Load Products From Database
-otvorimo link: https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations
-otvorimo link: https://stackoverflow.com/questions/77091418/warning-only-plain-objects-can-be-passed-to-client-components-from-server-compo
-u folderu lib kreiramo folder actions
-u folderu actions kreiramo product.actions.ts fajl
-u product.actions.ts fajl dodajemo direktivu 'use server'
-kreiramo i eksportujemo asinhronu funkciju getLatestProducts()
-importujemo funkciju PrismaClient iz paketa prisma/client
-u funkciji getLatestProducts() kreiramo varijablu const prisma
-pozivamo funkciju await prisma.product.findMany()
-vrijednost funkcije await prisma.product.findMany() pohranjujemo u varijablu const data
-dodajemo izjavu return data
-u utils.ts fajlu kreiramo i eskportujemo funkciju convertToPlainObject()
-u product.actions.ts fajl importujemo funkciju convertToPlainObject
-u izjavu return dodajemo funkciju convertToPlainObject(data)
-u komponentu (root)/page.tsx importujemo funkciju getLatestProducts iz product.actions.ts fajla
-u funkciji Homepage() pozivamo funkciju await getLatestProducts()
-vrijednost funkcije await getLatestProducts() pohranjujemo u varijablu const latestProducts
-u prop data proslijedujemo vrijednost varijable latestProducts
-u constants/index.ts fajlu kreiramo i eksportujemo varijablu const LATEST_PRODUCTS_LIMIT
-u .env fajl dodajemo varijablu LATEST_PRODUCTS_LIMIT
-u example.env fajl dodajemo primjer varijable LATEST_PRODUCTS_LIMIT koju je potrebno kreirati
-u product.actions.ts fajl importujemo varijablu LATEST_PRODUCTS_LIMIT iz constants/index.ts fajla

23. Zod Validation & Type Inference
-otvorimo web stranicu: https://zod.dev/
-u terminalu ukucamo komandu: npm i zod
-u folderu lib kreiramo validators.ts fajl
-u validators.ts fajl importujemo instancu z iz paketa zod
-pozivamo funkciju z.object()
-vrijednost funkcije z.object() pohranjujemo u varijablu insertProductSchema
-eksportujemo varijable insertProductSchema
-kreiramo folder types
-u folderu types kreiramo index.ts fajl
-u types/index.ts fajl importujemo instancu z iz paketa zod
-importujemo varijablu insertProductSchema iz lib/validators.ts fajla
-kreiramo i eksportujemo tip Product
-tipu Product dodajemo genericki tip z.infer<typeof insertProductSchema> & { ... }
-u objekt dodajemo opcije id, rating i createdAt
-u lib/utils.ts fajlu kreiramo i eksportujemo funkciju formatNumberWithDecimal()
-u lib/validators.ts fajl importujemo funkciju formatNumberWithDecimal
-kreiramo varijablu const currency
-u objekt z.object({}) dodajemo key - value par price: currency
-u komponentu product-card.tsx importujemo tip Product iz foldera types
-u funkciji ProductCard() destruktuiranom parametru product dodajemo tip Product
-u komponentu product-list.tsx importujemo tip Product iz foldera types
-u funkciji ProductList() destruktuiranom parametru data dodajemo tip Product
-u jsx-u, u funkciji map() parametru product dodajemo tip Product

24. Serverless Environment Config
-otvorimo link: https://www.npmjs.com/package/@neondatabase/serverless
-u terminalu ukucamo komandu: npm i @neondatabase/serverless
-otvorimo link: https://www.npmjs.com/package/@prisma/adapter-neon
-ukucamo komandu: npm i @prisma/adapter-neon
-otvorimo link: https://www.npmjs.com/package/ws
-ukucamo komandu: npm i ws
-otvorimo link: https://www.npmjs.com/package/@types/ws
-ukucamo komandu: npm i -D @types/ws
-otvorimo link: https://www.npmjs.com/package/bufferutil
-ukucamo komandu: npm i -D bufferutil
-u schema.prisma fajlu u objekt generator client dodajemo opciju previewFeatures
-ukucamo komandu npx prisma generate
-otvorimo link: https://neon.tech/docs/serverless/serverless-driver
-otvorimo link: https://www.prisma.io/docs/orm/overview/databases/neon
-u folderu prisma kreiramo prisma.ts fajl
-u prisma.ts fajl kopiramo kod iz dokumentacije
-u product.actions.ts fajl importujemo instancu prisma iz db/prisma.ts fajla
-izbrisemo varijablu const prisma
-izbrisemo folder .next
-u terminalu ukucamo komandu: npm run dev

25. Product Details Page
-u product.actions.ts fajlu kreiramo i eksportujemo asinhronu funkciju getProductBySlug() sa parametrom slug
-parametru slug dodajemo tip string
-u izjavu return dodajemo metodu return await prisma.product.findFirst()
-u funkciju findFirst() dodajemo konfiguracioni objekt
-u konfiguracioni objekt dodajemo objekt where
-u folderu (root) kreiramo foldere product i [slug]
-u folderu product/[slug] kreiramo komponentu page.tsx
-u komponenti [slug]/page.tsx kreiramo i eksportujemo funkciju ProductDetailsPage() kao default
-otvorimo rutu: http://localhost:3000/product/[slug]
-funkciji ProductDetailsPage() dodajemo parametar props sa tipom Promise
-funkciji ProductDetailsPage() dodajemo asinhronost
-u funkciji ProductDetailsPage() dodajemo metodu await props.params
-vrijednost metode await props.params pohranjujemo u destruktuiranu varijablu const { slug }
-importujemo funkciju notFound iz paketa next/navigation
-importujemo funkciju getProductBySlug iz product.actions.ts fajla
-dodajemo metodu getProductBySlug(slug)
-vrijednost metode getProductBySlug(slug) pohranjujemo u varijablu const product
-dodajemo uslov if (!product) notFound()
-otvorimo link: https://ui.shadcn.com/docs/components/badge
-u terminalu ukucamo komandu: npx shadcn@latest add badge
-importujemo komponentu Badge iz komponente ui/components/badge.tsx
-importujemo komponente Card i CardContent iz komponente ui/components/card.tsx
-importujemo komponentu Button iz komponente ui/components/button.tsx
-importujemo komponentu ProductPrice iz komponente product/product-price.tsx
-u jsx-u dodajemo section element kao roditelj element
-u section elementu kreiramo div element sa Tailwind CSS Grid klasama
-u div elementu sa Tailwind CSS Grid klasama kreiramo dva div elementa za sliku i detalje sa Tailwind CSS klasom col-span-2
-u div elementu za detalje kreiramo div element sa Tailwind CSS Flex klasama
-u div elementu kreiramo p dva span elementa u kojima dinamicki prikazujemo marku artikla i kategoriju
-kreiramo h2 element u kojem dinamicki prikazujemo ime artikla
-kreiramo p element i unutar njega cetiri span elementa u kojima dinamicki prikazujemo ocjenu i recenzije artikla
-kreiramo div element sa Tailwind CSS Flex klasama u koji dodajemo komponentu ProductPrice
-komponenti ProductPrice dodajemo prop value i className
-kreiramo div element sa klasom mt-10 u kojem dinamicki prikazujemo opis artikla
-kreiramo div element u koji dodajemo komponentu Card sa otvorenim i zatvorenim tagom
-u komponentu Card dodajemo komponentu CardContent
-u komponenti CardContent kreiramo div element u koji dodajemo komponentu ProductPrice
-kreiramo div element u koji dodajemo komponentu Badge
-dodajemo uslov ternarni operator product?.stock > 0 
-dodajemo uslov za kondicionalno renderovanje komponenta Button product?.stock > 0 &&

26. Product Images Component
-u folderu shared/product kreiramo komponentu product-images.tsx
-u komponenti product-images.tsx kreiramo i eksportujemo funkciju ProductImages() kao default
-funkciji ProductImages() dodajemo parametar destruktuirani prop images sa tipom string[]
-u komponentu [slug]/page.tsx importujemo komponentu ProductImages iz komponente product-images.tsx
-u jsx-u, u div element za sliku dodajemo komponentu ProductImages sa prop images
-u komponentu product-images.tsx dodajemo direktivu 'use client'
-importujemo funkciju useState iz paketa react
-importujemo komponentu Image iz paketa next/image
-importujemo funkciju cn iz lib/utils.ts fajla
-u funkciji ProductImages() kreiramo state varijablu const current i set funkciju setCurrent
-u roditelj div element dodajemo komponentu Image
-komponenti Image dodajemo prop src, alt, width, height i className
-kreiramo div element sa Tailwind klasom flex
-u div element dodajemo metodu images?.map()
-u funkciji map() kreiramo div element
-div elementu dodajemo prop key, className i dogadaj onClick
-u div element dodajemo komponentu Image
-komponenti Image dodajemo prop src, alt, width, height
-u dogadaj onClick proslijedujemo funkciju () => setCurrent(index)
-u prop className proslijedujemo dinamicku klasu cn()

27. Initial Deployment
-u terminalu ukucamo komandu: npm run build
-otvorimo Web stranicu: https://github.com i postavimo kod
-na Web stranici https://vercel.com kreiramo novi projekt
-u kreirani projekt dodajemo env varijable iz .env fajla
-u opciji Install Command dodajemo komandu: npm install --legacy-peer-deps
-promjenimo ime varijable NEXT_PUBLIC_SERVER_URL nakon sto dobijemo Vercel link projekta

28. A Note On ES Lint Errors


Section 04: Authentication With Next Auth

29. Section Intro

30. Prisma User-Related Models
-otvorimo web stranicu: https://authjs.dev/
-otvorimo link: https://authjs.dev/getting-started/adapters/prisma
-u schema.prisma fajlu kreiramo modele User, Account, Session i VerificationToken
-u terminalu ukucamo komandu: npx prisma generate
-ukucamo komandu: npx prisma migrate dev --name add_user_based_tables
-u folderu prisma generisan novi folder za migracije
-ukucamo komandu: npx prisma studio

31. Seed User Data
-u sample-data.ts fajlu kreiramo niz users
-otvorimo link: https://www.npmjs.com/package/bcrypt-ts
-otvorimo link: https://npm.runkit.com/bcrypt-ts-edge
-u terminalu ukucamo komandu: npm install bcrypt-ts-edge
-importujemo funkciju hashSync iz paketa bcrypt-ts-edge
-u nizu users kreiramo dva objekta sa podacima o korisniku
-u objekte dodajemo polja name, email, password i role
-u seed.ts fajl, u funkciju main() dodajemo vise metoda deleteMany()
-dodajemo metodu await prisma.user.createMany() za korisnike
-u terminalu ukucamo komandu: npx tsx ./db/seed
-ukucamo komandu: npx prisma studio

32. Next Auth Setup
-otvorimo link: https://authjs.dev/getting-started
-u terminalu ukucamo komandu: npm install next-auth@5.0.0-beta.25 --legacy-peer-deps
-otvorimo link: https://www.npmjs.com/package/@auth/prisma-adapter
-ukucamo komandu: npm install @auth/prisma-adapter
-ukucamo komandu: openssl rand -base64 32
-u .env fajlu dodajemo env varijable NEXT_AUTH_SECRET, NEXTAUTH_URL i NEXTAUTH_URL_INTERNAL
-u example.env fajl dodajemo primjer varijabli koje je potrebno kreirati
-otvorimo link: https://next-auth.js.org/configuration/options
-kreiramo auth.ts fajl i importujemo funkciju NextAuth iz paketa next-auth
-kreiramo i eskportujemo objekt config
-pozivamo funkciju NextAuth(config)
-vrijednost funkcije NextAuth(config) pohranjujemo u destruktuirane varijable const { handlers, auth, signIn, signOut } 
-eksportujemo destruktuirane varijable
-u objekt config dodajemo objekte pages i session
-importujemo funkciju PrismaAdapter iz paketa auth/prisma-adapter
-importujemo instancu prisma iz db/prisma.ts fajla
-u objekt config dodajemo key-value par adapter i funkciju PrismaAdapter(prisma)
-dodajemo niz providers
-importujemo funkciju CredentialsProvider iz paketa next-auth/providers/credentials
-importujemo funkciju compareSync iz paketa bcrypt-ts-edge
-u nizu providers pozivamo funkciju CredentialsProvider() sa argumentom konfiguracionim objektom
-u konfiguracioni objekt dodajemo objekt credentials
-dodajemo metodu async authorize(credentials)
-u funkciju authorize(credentials) dodajemo uslov if (credentials === null) return null
-kreiramo varijablu const user
-dodajemo uslov if (user && user.password)
-u uslovu if kreiramo varijablu const isMatch
-dodajemo uslov if (isMatch)
-dodajemo izjavu return null ako korisnik ne postoji ili ako se unesena sifra ne slaze sa sifrom u bazi podataka
-importujemo tip NextAuthConfig iz paketa next-auth
-dodajemo objekt callbacks
-u objekt callbacks dodajemo asinhronu funkciju session()
-funkciji session dodajemo parametre { session, user, trigger, token }
-u funkciju session() dodajemo metodu session.user.id = token.sub
-dodajemo uslov if (trigger === 'update') 
-nakon uslova if dodajemo izjavu return session
-objektu config dodajemo tip satisfies NextAuthConfig

33. Next Auth Catch All API Route
-otvorimo link: https://next-auth.js.org/getting-started/example#add-api-route
-u folderu app kreiramo foldere api, auth i [...nextauth]
-u folderu [...nextauth] kreiramo route.ts fajl
-u route.ts fajl dodajemo console.log('Hello World');
-u pretrazivacu otvorimo rutu: http://localhost:3000/api/auth/session
-u route.ts fajl importujemo varijablu handlers iz auth.ts fajla
-eksportujemo funkcije GET i POST
-u pretrazivacu otvorimo rute: /api/auth/signin, /api/auth/signout i /api/auth/session

34. Sign In & Sign Out Action
-u validators.ts fajlu kreiramo i eksportujemo varijablu signInFormSchema
-u folderu lib/actions kreiramo user.actions.ts fajl
-u user.actions.ts fajl dodajemo direktivu 'use server'
-importujemo funkciju signInFormSchema iz validators.ts fajla
-importujemo funkcije signIn i signOut iz auth.ts fajla
-importujemo funkciju isRedirectError iz paketa next
-kreiramo i eksportujemo asinhronu funkciju signInWithCredentials()
-funkciji signInWithCredentials() dodajemo parametre prevState i formData sa tipovima
-dodajemo blokove koda try - catch
-u bloku koda try dodajemo metodu signInFormSchema.parse()
-vrijednost metode signInFormSchema() pohranjujemo u varijablu const user
-pozivamo funkciju await signIn('credentials, user)
-dodajemo izjavu return objekt sa key - value vrijednostima success i message
-u objekt dodajemo vrijednost success: true i poruku da je prijava uspjesna
-u blok koda catch(error) dodajemo uslov if (isRedirectError(error))
-u uslov if dodajemo throw error
-dodajemo izjavu return objekt sa key - value vrijednostima success i message
-u objekt dodajemo vrijednost success: false i poruku da je email ili sifra pogresna
-kreiramo i eksportujemo asinhronu funkciju signOutUser()
-u funkciji signOutUser() pozivamo funkciju await signOut()

35. Auth Layout & Sign In Page
-u folderu app kreiramo folder (auth)
-u folderu (auth) kreiramo komponentu layout.tsx
-u komponenti (auth)/layout.tsx kreiramo i eksportujemo funkciju AuthLayout() kao default
-u funkciji AuthLayout() kreiramo roditelj div element sa Tailwind CSS klasama
-u div element dinamicki prikazujemo vrijednost prop children
-u folderu (auth) kreiramo folder sign-in i komponentu page.tsx
-u komponenti sign-in/page.tsx kreiramo i eksportujemo funkciju SignInPage() kao default
-otvorimo link: https://nextjs.org/docs/app/building-your-application/optimizing/metadata
-importujemo tip Metadata iz paketa next
-kreiramo i eksportujemo varijablu const metadata sa tipom Metadata
-u jsx-u roditelj div elementu dodajemo Tailwind CSS klase
-importujemo komponente Card, CardContent, CardDescription, CardHeader i CardTitle iz komponente ui/card.tsx
-u div element dodajemo komponentu Card sa otvorenim i zatvorenim tagom
-u komponentu Card dodajemo komponentu CardHeader sa otvorenim i zatvorenim tagom
-importujemo komponente Link i Image iz paketa next
-importujemo varijablu APP_NAME iz lib/constants.ts fajla
-u komponentu CardHeader dodajemo komponentu Link sa prop href i className
-u komponentu Link dodajemo komponentu Image sa prop src, alt, width, height i priority
-dodajemo komponentu CardTitle sa otvorenim i zatvorenim tagom
-dodajemo komponentu CardDescription sa otvorenim i zatvorenim tagom
-u komponentu Card dodajemo komponentu CardContent sa otvorenim i zatvorenim tagom

36. Credentials Sign In Form
-u folderu sign-in kreiramo komponentu credentials-signin-form.tsx
-u komponenti credentials-signin-form.tsx kreiramo i eksportujemo funkciju CredentialsSignInForm() kao default
-u komponentu sign-in/page.tsx importujemo komponentu CredentialsSignInForm iz komponente credentials-signin-form.tsx
-u jsx-u, u komponentu CardContent dodajemo komponentu CredentialsSignInForm
-u komponentu credentials-signin-form.tsx dodajemo direktivu 'use client'
-otvorimo link: https://ui.shadcn.com/docs/components/label
-otvorimo link: https://ui.shadcn.com/docs/components/input
-u terminalu ukucamo komandu: npx shadcn@latest add input label
-u funkciji CredentialsSignInForm(), u jsx-u kreiramo form element kao roditelj element
-u form elementu kreiramo div element za email polja sa Tailwind CSS klasom space-y-6
-importujemo komponente Label i Input iz foldera components/ui
-u div element dodajemo komponente Label i Input
-komponenti Label dodajemo prop htmlFor
-komponenti Input dodajemo prop id, name, type, required i autoComplete
-u constants/index.ts fajlu kreiramo i eksportujemo varijablu objekt const signInDefaultValues
-u komponentu credentials-signin-form.tsx importujemo varijablu signInDefaultValues
-u jsx-u komponenti Input dodajemo prop defaultValue
-u prop defaultValue proslijedujemo vrijednost varijable signInDefaultValues.email
-kreiramo jos jedan div element za sifru 
-u div element dodajemo komponente Label i Input
-komponenti Input dodajemo prop defaultValue
-u prop defaultValue proslijedujemo vrijednost varijable signInDefaultValues.password
-importujemo komponentu Button iz komponente ui/button.tsx
-kreiramo div element za komponentu Button
-komponenti Button dodajemo prop className i variant
-kreiramo div element za span element i komponentu Link
-komponenti Link dodajemo prop href, target i className

37. Hook Up Sign In Form
-otvorimo link: https://react.dev/reference/react/useActionState
-otvorimo link: https://react.dev/reference/react-dom/hooks/useFormStatus
-u komponentu credentials-signin-form.tsx importujemo funkciju useAction state iz paketa react
-importujemo funkciju useFormStatus iz paketa react-dom
-importujemo funkciju signInWithCredentials iz actions/user.actions.ts fajla
-u funkciji CredentialsSignInForm() pozivamo funkciju useActionState() sa dva argumenta
-u funkciji useActionState() prvi argument je funkcija signInWithCredentials, dok je drugi argument ojekt
-vrijednost funkcije pohranjujemo u varijablu const data i funkciju action
-u jsx-u form elementu dodajemo prop action
-u prop action proslijedujemo vrijednost funkcije action
-dodajemo uslov za kondicionalno renderovanje data && !data.success && ()
-kreiramo funkciju SignInButton()
-u funkciji SignInButton() pozivamo funkciju useFormStatus()
-vrijednost funkcije useFormStatus() pohranjujemo u destruktuiranu varijablu const { pending }
-dodajemo izjavu return
-u izjavi return dodajemo komponentu Button sa prop disabled, className i variant
-u komponentu Button dodajemo uslov ternarni operator za varijablu pending
-u div element dodajemo komponentu SignInButton
-u komponentu app/(auth)/page.tsx importujemo funkciju auth iz auth.ts fajla
-importujemo funkciju redirect iz paketa next/redirect
-funkciji SignInPage() dodajemo asinhronost
-u funkciji SignInPage() pozivamo funkciju await auth()
-vrijednost funkcije await auth() pohranjujemo u varijablu const session
-dodajemo uslov if (session)
-u uslovu if (session) pozivamo funkciju return redirect('/')
-u pretrazivacu otvorimo rutu: http://localhost:3000/ i prijavimo se
-u pretrazivacu otvorimo opciju Devtools -> Application -> Cookies
-otvorimo link: http://localhost:3000/api/auth/session da vidimo podatke o prijavljenom korisniku
-u folderu sign-in kreiramo komponentu signin-button.tsx
-u komponenti signin-button.tsx kreiramo i eskportujemo funkciju SignInButton() kao default
-premjestamo logiku za komponentu SignInButton iz komponente credentials-signin-form.tsx
-u komponentu credentials-signin-form.tsx importujemo komponentu SignInButton iz komponente signin-button.tsx
-otvorimo rutu: http://localhost:3000/sign-in i prijavimo se

38. Callback URL Redirect
-otvorimo link: https://nextjs.org/docs/app/api-reference/functions/use-search-params
-u komponenti sign-in/page.tsx, funkciji SignInPage() dodajemo parametar props sa generickim tipom Promise
-u funkciji SignInPage() dodajemo metodu await props.searchParams
-vrijednost metode await props.searchParams pohranjujemo u varijablu const { callbackUrl }
-u uslov if (session) dodajemo izjavu return redirect(callbackUrl || '/')
-u komponentu sign-in-credentials.tsx importujemo funkciju useSearchParams iz paketa next/navigation
-u funkciji CredentialsSignInForm() kreiramo varijable const searchParams i const callbackUrl
-u jsx-u, u form elementu kreiramo input element sa prop type, name i value
-u prop type dodajemo opciju da je element sakriven
-u prop name dodajemo ime callbackUrl
-u prop value proslijedujemo vrijednost varijable callbackUrl
-otvorimo pretrazivac i obrisemo kolacice u aplikaciji 
-otvorimo rutu: http://localhost:3000/sign-in?callbackUrl=http%3A%2F%2Flocalhost%3A3000%2Fshipping-address i prijavimo se
-nakon prijave treba se otvoriti ruta: http://localhost:3000/shipping-address

39. User Button & Sign Out
-u projekt na web stranici Vercel dodajemo tri env varijable: NEXTAUTH_SECRET, NEXTAUTH_URL i NEXTAUTH_URL_INTERNAL
-u folderu header kreiramo komponentu user-button.tsx
-u komponenti user-button.tsx kreiramo i eksportujemo funkciju UserButton() kao default
-u komponentu menu.tsx importujemo komponentu UserButton iz komponente user-button.tsx
-u jsx-u dodajemo dvije komponente UserButton sa samozatvarajucim tagom
-u komponentu user-button.tsx importujemo komponentu Link iz paketa next
-importujemo funkciju auth iz auth.ts fajla
-importujemo komponentu Button iz komponente ui/button.tsx
-importujemo komponente DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuLabel i DropdownMenuTrigger iz komponente ui/dropdown-menu.tsx
-importujemo React ikonicu UserIcon iz paketa lucide-react
-funkciji UserButton() dodajemo asinhronost
-u funkciji UserButton() pozivamo funkciju await auth()
-vrijednost funkcije await auth() pohranjujemo u varijablu const session
-dodajemo uslov if (!session)
-u uslov if (!session) dodajemo komponentu Button za prikazivenje teksta za prijavu ako korisnik nije prijavljen
-kreiramo varijablu const firstInitial
-importujemo funkciju signOutUser iz user.actions.ts fajla
-u jsx-u roditelj div elementu dodajemo Tailwind CSS flex klase
-u div element dodajemo komponentu DropdownMenu sa otvorenim i zatvorenim tagom
-u komponentu DropdownMenu dodajemo komponentu DropdownMenuTrigger sa otvorenim i zatvorenim tagom
-u komponenti DropdownMenuTrigger kreiramo div element sa Tailwind CSS flex klasama
-u div element dodajemo komponentu Button sa prop variant, className
-u komponenti Button dinamicki prikazujemo vrijednost varijable firstInitial
-u komponentu DropdownMenu dodajemo komponentu DropdownMenuContent sa otvorenim i zatvorenim tagom 
-komponenti DropdownMenuContent dodajemo prop className, align i forceMount
-u komponentu DropdownMenuContent dodajemo komponentu DropdownMenuLabel sa otvorenim i zatvorenim tagom
-u komponenti DropdownMenuLabel kreiramo div element sa Tailwind CSS klasama
-u div elementu kreiramo dva p elementa sa Tailwind CSS klasama u kojima dinamicki prikazujemo ime i email prijavljenog korisnika
-u komponentu DropdownMenuContent dodajemo komponentu DropdownMenuItem sa otvorenim i zatvorenim tagom
-u komponenti DropdownMenuContent kreiramo form element sa prop action
-u prop action proslijedujemo funkciju signOutUser
-u form element dodajemo komponentu Button sa tekstom Sign Out

40. Sign Up Zod Schema & Action
-u validators.ts fajlu kreiramo i eksportujemo varijablu const signUpFormSchema
-funkciji z.object({ }) dodajemo metodu refine()
-u user.actions.ts fajl importujemo varijablu signUpFormSchema iz validators.ts fajla
-importujemo funkciju hashSync iz paketa bcrypt-ts-edge
-importujemo instancu prisma iz db/prisma.ts fajla
-kreiramo i eksportujemo asinhronu funkciju signUp() sa dva parametra
-u funkciji signUp() prvi parametar je prevState sa tipom unknown, dok je drugi parametar formData sa tipom FormData
-u funkciji signUp() dodajemo blokove koda try - catch
-u bloku koda try dodajemo metodu signUpFormSchema.parse()
-vrijednost metode signUpFormSchema.parse() pohranjujemo u varijablu const user
-kreiramo varijablu const plainPassword
-dodajemo metodu hashSync(user.password, 10)
-vrijednost metode hashSync(user.password, 10) pohranjujemo u objekt polje user.password
-pozivamo metodu await prisma.user.create()
-u funkciju create() dodajemo konfiguracioni objekt
-u konfiguracioni objekt dodajemo objekt data { ... }
-pozivamo funkciju await signIn() sa dva argumenta
-u funkciji signIn() prvi argument je string credentials, dok je drugi argument objekt koji sadrzi polja o imenu u hasovanoj sifri
-dodajemo objekt izjavu return sa poljima success: true i porukom da je korisnik uspjesno kreiran
-u blok koda catch (error) dodajemo uslov if (isRedirectError(error))
-dodajemo objekt izjavu return sa poljima success: false i porukom da je doslo do greske

41. Sign Up Page & Form
-u folderu (auth) kreiramo folder sign-up i komponentu page.tsx
-u komponenti sign-up/page.tsx kreiramo i eksportujemo funkciju SignUpPage()
-kopiramo vecinu koda iz komponente sign-in/page.tsx u komponentu sign-up/page.tsx
-u folderu sign-up kreiramo komponentu sign-up-form.tsx
-kopiramo vecinu koda iz komponente sign-in/credentials-sign-form.tsx u komponentu sign-up-form.tsx
-u constants/index.ts fajlu kreiramo i eksportujemo varijablu signUpDefaultValues
-u komponentu sign-up-form.tsx importujemo varijablu signUpDefaultValues
-importujemo funkciju signUp iz user.actions.ts fajla
-kreiramo komponentu sign-up-button.tsx 
-u komponenti sign-up-button.tsx kreiramo i eksportujemo funkciju SignUpButton() kao default
-u komponentu sign-up-form.tsx importujemo komponentu SignUpButton iz komponente sign-up-button.tsx
-u komponentu sign-up/page.tsx importujemo komponentu SignUpForm iz komponente sign-up-form.tsx
-otvorimo rutu: http://localhost:3000/sign-up i registrujemo se

42. Sign Up Error Handling
-u komponenti sign-up-form.tsx, komponentama Input brisemo prop required
-komponenti Input za email dodajemo prop type='text'
-otvorimo rutu: http://localhost:3000/sign-up i pokusamo se regitrovati sa netacnim kredencijalima
-u lib/utils.ts fajlu kreiramo i eksportujemo asinhronu funkcija formatError() sa parametrom error
-parametru error dodajemo tip any
-u funkciji formatError() dodajemo uslov if (error.name === 'ZodError')
-dodajemo uslove else if i else
-u uslovu if dodajemo metodu Object.keys(error.errors).map((field) => { ... })
-u funkciji map() kreiramo varijablu const message
-dodajemo izjavu ternarni operator return typeof message === 'string'
-vrijednost metode Object.keys() pohranjujemo u varijablu const fieldErrors
-dodajemo izjavu return fieldErrors.join('. ')
-u user.actions.ts fajl importujemo funkciju formatError iz utils.ts fajla
-funkciju signUp preimenujemo u signUpUser
-u funkciju signUpUser, u izjavu objekt return, u polje message dodajemo funkciju formatError(error)
-u utils.ts fajlu, u funkciji formatError(), u uslovu else if kreiramo varijablu const field
-dodajemo izjavu return poruku da korisnik sa tom email adresom postoji
-u uslov else dodajemo izjavu uslov ternarni operator return typeof error.message === 'string'

43. Customize Token with JWT Callback
-manje izmjene u semama za prijavu i registraciju korisnika u validators.ts fajlu
-otvorimo link: https://next-auth.js.org/configuration/callbacks
-u auth.ts fajlu kreiramo asinhronu funkciju jtw() sa parametrima destruktuiranom prop { token, user, trigger, session }
-parametrima dodajemo tip any
-u funkciju jwt() dodajemo uslov if (user)
-dodajemo izjavu return token
-u funkciju session() dodajemo vrijednosti session.user.role i session.user.name
-promjenimo uslov if (trigger === 'update') u if (trigger === 'update' && token.name)
-u funkciju jtw() dodajemo uslov if (session?.user.name && trigger === 'update')
-otvorimo rutu: http://localhost:3000/sign-in i prijavio se
-u VS Code terminalu provjerimo vrijednost za token
-otvorimo rutu: http://localhost:3000/api/auth/session da provjerimo informacije za prijavljenog korisnika


Section 05: Add To Cart

44. Section Intro

45. Cart Zod Schema & Prisma Model
-u validators.ts fajlu kreiramo i eksportujemo varijablu cartItemSchema
-kreiramo i eksportujemo varijablu const insertCartSchema
-u types/index.ts fajlu importujemo varijable insertCartSchema i cartItemSchema
-kreiramo i eksportujemo tipove Cart i CartItem
-u schema.prisma kreiramo model Cart
-modelu User dodajemo model Cart
-u terminalu ukucamo komandu: npx prisma generate
-u terminalu ukucamo komandu: npx prisma migrate dev --name add-cart
-u terminalu ukucamo komandu: npx prisma studio
-u folderu prisma/migrations se generise folder add_cart i migration.sql fajl

46. Add To Cart Component
-u folderu shared/product kreiramo komponentu add-to-cart.tsx
-u komponenti add-to-cart.tsx kreiramo i eksportujemo funkciju AddToCart() kao default
-dodajemo direktivu 'use client'
-importujemo tip CartItem iz foldera types
-funkciji AddToCart() dodajemo parametar destruktuirani prop item
-destruktuiranom parametru item dodajemo tip CartItem
-u komponentu product/[slug]/page.tsx importujemo komponentu AddToCart iz komponente add-to-cart.tsx
-izbrisemo import za komponentu Button
-u jsx-u, u uslovu za kondicionalno renderovanje product?.stock > 0 && dodajemo komponentu AddToCart
-komponenti AddToCart dodajemo prop item
-u komponentu add-to-cart.tsx importujemo komponentu Button iz komponente ui/button.tsx
-otvorimo link: https://nextjs.org/docs/pages/api-reference/functions/use-router
-importujemo funkciju useRouter iz paketa next/navigation
-importujemo React ikonicu Plus iz paketa lucide-react
-otvorimo link: https://ui.shadcn.com/docs/components/toast
-u terminalu ukucamo komandu: npx shadcn@latest add toast
-u folderu components/ui se generisu komponente toast.tsx i toaster.tsx
-generise se folder hooks sa use-toast.ts fajlom
-u komponentu app/layout.tsx importujemo komponentu Toaster iz komponente ui/toaster
-u jsx-u, u komponentu ThemeProvider dodajemo komponentu Toaster sa samozatvarajucim tagom
-u komponentu add-to-cart.tsx importujemo funkciju useToast iz hooks/use-toast.ts fajla
-importujemo komponentu ToastAction iz komponente ui/toast.tsx
-u jsx-u, dodajemo komponentu Button sa prop className, type i onClick
-kreiramo asinhronu funkciju handleAddToCart()
-u folderu lib/actions kredencijalima cart.actions.ts fajl
-u cart.actions.ts fajl dodajemo direktivu 'use server'
-importujemo tip CartItem iz foldera types
-kreiramo i eksportujemo asinhronu funkciju addItemToCart() sa parametrom data
-parametru data dodajemo tip CartItem
-u funkciju addItemToCart() dodajemo izjavu objekt return sa key - value parovima success i message
-u komponentu add-to-cart.tsx importujemo funkciju addItemToCart iz foldera lib/actions
-u funkcija AddToCart() pozivamo funkcije useRouter() i useToast()
-vrijednost funkcije useRouter() pohranjujemo u destruktuiranu varijablu const router
-vrijednost funkcije useToast() pohranjujemo u destruktuiranu varijablu const { toast }
-u funkciji handleAddToCart() pozivamo funkciju await addItemToCart(item)
-vrijednost funkcije await addItemToCart(item) pohranjujemo u varijablu const res
-dodajemo uslov if (!res.success)
-u uslovu if (!res.success) pozivamo funkciju toast()
-funkciji toast() dodajemo argument objekt sa key - value parovima variant i description
-nakon funkcije toast() dodajemo izjavu return
-nakon uslova if (!res.success) pozivamo funkciju toast()
-funkciji toast() dodajemo argument objekt sa key - value parovima description i action
-u prop action dodajemo komponentu ToastAction sa otvorenim i zatvorenim tagom
-komponenti ToastAction dodajemo prop className, altText i dogadaj onClick
-u dogadaj onClick proslijedujemo anonimnu funkciju
-u anonimnu funkciju proslijedujemo funkciju router.push('/cart')
-otvorimo rutu http://localhost:3000/product/[slug] i kliknemo dugme Add To Cart
-importujemo React ikonicu Plus iz paketa lucide-react
-u komponenti Button kreiramo dva span element
-u prvi span element dodajemo komponentu Button, dok u drugi span element dodajemo tekst Add To Cart

47. Session Cart ID Cookie
-otvorimo link: https://vercel.com/docs/functions/limitations#code-size-limit
-otvorimo link: https://gist.github.com/bradtraversy/16e3c89b9b25bc79cf86f5f36e14e83d
-otvorimo link: https://authjs.dev/reference/nextjs#authorized
-kreiramo middleware.ts fajl
-u middleware.ts fajlu eksportujemo funkciju auth kao middleware
-u auth.ts fajl importujemo funkcije cookies i NextResponse iz paketa next
-kreiramo funkciju authorized() sa destruktuirana parametra request i auth
-u funkciju authorized dodajemo uslov if - else
-pozivamo funkciju crypto.randomUUID()
-vrijednost funkcije crypto.randomUUID() pohranjujemo u varijablu const sessionCartId
-pozivamo funkciju new Headers(request.headers)
-vrijednost funkcije new Headers(request.headers) pohranjujemo u varijablu const newRequestHeaders
-pozivamo funkciju NextResponse.next()
-vrijednost funkcije NextResponse.next() pohranjujemo u varijablu const response
-pozivamo funkciju response.cookies.set()
-dodajemo izjavu return response
-u uslov else dodajemo izjavu return true

Vercel Deploy Error Edge Function "middleware" fix
-Error: The Edge Function "middleware" size is 1.02 MB and your plan size limit is 1 MB. Learn More: https://vercel.link/edge-function-size
-otvorimo link: https://authjs.dev/guides/edge-compatibility
-otvorimo link: https://gist.github.com/bushblade/73a85d7bb145d17d7dbb6bea68f11f9e
-kreiramo auth.config.ts fajl
-u auth.config.ts fajl importujemo tip NextAuthConfig i funkciju NextResponse iz paketa next
-kreiramo i eksportujemo objekt const authConfig
-u objekt authConfig dodajemo niz providers i objekt callbacks
-u middleware.ts fajl importujemo objekt authConfig
-u auth.ts fajl importujemo objekt authConfig
-u objekt callbacks dodajemo ...authConfig.callbacks

48. Get Item From Cart
-u cart.actions.ts fajl importujemo funkcije cookies i formatError iz foldera utils
-u funkciju addItemToCart() dodajemo blokove koda try - catch
-u blokove koda try - catch dodajemo izjave return i objekte sa key - value parovima success i message
-u funkciji addItemToCart() pozivamo funkciju await cookies()
-vrijednost funkcije await cookies() pohranjujemo u varijablu const sessionCartId 
-dodajemo uslov if (!sessionCartId)
-importujemo funkciju auth iz auth.ts fajla
-pozivamo funkciju await auth()
-vrijednost funkcije await auth() pohranjujemo u varijablu const session
-kreiramo varijablu const userId
-kreiramo i eksportujemo asinhronu funkciju getMyCart()
-importujemo instancu prisma prisma.ts fajla
-u funkciji getMyCart() kreiramo varijablu const sessionCartId
-dodajemo uslov if (!sessionCartId)
-kreiramo varijable const session i const userId
-pozivamo funkciju await prisma.card.findFirst()
-vrijednost funkcije await prisma.card.findFirst() pohranjujemo u varijablu const cart
-dodajemo uslov if (!cart) return undefined
-importujemo funkciju convertToPlainObject iz utils.ts fajla
-dodajemo izjavu return convertToPlainObject()
-u funkciji addItemToCart() pozivamo funkciju await getMyCart()
-vrijednost funkcije await getMyCart() pohranjujemo u varijablu const cart
-importujemo varijablu cartItemSchema iz validators.ts fajla
-kreiramo varijablu const item
-pozivamo funkciju await prisma.product.findFirst()
-vrijednost funkcije await prisma.product.findFirst() pohranjujemo u varijablu const product

49. Price Calc & Add To Database
-u lib/utils.ts fajlu kreiramo i eksportujemo funkciju round2() sa parametrom value
-parametru value dodajemo tipove number | string
-u funkciju round2() dodajemo uslove if - else if - else
-u cart.actions.ts fajl importujemo funkciju round2 iz utils.ts fajla
-kreiramo funkciju calcPrice() sa parametrom items
-parametru items dodajemo tip CartItem[]
-u funkciji calcPrice() pozivamo funkciju round2()
-vrijednost funkcije round2() pohranjujemo u varijablu const itemsPrice
-dodajemo izjavu return objekt sa key - value parovima itemsPrice, shippingPrice, taxPrice i totalPrice
-importujemo varijablu insertCartSchema iz validators.ts fajla
-u funkciju addItemToCart() dodajemo uslov if (!product)
-dodajemo uslov if (!cart)
-u uslovu if (!cart) kreiramo varijablu const newCart
-otvorimo rutu http://localhost:3000/product/[slug] i kliknemo dugme Add To Cart
-pozivamo funkciju await prisma.cart.create()
-importujemo funkciju revalidatePath iz paketa next/cache
-pozivamo funkciju revalidatePath()
-izjavu return objekt sa key - value parovima success i message premjestamo u uslov if (!cart)

50. Handle Quantity & Multiple Products
-u cart.actions.ts fajl importujemo instancu Prisma iz paketa prisma/client
-za uslov if (!cart) dodajemo uslov else
-u uslovu else kreiramo varijablu const existItem
-dodajemo uslov if (existItem) - else
-u uslov if (existItem) dodajemo uslov if (product.stock < existItem.qty + 1) 
-u uslov if pozivamo funkciju throw new Error()
-nakon uslova if pozivamo funkciju (cart.items as CartItem[]).find()
-u uslov else dodajemo uslov if (product.stock < 1)
-u uslov if (product.stock < 1) pozivamo funkciju throw new Error()
-nakon uslova if pozivamo funkciju cart.items.push(item)
-pozivamo funkciju await prisma.cart.update()
-pozivamo funkciju revalidatePath()
-dodajemo izjavu return objekt sa key - value parovima success i message
-u komponentu add-to-cart.tsx, u funkciju toast dodajemo description: res.message
-otvorimo rutu: http://localhost:3000/product/[slug] i kliknemo dugme Add To Cart da vidimo poruku

51. Remove Cart Action
-u cart.actions.ts fajlu kreiramo i eksportujemo funkciju removeItemFromCart() sa parametrom productId
-parametru productId dodajemo tip string
-u funkciju removeItemFromCart() dodajemo blokove koda try - catch
-u blok koda catch dodajemo izjavu return objekt sa key - value parovima success i message
-u bloku koda try kreiramo varijablu const sessionCartId
-dodajemo uslov if (!sessionCartId) 
-pozivamo funkciju await prisma.product.findFirst()
-vrijednost funkcije await prisma.product.findFirst() pohranjujemo u varijablu const product
-dodajemo uslov if (!product)
-u uslov if (!product) pozivamo funkciju throw new Error()
-nakon uslova if (!product) pozivamo funkciju await getMyCart()
-vrijednost funkcije await getMyCart() pohranjujemo u varijablu const cart
-dodajemo uslov if (!cart)
-u uslovu if (!cart) pozivamo funkcija throw new Error()
-pozivamo funkciju (cart.items as CartItem[]).find()
-vrijednost funkcije (cart.items as CartItem[]).find() pohranjujemo u varijablu const existItem
-dodajemo uslov if (!existItem) 
-u uslovu if (!existItem) pozivamo funkciju throw new Error()
-dodajemo uslove if (existItem.qty === 1) - else
-nakon uslova if - else pozivamo funkciju await prisma.cart.update()
-pozivamo funkciju revalidatePath()
-dodajemo izjavu return objekt sa key - value parovima success i message

52. Dynamic Cart Button
-u komponentu product/[slug]/page.tsx importujemo funkciju getMyCart iz cart.actions.ts fajla
-u funkciji ProductDetailsPage() pozivamo funkciju getMyCart()
-vrijednost funkcije getMyCart() pohranjujemo u varijablu const cart
-u jsx-u, komponenti AddToCart dodajemo prop cart u koji proslijedujemo varijablu cart
-u komponentu add-to-cart.tsx importujemo funkciju removeItemFromCart
-importujemo tip Cart
-importujemo React ikonicu Minus
-funkciji AddToCart() dodajemo parametar destruktuirani prop cart
-destruktuiranom parametru cart dodajemo tip Cart
-kreiramo varijablu const existItem
-kreiramo funkciju handleRemoveFromCart()
-u jsx-u dodajemo izjavu return ternarni operator za varijablu existItem
-u prvi dio ternarnog operatora kreiramo roditelj div element
-u roditelj div element dodajemo dvije komponente Button
-prvoj komponenti Button dodajemo prop type, variant i dogadaj onClick
-u dogadaj onClick proslijedujemo funkciju handleRemoveFromCart
-u komponentu Button dodajemo React ikonicu Minus
-kreiramo span element sa prop className
-u span elementu dinamicki prikazujemo vrijednost varijable existItem.qty
-drugoj komponenti Button dodajemo prop type, variant i dogadaj onClick
-u dogadaj onClick proslijedujemo funkciju handleAddToCart
-u komponentu Button dodajemo React ikonicu Plus
-u drugi dio ternarnog operatora dodajemo komponentu Button i React ikonicu Plus
-funkciji handleRemoveFromCart() dodajemo asinhronost 
-u funkciji handleRemoveFromCart() pozivamo funkciju await removeItemFromCart(item.productId)
-vrijednost funkcije await removeItemFromCart(item.productId) pohranjujemo u varijablu const res
-pozivamo funkciju toast() sa argumentom objekt
-u objekt dodajemo key - value parove variant i description
-nakon funkcije toast() dodajemo izjavu return

53. Smooth UI With useTransition Hook
-otvorimo link: https://react.dev/reference/react/useTransition
-u komponentu add-to-cart.tsx importujemo funkciju useTransition iz paketa react
-importujemo React ikonicu Loader iz paketa lucide-react
-u funkciji AddToCart() pozivamo funkciju useTransition()
-vrijednost funkcije useTransition() pohranjujemo u destruktuirane varijable const [isPending, startTransition]
-u funkcije handleAddToCart() i handleRemoveFromCart() pozivamo funkciju startTransition()
-u funkcije startTransition() proslijedujemo kao argument anonimne asinhrone funkcije
-u komponente Button dodajemo uslov ternarni operator za varijablu isPending
-u prvi dio ternarnog operatora dodajemo komponentu Loader
-komponenti Loader dodajemo prop className i animate-spin
-u drugi dio ternarnog operatora dodajemo React ikonicu Plus ili Minus 


Section 06: Cart & Shipping Pages

54. Section Intro

55. Cart Page
-u folderu (root)/cart kreiramo komponentu page.tsx
-u komponenti cart/page.tsx kreiramo i eksportujemo funkciju CartPage() kao default
-kreiramo i eskportujemo varijablu const metadata
-kreiramo komponentu cart-table.tsx
-u komponenti cart-table.tsx kreiramo i eskportujemo funkciju CartTable() kao default
-u komponentu cart-table.tsx dodajemo direktivu 'use client'
-importujemo tip Cart iz types/index.ts fajla
-u komponentu cart/page.tsx importujemo komponentu CartTable iz komponente cart-table.tsx
-u komponenti cart-table.tsx funkciji CartTable() dodajemo parametar destruktuirani prop cart sa tipom Cart
-u jsx-u kreiramo h2 element sa Tailwind CSS klasama
-u komponentu cart/page.tsx importujemo funkciju getMyCart iz cart.actions.ts fajla
-funkciji CartPage() dodajemo asinhronost
-u funkciji CartPage() pozivamo funkciju await getMyCart()
-vrijednost funkcije await getMyCart() pohranjujemo u varijablu const cart
-u jsx-u dodajemo komponentu CartTable sa prop cart
-u komponentu cart-table.tsx importujemo funkcije useRouter, useTransition, addItemToCart, removeItemFromCart i useToast
-importujemo React ikonice ArrowRight, Loader, Minus i Plus
-importujemo komponente Link i Image
-pozivamo funkciju useRouter()
-vrijednost funkcije useRouter() pohranjujemo u varijablu const router
-pozivamo funkciju useToast() 
-vrijednost funkcije useToast() pohranjujemo u varijablu const { toast }
-pozivamo funkciju useTransition()
-vrijednost funkcije useTransition() pohranjujemo u varijable const [isPending, startTransition]
-u jsx-u dodajemo ternarni uslov !cart || cart.items.length === 0
-otvorimo rutu: http://localhost:3000/cart

56. ShadCN UI Table
-otvorimo link: https://ui.shadcn.com/docs/components/table
-u terminalu ukucamo komandu npx shadcn@latest add table
-u komponentu cart-table.tsx importujemo komponente Table, TableBody, TableHead,  TableHeader, TableRow i TableCell iz komponente ui/table.tsx
-importujemo komponentu Button iz komponente ui/button.tsx
-u div element sa klasom overflow-x-auto md:col-span-3 dodajemo Table komponente iz komponente ui/table.tsx
-u komponentu TableBody dodajemo funkciju cart.items?.map()
-otvorimo rutu: http://localhost:3000/cart

57. Subtotal Card
-u lib/utils.ts fajlu kreiramo varijablu CURRENCY_FORMATTER
-kreiramo i eksportujemo funkciju formatCurrency() sa parametrom amount
-parametru amount dodajemo tipove number, string i null
-u funkciju formatCurrency() dodajemo uslove if, else if i else
-u komponentu cart-table.tsx importujemo funkciju formatCurrency iz lib/utils.ts fajla
-importujemo komponente Card i CardContent iz komponente ui/card.tsx
-u div element sa klasom grid md:grid-cols-4 md:gap-5 dodajemo komponentu Card
-u komponentu Card dodajemo komponentu CardContent sa prop className
-u komponenti CardContent kreiramo div element sa Tailwind CSS klasama
-u div elementu kreiramo dva span elementa
-u prvi span element dodajemo funkciju cart.items.reduce()
-u drugi span element dodajemo funkciju formatCurrency(cart.itemsPrice)
-u komponentu CardContent dodajemo komponentu Button sa prop className, disabled i onClick
-u komponenti Button kreiramo dva span elementa
-u prvi span element dodajemo uslov ternarni operator isPending 
-u drugi span element dodajemo tekst Proceed to Checkout

58. Shipping Address Zod Schema & Page
-u lib/validators.ts fajlu kreiramo i eksportujemo varijablu shippingAddressSchema
-u types/index.ts fajl importujemo varijablu shippingAddressSchema
-eksportujemo tip ShippingAddress
-u constants/index.ts fajlu kreiramo i eskportujemo varijablu shippingAddressDefaultValues
-u folderu (root) kreiramo folder shipping-address i komponentu page.tsx
-u komponenti shipping-address/page.tsx kreiramo i eksportujemo funkciju ShippingAddressPage() kao default
-u user.actions.ts fajlu kreiramo i eksportujemo asinhronu funkciju getUserById()
-u komponentu shipping-address/page.tsx importujemo funkcije redirect, auth, getMyCart i getUserById
-importujemo tipove Metadata i ShippingAddress
-funkciji ShippingAddressPage() dodajemo asinhronost
-kreiramo i eksportujemo varijablu const metadata
-u funkciji ShippingAddressPage() pozivamo funkciju await getMyCart()
-vrijednost funkcije await getMyCart() pohranjujemo u varijablu const cart
-dodajemo uslov if (!cart || cart.items.length === 0)
-u uslovu if pozivamo funkciju redirect('/cart')
-pozivamo funkciju await auth()
-vrijednost funkcije await auth() pohranjujemo u varijablu const session
-kreiramo varijablu const userId
-dodajemo uslov if (!userId) 
-u uslov if (!userId) dodajemo throw new Error()
-pozivamo funkciju await getUserById(userId)
-vrijednost funkcije await getUserById(userId) pohranjujemo u varijablu const user

59. Shipping Address & Form
-u folderu shipping-address kreiramo komponentu shipping-address-form.tsx
-u komponenti shipping-address-form.tsx kreiramo i eksportujemo funkciju ShippingAddressForm()
-dodajemo direktivu 'use client'
-importujemo tip ShippingAddress iz types/index.ts fajla
-funkciji ShippingAddressForm() dodajemo parametar destruktuirani prop address
-u komponentu shipping-address/page.tsx importujemo komponentu ShippingAddressForm iz komponente shipping-address-form.tsx
-u jsx-u dodajemo prazan fragment kao roditelj element
-u prazan fragment dodajemo komponenta ShippingAddressForm sa prop address
-u prop address proslijedujemo varijablu user.address as ShippingAddress
-u komponentu shipping-address-form.tsx importujemo funkcije useTransition, useRouter i useToast
-importujemo varijablu shippingAddressSchema iz lib/validators.ts fajla
-u funkciji ShippingAddressForm() pozivamo funkciju useRouter()
-vrijednost funkcije useRouter() pohranjujemo u varijablu const router
-pozivamo funkciju useToast() 
-vrijednost funkcije useToast() pohranjujemo u destruktuiranu varijablu const { toast }
-otvorimo link: https://www.npmjs.com/package/react-hook-form
-otvorimo link: https://github.com/react-hook-form/resolvers
-u terminalu ukucamo komandu: npm i react-hook-form @hookform/resolvers
-otvorimo link: https://ui.shadcn.com/docs/components/form
-u terminalu ukucamo komandu: npx shadcn@latest add form
-importujemo funkcije useForm i zodResolver
-importujemo instancu z iz paketa zod
-importujemo varijablu shippingAddressDefaultValues iz lib/constants.ts fajla
-kreiramo varijablu const form
-pozivamo funkciju useTransition()
-vrijednost funkcije useTransition() pohranjujemo u varijable const [isPending, startTransition]
-importujemo komponente Form, FormControl, FormField, FormItem, FormLabel i FormMessage iz komponente ui/form.tsx
-importujemo komponentu Input iz komponente ui/input.tsx
-u jsx-u dodajemo prazan fragment kao roditelj element
-u praznom fragmentu kreiramo div element sa Tailwind CSS klasama
-u div elementu kreiramo elemente h1 i p sa Tailwind CSS klasama
-u div element dodajemo komponentu Form sa otvorenim i zatvorenim tagom
-komponenti Form dodajemo prop {...form}
-u komponenti Form kreiramo form element
-form elementu dodajemo atribute method, className i dogadaj onSubmit
-kreiramo funkciju onSubmit() sa parametrom values
-parametru values dodajemo tip z.infer<typeof shippingAddressSchema>
-u dogadaj onSubmit proslijedujemo funkciju form.handleSubmit(onSubmit)
-u form elementu kreiramo div element sa Tailwind CSS klasama
-u komponentu div dodajemo komponentu FormField za puno ime korisnika sa samozatvarajucim tagom
-komponenti FormField dodajemo prop control, name i render
-u prop render proslijedujemo anonimnu funkciju sa parametrom destruktuiranim prop field
-u anonimnu funkciju dodajemo komponente FormItem, FormLabel, FormControl, Input i FormMessage
-kreiramo div element i komponentu FormField za korisnikovu adresu
-kreiramo div element i komponentu FormField za korisnikov grad
-kreiramo div element i komponentu FormField za korisnikov postanski broj
-kreiramo div element i komponentu FormField za korisnikovu drzavu
-kreiramo div element sa Tailwind CSS klasama flex gap-2
-importujemo komponentu Button iz komponente ui/button.tsx
-u div element dodajemo komponentu Button sa prop type i disabled
-importujemo React ikonice Loader i ArrowRight iz paketa lucide-react
-u komponentu Button dodajemo uslov ternarni operator za varijablu isPending
-otvorimo rutu: http://localhost:3000/shipping-address

60. Update User Address
-u user.actions.ts fajl importujemo funkciju auth iz auth.ts fajla
-importujemo tip ShippingAddress iz types/index.ts fajla
-importujemo varijablu shippingAddressSchema iz validators.ts fajla
-kreiramo i eksportujemo asinhronu funkciju updateUserAddress() sa parametrom data
-parametru data dodajemo tip ShippingAddress
-dodajemo blokove koda try - catch
-u bloku koda try kreiramo varijablu const session
-kreiramo varijablu const currentUser
-dodajemo uslov if (!currentUser)
-kreiramo varijablu const address
-pozivamo funkciju await prisma.user.update()
-dodajemo izjavu objekt return da je korisnikova adresa uspjesno izmjenjena
-u blok koda catch dodajemo izjavu objekt return da je doslo do greske
-u komponentu shipping-address-form.tsx importujemo funkciju updateUserAddress iz user.actions.ts fajla
-importujemo tip SubmitHandler iz paketa react-hook-form
-funkciji onSubmit() dodajemo asinhronost
-funkciji onSubmit() dodajemo tip SubmitHandler<z.infer<typeof shippingAddressSchema>>
-u funkciji onSubmit() pozivamo funkciju startTransition()
-u funkciji startTransition() pozivamo anonimnu asinhronu funkciju
-u anonimnoj asinhronoj funkciji kreiramo varijablu const res
-dodajemo uslov if (!res.success)
-pozivamo funkciju router.push('/payment-method')
-otvorimo rutu: http://localhost:3000/shipping-address

61. Checkout Steps Component
-otvorimo link: https://react.dev/reference/react/Fragment
-u folderu components/shared kreiramo komponentu checkout-steps.tsx
-u komponenti checkout-steps.tsx kreiramo i eksportujemo funkciju CheckoutSteps() kao default
-importujemo komponentu Fragment iz paketa react
-importujemo funkciju cn iz utils.ts fajla
-funkciji CheckoutSteps() dodajemo parametar destruktuirani prop current = 0
-u jsx-u roditelj div elementu dodajemo Tailwind CSS klase
-kreiramo varijablu niz checkoutSteps
-u roditelj div elementu dodajemo funkciju checkoutSteps?.map()
-u funkciju map() proslijedujemo anonimnu funkciju sa parametrima step i index
-u anonimnu funkciju dodajemo komponentu Fragment sa otvorenim i zatvorenim tagom
-komponenti Fragment dodajemo prop key
-u komponenti Fragment kreiramo div element sa prop className
-u prop className proslijedujemo funkciju cn()
-u div elementu dinamicki prikazujemo vrijednost varijable step
-u komponentu Fragment dodajemo uslov za kondicionalno renderovanje step !== 'Place Order' && ()
-u komponentu shipping-address/page.tsx importujemo komponentu CheckoutSteps iz komponente CheckoutSteps.tsx
-u jsx-u dodajemo komponentu CheckoutSteps sa prop current
-otvorimo rutu: http://localhost:3000/shipping-address

62. Persist Session Cart
-u auth.ts fajlu, u funkciju jwt() dodajemo uslov if (trigger === 'signIn' || trigger === 'signUp')
-u uslovu if pozivamo funkciju await cookies()
-vrijednost funkcije await cookies() pohranjujemo u varijablu const cookiesObject
-pozivamo funkciji cookiesObject.get()
-vrijednost funkcije cookiesObject.get() pohranjujemo u varijablu const sessionCartId
-dodajemo uslov if (sessionCartId)
-u uslovu if (sessionCartId) pozivamo funkciju await prisma.cart.findFirst()
-vrijednost funkcije await prisma.cart.findFirst() pohranjujemo u varijablu const sessionCart
-dodajemo uslov if (sessionCart)
-u uslovu if (sessionCart) pozivamo funkciju await prisma.cart.deleteMany()
-pozivamo funkciju await prisma.cart.update()

63. Protecting Paths
-u auth.config.ts fajlu, u funkciji authorized() kreiramo niz const protectedPaths
-iz varijable request.nextUrl destruktuiramo varijablu const { pathname }
-dodajemo uslov if (!auth && protectedPaths.some((path) => path.test(pathname)))
-u uslov if dodajemo izjavu return false
-odjavimo se iz aplikacije i otvorimo rutu: http://localhost:3000/shipping-address
-otvorimo link: https://www.udemy.com/course/nextjs-ecommerce-course/learn/lecture/47571607#questions/22806241/


Section 07: Payment Method & Order Pages

64. Section Intro

65. Payment Method Action & Zod Schema
-u .env fajlu kreiramo varijable PAYMENT_METHODS i DEFAULT_PAYMENT_METHOD
-u example.env fajl dodajemo primjer env varijabli koje je potrebno kreirati
-u constants/index.ts fajlu kreiramo i eksportujemo varijable PAYMENT_METHODS i DEFAULT_PAYMENT_METHOD
-u validators.ts fajl importujemo varijablu PAYMENT_METHODS iz constants/index.ts fajla
-kreiramo i eksportujemo varijablu const paymentMethodSchema
-u user.actions.ts fajl importujemo varijablu paymentMethodSchema iz validators.ts fajla
-importujemo instancu z iz paketa zod
-kreiramo i eksportujemo asinhronu funkciju updateUserPaymentMethod()
-funkciji updateUserPaymentMethod() dodajemo parametar data
-parametru data dodajemo tip z.infer<typeof paymentMethodSchema>
-dodajemo blokove koda try - catch
-u blok koda catch dodajemo izjavu objekt return da je doslo do greske prilikom izmjene metode placanja
-u bloku koda try pozivamo funkciju await auth()
-vrijednost funkcije await auth() pohranjujemo u varijablu const session
-pozivamo funkciju await prisma.user.findFirst()
-vrijednost funkcije await prisma.user.findFirst() pohranjujemo u varijablu const currentUser
-dodajemo uslov if (!currentUser)
-otvorimo link: https://stackoverflow.com/questions/74853013/next-js-error-session-user-is-possibly-undefined-but-im-able-to-acc
-kreiramo varijablu const paymentMethod
-pozivamo funkciju await prisma.user.update()
-dodajemo izjavu objekt return da je izmjena metode placanja uspjesna

66. Payment Method Page
-u folderu app/(root) kreiramo folder payment-method i komponentu page.tsx
-u komponenti payment-method/page.tsx kreiramo i eksportujemo funkciju PaymentMethodPage() kao default
-funkciji PaymentMethodPage() dodajemo asinhronost
-importujemo tip Metadata iz paketa next
-importujemo funkcije auth i getUserById
-kreiramo i eksportujemo varijablu const metadata sa tipom Metadata
-u funkciji PaymentMethodPage() kreiramo varijable const session i const userId
-dodajemo uslov if (!userId) 
-kreiramo varijablu const user
-kreiramo komponentu payment-method-form.tsx
-u komponenti payment-method-form.tsx kreiramo i eksportujemo funkciju PaymentMethodForm() kao default
-dodajemo direktivu 'use client'
-funkciji PaymentMethodForm() dodajemo parametar destruktuirani prop preferredPaymentMethod
-importujemo funkcije useTransition, useRouter, useForm, zodResolver i useToast
-importujemo instancu z iz paketa zod
-importujemo varijablu paymentMethodSchema iz validators.ts fajla
-importujemo varijablu DEFAULT_PAYMENT_METHOD iz constants/index.ts fajla
-importujemo komponentu CheckoutSteps iz komponente CheckoutSteps.tsx
-u funkciji PaymentMethodForm() kreiramo varijablu const router
-pozivamo funkciju useToast()
-vrijednost funkcije useToast pohranjujemo u destruktuiranu varijablu const { toast }
-kreiramo varijablu const form 
-pozivamo funkciju useTransition()
-vrijednost funkcije useTransition() pohranjujemo u destruktuirane varijable const [isPending, startTransition]
-u jsx-u dodajemo komponentu CheckoutSteps sa prop current
-u komponentu payment-method/page.tsx importujemo komponentu PaymentMethodForm
-u jsx-u dodajemo komponentu PaymentMethodForm sa prop preferredPaymentMethod
-otvorimo rutu: http://localhost:3000/payment-method

67. Payment Method Form & Update
-u komponentu payment-method importujemo komponentu CheckoutSteps iz komponente CheckoutSteps.tsx
-u jsx-u dodajemo komponentu CheckoutSteps sa prop current
-u komponentu payment-method-form.tsx importujemo React ikonice ArrowRight i Loader iz paketa lucide-react
-importujemo komponente Form, FormField, FormControl, FormItem, FormLabel i FormMessage iz komponente ui/form.tsx
-importujemo komponentu Button iz komponente ui/button.tsx
-u jsx-u dodajemo prazan fragment kao roditelj element
-u praznom fragmentu kreiramo div element sa Tailwind CSS klasama
-u div elementu kreiramo elemente h2 i p sa Tailwind CSS klasama
-dodajemo komponentu Form
-u komponenti Form kreiramo form element 
-form elementu dodajemo prop method, className i dogadaj onSubmit
-kreiramo asinhronu funkciju onSubmit()
-u dogadaj onSubmit proslijedujemo funkciju form.handleSubmit(onSubmit)
-u form elementu kreiramo dva div elementa sa Tailwind CSS klasama
-u drugi div element dodajemo komponentu Button sa prop type i disabled
-otvorimo link: https://ui.shadcn.com/docs/components/radio-group
-u terminalu ukucamo komandu: npx shadcn@latest add radio-group
-u prvi div element dodajemo komponentu FormField sa samozatvarajucim tagom
-komponenti FormField dodajemo prop control, name i render
-u prop render proslijedujemo anonimnu funkciju sa destruktuiranim parametrom field
-u anonimnu funkciju dodajemo komponentu FormItem sa otvorenim i zatvorenim tagom
-u komponentu FormItem dodajemo komponentu FormControl sa otvorenim i zatvorenim tagom
-importujemo komponente RadioGroup i RadioGroupItem iz komponente ui/radio-group.tsx
-u komponentu FormControl dodajemo komponentu RadioGroup 
-komponenti RadioGroup dodajemo prop onValueChange i className
-importujemo varijablu PAYMENT_METHODS iz constants/index.ts fajla
-kreiramo varijablu const paymentMethods
-u komponentu RadioGroup dodajemo funkciju paymentMethods.map()
-u funkciju map() dodajemo komponentu FormItem sa otvorenim i zatvorenim tagom
-komponenti FormItem dodajemo prop key i className
-u komponentu FormItem dodajemo komponentu FormControl sa otvorenim i zatvorenim tagom
-u komponentu FormControl dodajemo komponentu RadioGroupItem sa samozatvarajucim tagom
-komponenti RadioGroupItem dodajemo prop value i checked
-u komponentu FormItem dodajemo komponentu FormLabel sa otvorenim i zatvorenim tagom
-u prop render, u komponentu FormItem dodajemo komponentu FormMessage sa samozatvarajucim tagom
-importujemo funkciju updateUserPaymentMethod iz user.actions.ts fajla
-asinhronoj funkciji onSubmit() dodajemo parametar values
-parametru values dodajemo tip z.infer<typeof paymentMethodSchema>
-u funkciji onSubmit() pozivamo funkciju startTransition()
-u funkciju startTransition() proslijedujemo anonimnu asinhronu funkciju
-u anonimnoj asinhronoj funkciji pozivamo funkciju await updateUserPaymentMethod(values)
-vrijednost funkcije await updateUserPaymentMethod() pohranjujemo u varijablu const res
-dodajemo uslov if (!res.success) 
-u uslovu if (!res.success) pozivamo funkciju toast()
-nakon funkciji toast() dodajemo izjavu return
-nakon uslova if (!res.success) pozivamo funkciju router.push('/place-order')
-otvorimo rutu: http://localhost:3000/payment-method i odaberemo metodu placanja
-nakon sto odaberemo metodu placanja kliknemo dugme Continue

68. Order & OrderItem Prisma Schema
-u schema.prisma fajlu kreiramo modele Order i OrderItem
-u terminalu ukucamo komandu: npx prisma generate
-u terminalu ukucamo komandu: npx prisma migrate dev --name add-order
-u terminalu ukucamo komandu: npx prisma studio

69. Order Zod Shcemas & Types
-u validators.ts fajlu kreiramo i eksportujemo varijablu const insertOrderSchema
-kreiramo i eksportujemo varijablu const insertOrderItemSchema
-u types/index.ts fajl importujemo varijable insertOrderItemSchema i insertOrderSchema
-kreiramo i eksportujemo tipove OrderItem i Order

70. Place Order Page
-u folderu (root) kreiramo folder place-order i komponentu page.tsx
-u komponenti place-order/page.tsx kreiramo i eksportujemo asinhronu funkciju PlaceOrderPage()
-importujemo funkciju redirect iz paketa next/navigation
-importujemo tip Metadata iz paketa next
-kreiramo varijablu const metadata sa tipom Metadata
-importujemo funkciju getMyCart iz cart.actions.ts fajla
-importujemo funkciju auth iz auth.ts fajla
-importujemo funkciju getUserById iz user.actions.ts fajla
-u funkciji PlaceOrderPage() kreiramo varijable const cart, const session i const userId
-dodajemo uslov if (userId)
-kreiramo varijablu const user
-dodajemo uslov if (!cart || cart.items.length === 0)
-dodajemo uslov if (!user.address)
-dodajemo uslov if (!user.paymentMethod)
-importujemo tip ShippingAddress iz types/index.ts fajla
-kreiramo varijablu const userAddress
-importujemo komponentu CheckoutSteps iz komponente CheckoutSteps.tsx
-u jsx-u dodajemo prazan fragment kao roditelj element 
-u prazan fragment dodajemo komponentu CheckoutSteps sa prop current
-kreiramo h2 element sa Tailwind CSS klasama
-kreiramo div element sa Tailwind CSS Grid klasama
-u div elementu sa Tailwind CSS Grid klasama kreiramo div element
-importujemo komponente Card i CardContent iz komponente ui/card.tsx 
-u div element dodajemo komponentu Card sa otvorenim i zatvorenim tagom
-u komponentu Card dodajemo komponentu CardContent sa otvorenim i zatvorenim tagom
-u komponenti CardContent dinamicki prikazujemo podatke o korisnikovoj adresi stanovanja
-dodajemo komponentu Card u kojoj dinamicki prikazujemo podatke o korisnikovoj metodi placanja
-importujemo komponentu Image iz paketa next/image
-importujemo komponente Table, TableBody, TableCell, TableHead, TableHeader, TableRow iz komponente ui/table.tsx
-dodajemo komponentu Cart u kojoj dinamicki prikazujemo podatke o korisnikovim artiklima iz korpe
-importujemo funkciju formatCurrency iz lib/utils.ts fajla
-kreiramo div element i unutar div elementa dodajemo komponentu Card za dinamicko prikazivanje podataka o korisnikovoj korpi
-otvorimo rutu: http://localhost:3000/place-order

71. Create Order Action
-u folderu lib/actions kreiramo order.actions.ts fajl
-u order.actions.ts fajl dodajemo direktivu 'use server'
-kreiramo i eksportujemo asinhronu funkciju createOrder()
-importujemo funkciju isRedirectError iz paketa next/dist/client/components/redirect-error
-importujemo funkciju formatError iz lib/utils.ts fajla
-u funkciju createOrder() dodajemo blokove koda try - catch
-u blok koda catch dodajemo uslov if (isRedirectError(error)) throw error
-dodajemo izjavu objekt return poruku da je doslo do greske
-importujemo funkcije auth, getMyCart i getUserById
-u bloku koda try kreiramo varijablu const session
-dodajemo uslov if (!session)
-kreiramo varijable const cart i const userId
-dodajemo uslov if (!userId)
-kreiramo varijablu const user 
-dodajemo uslov if (!cart || cart.items.length === 0)
-dodajemo uslov if (!user.address)
-dodajemo uslov if (!user.paymentMethod)
-importujemo varijablu insertOrderSchema iz validators.ts fajla
-kreiramo varijablu const order
-otvorimo link: https://www.prisma.io/docs/orm/prisma-client/queries/transactions
-importujemo instancu prisma iz prisma.ts fajla
-importujemo tip CartItem iz types/index.ts fajla
-pozivamo funkciju await prisma.$transaction()
-vrijednost funkcije await prisma.$transaction() pohranjujemo u varijablu const insertedOrderId
-dodajemo uslov if (!insertedOrderId) 
-u uslov if (!insertedOrderId) dodajemo funkciju throw new Error()
-dodajemo izjavu objekt return poruku da je narudzba uspjesno kreirana

72. Place Order Form
-u folderu place-order kredencijalima komponentu place-order-form.tsx
-u komponenti place-order-form.tsx kreiramo i eksportujemo funkciju PlaceOrderForm() kao default
-dodajemo direktivu 'use client'
-importujemo funkciju createOrder iz order.actions.ts fajla
-u komponentu place-order/page.tsx importujemo komponentu PlaceOrderForm iz komponente PlaceOrderForm.tsx
-u jsx-u, u zadnju komponentu Card dodajemo komponentu PlaceOrderForm sa samozatvarajucim tagom
-u funkciji PlaceOrderForm() kreiramo varijablu const router
-u jsx-u kreiramo form element kao roditelj element
-form elementu dodajemo prop className i dogadaj onSubmit
-kreiramo asinhronu funkciju handleSubmit()
-u dogadaj onSubmit proslijedujemo funkciju handleSubmit
-kreiramo komponentu place-order-button.tsx
-u komponenti place-order-button.tsx kreiramo i eksportujemo funkciju PlaceOrderButton() kao default
-u komponentu PlaceOrderButton() importujemo funkcije useRouter i useFormStatus
-importujemo React ikonice Check i Loader iz paketa lucide-react
-importujemo komponentu Button iz komponente ui/button.tsx
-u funkciji PlaceOrderButton pozivamo funkciju useFormStatus()
-vrijednost funkcije useFormStatus() pohranjujemo u destruktuiranu varijablu const { pending }
-u jsx-u dodajemo komponentu Button kao roditelj element
-komponenti Button dodajemo prop disabled i className
-u komponentu Button dodajemo uslov ternarni operator za varijablu pending
-u komponentu place-order-form.tsx importujemo komponentu PlaceOrderButton iz komponente place-order-button.tsx
-funkciji handleSubmit dodajemo parametar e sa tipom React.FormEvent
-u funkciji handleSubmit() pozivamo funkciju e.preventDefault()
-pozivamo funkciju await createOrder()
-vrijednost funkcije await createOrder() pohranjujemo u varijablu const res
-dodajemo uslov if (res.redirectTo)
-u uslov if (res.redirectTo) pozivamo funkciju router.push(res.redirectTo)
-u jsx-u, u form element dodajemo komponentu PlaceOrderButton sa samozatvarajucim tagom
-otvorimo rutu: http://localhost:3000/place-order i kliknemo dugme Place Order

73. Order Page & Action
-u order.actions.ts fajlu kreiramo i eksportujemo asinhronu funkciju getOrderById()
-funkciji getOrderById() dodajemo parametar orderId sa tipom string
-importujemo funkciju convertToPlainObject iz lib/utils.ts fajla
-u funkciji getOrderById() pozivamo funkciju await prisma.order.findFirst()
-vrijednost funkcije await prisma.order.findFirst() pohranjujemo u varijablu const data
-dodajemo izjavu return convertToPlainObject(data)
-u folderu (root) kreiramo folder order
-u folderu order kreiramo folder [id] i komponentu page.tsx
-u komponenti [id]/page.tsx kreiramo i eksportujemo asinhrone funkciju OrderDetailsPage() kao default
-otvorimo rutu: http://localhost:3000/place-order i kliknemo dugme Place Order
-nakon sto kliknemo dugme Place Order otvori se ruta: http://localhost:3000/order/[id]
-u komponentu [id]/page.tsx importujemo tip Metadata iz paketa next
-importujemo funkciju notFound iz paketa next/navigation
-importujemo funkciju getOrderById iz order.actions.ts fajla
-kreiramo i eksportujemo varijablu const metadata sa tipom Metadata
-funkciji OrderDetailsPage() dodajemo parametar objekt props
-u funkciji OrderDetailsPage() pozivamo funkciju await prop.params
-vrijednost funkcije await prop.params pohranjujemo u varijablu const params
-destruktuiramo varijablu const { id } iz varijable paramms
-pozivamo funkciju await getOrderById(id)
-dodajemo uslov if (!order)
-u uslovu if (!order) pozivamo funkciju notFound()
-u jsx-u dodajemo prazan fragment kao roditelj element
-u praznom fragmentu dinamicki ispisujemo vrijednost varijable id

74. Format Utility Functions
-u prisma.ts fajl, u funkciju $extends() dodajemo objekte cart i order
-u lib/utils.ts fajlu kreiramo i eksportujemo funkciju formatId()
-funkciji formatId() dodajemo parametar id sa tipom string
-u funkciju formatId() dodajemo izjavu return id.substring()
-kreiramo i eksportujemo funkciju formatDateTime()
-funkciji formatDateTime() dodajemo parametar dateString sa tipom Date

75. Order Details Page
-otvorimo rutu: http://localhost:3000/order/[id]
-u folderu order/[id] kreiramo komponentu order-details-table.tsx
-u komponentu order-details-table.tsx dodajemo direktivu 'use client'
-kreiramo i eksportujemo funkciju OrderDetailsTable() kao default
-importujemo tip Order iz types/index.ts fajla
-funkciji OrderDetailsTable() dodajemo parametar destruktuirani prop order
-parametru order dodajemo tip Order
-u jsx-u dodajemo prazan fragment kao roditelj element
-u komponentu order/[id] importujemo komponentu OrderDetailsTable iz komponente order-details-table.tsx
-importujemo tip ShippingAddress iz types/index.ts fajla
-u jsx-u dodajemo komponentu OrderDetailsTable sa samozatvarajucim tagom
-komponenti OrderDetailsTable dodajemo prop order
-u komponenti order-details-table.tsx, u jsx-u kreiramo h2 element sa Tailwind CSS klasama
-importujemo funkcije formatCurrency, formatDateTime i formatId iz lib/utils.ts fajla
-u h2 elementu kreiramo dva span elementa
-u prvi span element dodajemo rijec Order
-u drugom span elementu dinamicki prikazujemo vrijednost id-a narudzbe formatId(id)
-kreiramo div element sa Tailwind CSS Grid klasama grid md:grid-cols-3 md:gap-5
-u div elementu sa Tailwind CSS Grid klasama kreiramo div element sa Tailwind CSS klasama overflow-x-auto md:col-span-2 space-y-4
-destruktuiramo 12 varijabli iz prop order
-importujemo komponente Card i CardContent iz komponente ui/card.tsx
-importujemo komponentu Badge iz komponente ui/badge.tsx
-u div elementu sa Tailwind CSS klasama overflow-x-auto md:col-span-2 space-y-4 dodajemo komponentu Card za metodu placanja
-u komponentu Card dodajemo komponentu CardContent sa otvorenim i zatvorenim tagom
-u komponenti CardContent kreiramo elemente h3 i p
-u p elementu dinamicki prikazujemo vrijednost varijable paymentMethod
-dodajemo uslov ternarni operator za varijablu isPaid
-dodajemo komponentu Card za adresu dostave
-importujemo komponente za tabelu iz komponente ui/table.tsx 
-importujemo komponente Image i Link iz paketa next
-dodajemo komponentu Card za prikazivenje podataka o proizvodima koji su naruceni
-u div elementu sa Tailwind CSS Grid klasama kreiramo div element sa Tailwind CSS klasama mt-4 md:mt-0
-u div element dodajemo komponentu Card za prikazivanje troskova narudzbe


Section 08: PayPal Payments

76. Section Intro

77. PayPal Sandbox Setup
-otvorimo web stranicu: https://developer.paypal.com/
-otvorimo link: https://developer.paypal.com/dashboard/applications/sandbox
-otvorimo link: https://developer.paypal.com/dashboard/accounts
-u .env fajlu kreiramo tri env varijable: PAYPAL_API_URL, PAYPAL_CLIENT_ID i PAYPAL_APP_SECRET
-u example.env fajl dodajemo primjer varijabli koje je potrebno kreirati

78. Generate Access Token
-otvorimo link: https://developer.paypal.com/reference/get-an-access-token/
-u folderu lib kreiramo paypal.ts fajl
-u paypal.ts fajlu kreiramo varijablu const base
-kreiramo i eksportujemo varijablu objekt const paypal
-kreiramo asinhronu funkciju generateAccessToken()
-u funkciji generateAccessToken() destruktuiramo varijable const { PAYPAL_CLIENT_ID, PAYPAL_APP_SECRET } iz varijable process.env
-kreiramo varijablu const auth
-pozivamo funkciju await fetch()
-prvi argument u funkciji fetch() je link, dok je drugi argument konfiguracioni objekt
-vrijednost funkcije await fetch() pohranjujemo u varijablu const response
-dodajemo uslove if (response.ok) - else
-u uslovu if (response.ok) pozivamo funkciju await response.json()
-vrijednost funkcije await response.json() pohranjujemo u varijablu const jsonData
-dodajemo izjavu return jsonData.access_token
-u uslovu else pozivamo funkciju await response.text()
-vrijednost funkcije await response.text() pohranjujemo u varijablu const errorMessage
-pozivamo funkciju throw new Error(errorMessage)

79. Jest Testing For Access Token
-otvorimo web stranicu https://jestjs.io/
-otvorimo link: https://www.npmjs.com/package/jest
-otvorimo link: https://www.npmjs.com/package/ts-jest
-otvorimo link: https://www.npmjs.com/package/ts-node
-otvorimo link: https://www.npmjs.com/package/@types/jest
-otvorimo link: https://www.npmjs.com/package/@types/node
-otvorimo link: https://www.npmjs.com/package/dotenv
-u terminalu ukucamo komandu: npm install -D jest ts-jest ts-node @types/jest @types/node dotenv
-u terminalu ukucamo komandu: npm init jest@latest
-nakon ove komande generise se jest.config.ts fajl
-u jest.config.ts fajl importujemo tip Config iz paketa jest
-kreiramo varijablu objekt const config sa tipom Config
-u objekt config dodajemo opcije clearMocks, covecoverageProvider, preset i setupFiles
-u package.json fajl, u objekt scripts dodajemo komande test i test:watch
-kreiramo jest.setup.ts fajl
-u jest.setup.ts fajl dodajemo import 'dotenv/config'
-u paypal.ts fajlu eksportujemo funkciju generateAccessToken
-kreiramo folder tests
-u folderu tests kreiramo paypal.test.ts fajl
-u paypal.test.ts fajl importujemo funkciju generateAccessToken iz lib/paypal.ts fajla
-pozivamo funkciju test() sa dva argumenta
-prvi argument u funkciji test() je opis testa za generisanje PayPal pristupnog tokena, dok je drugi argument anonimna asinhrona funkcija
-u anonimnoj asinhronoj funkciji pozivamo funkciju await generateAccessToken()
-vrijednost funkcije await generateAccessToken() pohranjujemo u varijablu  const tokenResponse
-pozivamo dvije funkcije expect()
-u terminalu ukucamo komandu npm test ili npm run test:watch

80. Create Order & Capture Payment Request
-otvorimo link: https://developer.paypal.com/docs/api/orders/v2/
-otvorimo link: https://developer.paypal.com/docs/api/orders/v2/#orders_create
-otvorimo link: https://developer.paypal.com/docs/api/orders/v2/#orders_capture
-u paypal.ts fajlu, u objekt paypal kreiramo key - value par createOrder i asinhronu funkciju createOrder()
-funkciji createOrder() dodajemo parametar price sa tipom number
-u asinhronoj funkciji pozivamo funkciju await generateAccessToken()
-vrijednost funkcije await generateAccessToken() pohranjujemo u varijablu const accessToken
-kreiramo varijablu const url
-pozivamo funkciju await fetch() sa dva argumenta
-u funkciji fetch() prvi argument je varijabla url, dok je drugi argument konfiguracioni objekt
-dodajemo uslove if (response.ok) - else
-u uslovu if (response.ok) pozivamo funkciju await response.json()
-u uslovu else pozivamo funkciju await response.text()
-vrijednost funkcije await response.text() pohranjujemo u varijablu const errorMessage
-pozivamo funkciju throw new Error(errorMessage)
-kreiramo asinhronu funkciju handleResponse()
-funkciji handleResponse() dodajemo parametar response sa tipom Response
-u funkciju handleResponse() dodajemo uslove if (response.ok) - else
-u uslovu if (response.ok) pozivamo funkciju return response.json()
-u uslovu else kreiramo varijablu const errorMessage
-pozivamo funkciju throw new Error(errorMessage)
-u funkciji generateAccessToken() pozivamo funkciju await handleResponse(response)
-vrijednost funkcije await handleResponse(response) pohranjujemo u varijablu const jsonData
-dodajemo izjavu return jsonData.access_token
-u funkciji createOrder() pozivamo funkciju return handleResponse(response)
-u objektu paypal kreiramo key - value par capturePayment i asinhronu funkciju capturePayment()
-funkciji capturePayment() dodajemo parametar orderId sa tipom string
-u funkciji capturePayment() pozivamo funkciju await generateAccessToken()
-vrijednost funkcije await generateAccessToken() pohranjujemo u varijablu  const accessToken
-kreiramo varijablu const url 
-pozivamo funkciju await fetch() sa dva argumenta
-u funkciji fetch() prvi argument je varijabla url, dok je drugi argument konfiguracioni objekt
-vrijednost funkcije await fetch() pohranjujemo u varijablu const response
-pozivamo funkciju return handleResponse(response)

81. Jest Testing For Order Payment
-u paypal.test.ts fajl importujemo objekt paypal
-kreiramo funkciju test() sa dva argumenta
-u funkciji test() prvi argument je opis testa za kreiranje PayPal narudzbe, dok je drugi argument anonimna asinhrona funkcija
-u anonimnoj funkciji pozivamo funkciju await generateAccessToken()
-vrijednost funkcije await generateAccessToken() pohranjujemo u varijablu const token
-kreiramo varijablu const price
-pozivamo funkciju await paypal.createOrder(price)
-vrijednost funkcije await paypal.createOrder(price) pohranjujemo u varijablu const orderResponse
-pozivamo tri funkcije expect()
-u terminalu ukucamo komandu npm test
-pozivamo funkciju test()
-u funkciji test() prvi argument je opis testa za simuliranje hvatanja PayPal narudzbe, dok je drugi argument anonimna asinhrona funkcija
-u anonimnoj asinhronoj funkciji kreiramo varijablu const const orderId
-pozivamo funkciju jest.spyOn()
-vrijednost funkcije jest.spyOn() pohranjujemo u varijablu const mockCapturePayment
-pozivamo funkciju await paypal.capturePayment(orderId)
-vrijednost funkcije await paypal.capturePayment(orderId) pohranjujemo u varijablu const captureResponse
-pozivamo funkciju expect(captureResponse)
-pozivamo funkciju mockCapturePayment.mockRestore()
-u terminalu ukucamo komandu npm test

82. Create PayPal Order Action
-u lib/validators.ts fajlu kreiramo i eksportujemo varijablu const paymentResultSchema
-u types/index.ts fajl importujemo varijablu paymentResultSchema iz validators.ts fajla
-kreiramo i eksportujemo tip PaymentResult
-u order.actions.ts fajl importujemo tip PaymentResult iz types/index.ts fajla
-importujemo varijablu paypal iz paypal.ts fajla
-importujemo funkciju revalidatePath iz paketa next/cache
-kreiramo i eksportujemo asinhronu funkciju createPayPalOrder()
-funkciji createPayPalOrder() dodajemo parametar orderId sa tipom string
-dodajemo blokove koda try - catch
-u blok koda catch dodajemo izjavu objekt return poruku da je doslo do greske
-u bloku koda try pozivamo funkciju await prisma.order.findFirst()
-vrijednost funkcije await prisma.order.findFirst() pohranjujemo u varijablu const order
-dodajemo uslov if (order) - else
-u uslovu else pozivamo funkciju throw new Error()
-u uslovu if (order) pozivamo funkciju await paypal.createOrder()
-vrijednost funkcije await paypal.createOrder() pohranjujemo u varijablu const paypalOrder
-pozivamo funkciju await prisma.order.update()
-dodajemo izjavu objekt return poruku da je PayPal narudzba kreirana uspjesno

83. Approve & Update Order
-u order.actions.ts fajlu kreiramo i eksportujemo asinhronu funkciju approvePayPalOrder()
-funkciji approvePayPalOrder() dodajemo parametre orderId i data sa tipovima
-dodajemo blokove koda try - catch
-u blok koda catch dodajemo izjavu objekt return poruku da je doslo do greske
-u bloku koda try pozivamo funkciju await prisma.order.findFirst()
-vrijednost funkcije await prisma.order.findFirst() pohranjujemo u varijablu const order
-dodajemo uslov if (!order)
-u uslovu if (!order) pozivamo funkciju throw new Error()
-pozivamo funkciju await paypal.capturePayment(data.orderID)
-vrijednost funkcije await paypal.capturePayment(data.orderID) pohranjujemo u varijablu const captureData
-dodajemo uslov if () za varijablu captureData
-u uslovu if() pozivamo funkciju throw new Error()
-pozivamo funkciju revalidatePath(`/order/${orderId}`)
-dodajemo izjavu objekt return poruku da je PayPal narudzba uspjesno placena
-kreiramo asinhronu funkciju updateOrderToPaid()
-funkciji updateOrderToPaid() dodajemo destruktuirane parametre orderId i paymentResult sa tipovima
-u funkciji updateOrderToPaid() pozivamo funkciju await prisma.order.findFirst()
-vrijednost funkcije await prisma.order.findFirst() pohranjujemo u varijablu const order
-dodajemo uslov if (!order) 
-u uslovu if (!order) pozivamo funkciju throw new Error()
-dodajemo uslov if (order.isPaid)
-u uslovu if (order.isPaid) pozivamo funkciju throw new Error()
-pozivamo funkciju await prisma.$transaction()
-pozivamo funkciju await prisma.order.findFirst()
-vrijednost funkcije await prisma.order.findFirst() pohranjujemo u varijablu  const updatedOrder
-dodajemo uslov if (!updatedOrder) 
-u uslovu if (!updatedOrder) pozivamo funkciju throw new Error()
-u funkciji approvePayPalOrder() pozivamo funkciju await updateOrderToPaid()

84. Implement PayPal Button
-otvorimo link: https://www.npmjs.com/package/@paypal/react-paypal-js
-u terminalu ukucamo komandu: npm i @paypal/react-paypal-js
-u komponentu order-details-table.tsx importujemo komponente PayPalButtons, PayPalScriptProvider i funkciju usePayPalScriptReducer iz paketa @paypal/react-paypal-js
-importujemo funkcije approvePayPalOrder i createPayPalOrder iz order.actions.ts fajla
-funkciji OrderDetailsTable() dodajemo destruktuirani parametar paypalClientId sa tipom string
-u komponenti order/[id]/page.tsx, u jsx-u dodajemo komponenti OrderDetailsTable prop paypalClientId
-u komponenti order-details-table.tsx, u jsx-u dodajemo uslov za kondicionalno renderovanje isPaid && paymentMethod === 'PayPal' && (...)
-u uslovu za kondicionalno renderovanje kreiramo div element
-u div element dodajemo komponentu PayPalScriptProvider sa otvorenim i zatvorenim tagom
-komponenti PayPalScriptProvider dodajemo prop options
-kreiramo funkciju PrintLoadingState()
-u komponentu PayPalScriptProvider dodajemo komponente PrintLoadingState i PayPalButtons
-komponenti PayPalButtons dodajemo prop createOrder i onApprove
-u funkciji PrintLoadingState() pozivamo funkciju usePayPalScriptReducer()
-vrijednost funkcije usePayPalScriptReducer() pohranjujemo u varijable const [{ isPending, isRejected }]
-kreiramo varijablu let status
-dodajemo uslove if (isPending) - else if
-importujemo funkciju toast iz use-toast.ts fajla
-kreiramo funkcije handleCreatePayPalOrder() i handleApprovePayPalOrder()
-u prop createOrder proslijedujemo funkciju handleCreatePayPalOrder
-u prop onApprove proslijedujemo funkciju handleApprovePayPalOrder
-u funkciji handleCreatePayPalOrder() pozivamo funkciju await createPayPalOrder(order.id)
-u funkciji handleApprovePayPalOrder() pozivamo funkciju await approvePayPalOrder(order.id, data)
-otvorimo rutu: http://localhost:3000/place-order i kliknemo dugme Place Order
-otvorimo rutu: http://localhost:3000/order/[id] i kliknemo PayPal dugme za placanje


Section 09: Order History & User Profile

85. Section Intro

86. User Layout & Menu
-u folderu app kreiramo folder user i komponentu layout.tsx
-u komponenti user/layout.tsx kreiramo i eksportujemo funkciju UserLayout() kao default
-funkciji UserLayout() dodajemo parametar destruktuirani prop children
-importujemo varijablu APP_NAME iz constants/index.ts fajla
-importujemo komponente Link i Image iz paketa next
-importujemo komponentu Menu iz komponente header/menu.tsx
-u jsx-u dodajemo prazan fragment kao roditelj element
-u praznom fragmentu kreiramo div element sa Tailwind CSS flex klasama 
-u div elementu sa Tailwind CSS flex klasama kreiramo div element sa Tailwind CSS klasama border-b container mx-auto
-kreiramo div element za komponente Link i Menu
-kreiramo div element u kojem dinamicki prikazujemo vrijednost varijable prop children
-u folderu user kreiramo folder orders i komponentu page.tsx
-u komponenti orders/page.tsx kreiramo i eksportujemo funkciju OrdersPage() kao default
-otvorimo rutu: http://localhost:3000/user/orders
-u folderu user kreiramo komponentu main-nav.tsx
-u komponentu main-nav.tsx dodajemo direktivu 'use client'
-importujemo komponentu Link iz paketa next/link
-importujemo funkcije usePathname i cn
-kreiramo i eksportujemo funkciju MainNav() kao default
-funkciji Main() dodajemo parametre destruktuirane prop className i ...props
-parametrima dodajemo tip React.HTMLAttributes<HTMLElement>
-u funkciji MainNav() kreiramo varijablu const pathname
-u jsx-u kreiramo nav element kao roditelj element
-u komponentu orders/layout.tsx importujemo komponentu MainNav iz komponente main-nav.tsx
-u jsx-u, u div element sa Tailwind CSS klasama flex h-16 items-center px-4 dodajemo komponentu MainNav sa samozatvarajucim tagom
-komponenti MainNav dodajemo prop className
-u komponenti main-nav.tsx nav elementu dodajemo prop className
-u prop className proslijedujemo funkciju cn() sa dva argumenta
-u funkciji cn() prvi argument su Tailwind CSS klase, dok je drugi argument prop className
-nav elementu dodajemo prop {...props}
-kreiramo varijablu niz const links
-u nav elementu dodajemo funkciju links?.map()
-u funkciju map() dodajemo komponentu Link sa prop key, href i className
-u komponenti Link dinamicki prikazujemo vrijednost varijable item.title
-u prop className proslijedujemo funkciju cn() sa dva argumenta
-u funkciji cn() prvi argument su Tailwind CSS klase, dok je drugi argument ternarni uslov pathname.includes(item.href)
-u folderu user kreiramo folder profile i komponentu page.tsx
-u komponenti profile/page.tsx kreiramo i eksportujemo funkciju ProfilePage() kao default
-otvorimo rutu: http://localhost:3000/user/profile
-u komponentu user-button.tsx dodajemo dvije komponente DropdownMenuItem
-u prvu komponentu DropdownMenuItem dodajemo komponentu Link sa tekstom Profile
-u drugu komponentu DropdownMenuItem dodajemo komponentu Link sa tekstom Orders

87. Get My Orders Action
-u .env fajlu kreiramo env varijablu PAGE_SIZE
-u .example.env fajlu dodajemo primjer varijable koju je potrebno kreirati
-u constants/index.ts fajlu kreiramo i eksportujemo varijablu PAGE_SIZE
-u order.actions.ts fajl importujemo varijablu PAGE_SIZE iz constants/index.ts fajla
-kreiramo i eksportujemo asinhronu funkciju getMyOrders()
-funkciji getMyOrders() dodajemo destruktuirane parametre limit i page sa tipom number
-u funkciji getMyOrders() kreiramo varijablu const session
-dodajemo uslov if (!session)
-pozivamo funkciju await prisma.order.findMany()
-vrijednost funkcije await prisma.order.findMany() pohranjujemo u varijablu const data
-pozivamo funkciju await prisma.order.count()
-vrijednost funkcije await prisma.order.count() pohranjujemo u varijablu  const dataCount
-dodajemo izjavu objekt return i varijable data i totalPages

88. Orders Page
-u komponentu orders/page.tsx importujemo tip Metadata
-importujemo funkcije formatCurrency, formatDateTime i formatId iz lib/utils.ts fajla
-importujemo funkciju getMyOrders iz order.actions.ts fajla
-importujemo komponente za tabelu iz komponente ui/table.tsx
-importujemo komponentu Link iz paketa next/link
-kreiramo i eksportujemo varijablu const metadata sa tipom Metadata
-funkciji OrdersPage() dodajemo asinhronost
-funkciji OrdersPage() dodajemo parametar props
-u funkciji OrdersPage() pozivamo funkciju await props.searchParams
-vrijednost funkcije await props.searchParams pohranjujemo u destruktuiranu varijablu const { page }
-pozivamo funkciju await getMyOrders()
-vrijednost funkcije await getMyOrders() pohranjujemo u varijablu const orders
-u jsx-u kreiramo roditelj div element
-u roditelj div elementu kreiramo h2 element sa Tailwind CSS klasama
-u roditelj div elementu kreiramo div element sa Tailwind CSS klasom overflow-x-auto
-u div element sa klasom overflow-x-auto dodajemo komponentu Table
-u komponentu Table dodajemo komponente TableHeader i TableBody
-u komponentu TableHeader dodajemo komponentu TableRow
-u komponentu TableRow dodajemo pet komponenti TableHead
-u komponenti TableBody pozivamo funkciju orders?.data?.map()
-u funkciju map() dodajemo komponentu TableRow
-u komponentu TableRow dodajemo sest komponenti TableCell u kojima dinamicki prikazujemo podatke o naruzdbi
-otvorimo rutu: http://localhost:3000/user/orders

89. Orders Pagination
-otvorimo rutu: http://localhost:3000/user/orders
-otvorimo rutu: http://localhost:3000/user/orders?page=2¸
-u folderu components/shared kreiramo komponentu pagination.tsx
-u komponenti pagination.tsx kreiramo i eksportujemo funkciju Pagination() kao default
-dodajemo direktivu 'use client'
-otvorimo link: https://nextjs.org/docs/app/api-reference/functions/use-search-params
-importujemo funkcije useRouter i useSearchParams iz paketa next/navigation
-importujemo komponentu Button iz komponente ui/button.tsx
-kreiramo tip PaginationProps
-funkciji Pagination() dodajemo parametre destruktuirane prop page, totalPages i urlParamName
-parametrima dodajemo tip PaginationProps
-u funkciji Pagination() kreiramo varijable const router i const searchParams
-u jsx-u roditelj div elementu dodajemo Tailwind CSS klase
-u komponentu user/orders/page.tsx importujemo komponentu Pagination iz komponente pagination.tsx
-u jsx-u, dodajemo uslov za kondicionalno renderovanje orders.totalPages > 1 && (...)
-u uslov za kondicionalno renderovanje dodajemo komponentu Pagination sa samozatvarajucim tagom
-komponenti Pagination dodajemo prop page i totalPages
-u komponenti pagination.tsx, u roditelj div element dodajemo dvije komponente Button
-komponentama Button dodajemo prop size, variant, className i disabled
-otvorimo link: https://www.npmjs.com/package/query-string
-u terminalu ukucamo komandu: npm i query-string
-kreiramo funkciju handlePagination()
-funkciji handlePagination() dodajemo parametar btnType sa tipom string
-u funkciji handlePagination() kreiramo varijablu const pageValue
-komponentama Button dodajemo dogadaje onClick
-u dogadaje onClick proslijedujemo funkciju handlePagination()
-u lib/utils.ts fajl importujemo instancu qs iz paketa query-string
-kreiramo funkciju formUrlQuery()
-funkciji formUrlQuery() dodajemo destruktuirane parametre params, key i value
-parametrima dodajemo tipove
-u komponentu pagination.tsx importujemo funkciju formUrlQuery iz lib/utils.ts fajla
-u funkciji handlePagination() pozivamo funkciju formUrlQuery()
-u lib/utils.ts fajlu, u funkciji formUrlQuery() kreiramo varijablu const query
-dodajemo metodu query[key] = value
-dodajemo izjavu return qs.stringifyUrl()
-u komponenti pagination.tsx vrijednost funkcije formUrlQuery() pohranjujemo u varijablu const newUrl
-pozivamo funkciju router.push() sa dva argumenta
-u funkciji push() prvi argument je varijabla newUrl, dok je drugi argument objekt

Orders Pagination - Alternative
-otvorimo link: https://nextjs.org/docs/app/api-reference/functions/use-pathname
-u komponentu pagination.tsx importujemo funkciju usePathname iz paketa next/navigation
-u funkciji Pagination() kreiramo varijablu const pathname
-kreiramo varijablu const params 
-pozivamo funkciju params.set()
-pozivamo funkciju router.replace()

90. Update Profile Action
-u validators.ts fajlu kreiramo i eksportujemo varijablu const updateProfileSchema
-u user.actions.ts fajlu kreiramo i eksportujemo asinhronu funkciju updateProfile()
-funkciji updateProfile() dodajemo parametar objekt user
-u funkciji updateProfile() dodajemo blokove koda try - catch
-u blok koda catch dodajemo izjavu return objekt sa key - value parovima success i message
-u bloku koda try pozivamo funkciju await auth()
-vrijednost funkcije await auth() pohranjujemo u varijablu const session
-pozivamo funkciju await prisma.user.findFirst()
-vrijednost funkcije await prisma.user.findFirst() pohranjujemo u varijablu const currentUser
-dodajemo uslov if (!currentUser)
-pozivamo funkciju prisma.user.update()
-dodajemo izjavu objekt ruturn sa key - value parovima success i message

91. Update Profile Form
-otvorimo link: https://next-auth.js.org/getting-started/client
-u komponentu user/profile/page.tsx importujemo komponentu SessionProvider iz paketa next-auth/react
-importujemo tip Metadata iz paketa next
-importujemo funkciju auth iz auth.ts fajla
-kreiramo i eksportujemo varijablu const metadata
-funkciji ProfilePage() dodajemo asinhronost
-u funkciji ProfilePage() pozivamo funkciju await auth()
-vrijednost funkcije await auth() pohranjujemo u varijablu const session
-u jsx-u dodajemo komponentu SessionProvider sa otvorenim i zatvorenim tagom
-komponenti SessionProvider dodajemo prop session
-u prop session proslijedujemo varijablu session
-u komponenti SessionProvider kreiramo div element sa Tailwind CSS klasama max-w-md mx-auto space-y-4
-u div elementu kreiramo h4 element
-u folderu user/profile kreiramo komponentu profile-form.tsx
-u komponenti profile-form.tsx kreiramo i eksportujemo funkciju ProfileForm() kao default
-dodajemo direktivu 'use client'
-importujemo funkciju useSession iz paketa next-auth/react
-u funkciji ProfileForm() pozivamo funkciju useSession()
-vrijednost funkcije useSession() pohranjujemo u destruktuirane varijable const { data: session, update }
-u komponentu user/profile/page.tsx importujemo komponentu ProfileForm iz komponente profile-form.tsx
-u jsx-u, u div element dodajemo komponentu ProfileForm sa samozatvarajucim tagom
-u komponentu profile-form.tsx importujemo funkciju useForm iz paketa react-hook-form
-importujemo instancu z iz paketa zod
-importujemo varijablu updateProfileSchema iz validators.ts fajla
-importujemo funkciju zodResolver iz paketa @hookform/resolvers/zod
-u funkciji ProfileForm() kreiramo varijablu const form
-kreiramo funkciju onSubmit()
-importujemo komponente za formu iz komponente ui/form.tsx
-u jsx-u dodajemo komponentu Form kao roditelj element
-komponenti Form dodajemo prop {...prop}
-u komponenti Form kreiramo form element sa Tailwind CSS klasama
-form elementu dodajemo dogadaj onSubmit
-u dogadaj onSubmit proslijedujemo funkciju form.handleSubmit(onSubmit)
-u form elementu kreiramo div element sa Tailwind CSS klasama
-importujemo komponentu Input iz komponente ui/input.tsx
-u div element dodajemo komponentu FormField za email korisnika sa prop control, name i render
-dodajemo komponentu FormField za ime korisnika
-importujemo komponentu Button iz komponente ui/button.tsx
-u element form dodajemo komponentu Button sa prop type, size, className i disabled
-u komponentu Button dodajemo uslov ternarni operator za varijablu form.formState.isSubmitting

92. Profile Form Submission
-u komponenti profile-form.tsx, funkciji onSubmit dodajemo parametar values sa tipom
-funkciji onSubmit() dodajemo asinhronost
-importujemo funkciju updateProfile iz user.actions.ts fajla
-importujemo funkciju useToast iz use-toast.ts fajla
-u funkciji ProfileForm() pozivamo funkciju useToast()
-vrijednost funkcije useToast() pohranjujemo u destruktuiranu varijablu const { toast }
-u funkciji onSubmit pozivamo funkciju await updateProfile(values)
-vrijednost funkcije await updateProfile(values) pohranjujemo u varijablu const res
-dodajemo uslov if (!res.success)
-kreiramo varijablu const newSession
-pozivamo funkciju await update(newSession)
-pozivamo funkciju toast()
-u auth.ts fajlu, u funkciju jwt() dodajemo uslov if (session?.user.name && trigger === 'update')
-u komponentu user/orders/page.tsx, u jsx-u dodajemo uslov orders?.data?.length > 0


Section 10: Admin Overview & Orders

93. Section Intro

94. Admin Layout & Main Nav
-u folderu app kreiramo folder admin
-u folderu admin kreiramo komponente layout.tsx i main-nav.tsx
-u komponenti main-nav.tsx kreiramo i eksportujemo funkciju MainNav() kao default
-kreiramo varijablu niz const links
-u komponenti admin/layout.tsx kreiramo i eksportujemo asinhronu funkciju AdminLayout() kao default
-importujemo komponentu MainNav iz komponente main-nav.tsx
-u folderu admin kreiramo folder overview
-u folderu overview kreiramo komponentu page.tsx
-u komponenti overview/page.tsx kreiramo i eskportujemo funkciju AdminOverviewPage() kao default
-otvorimo rutu: http://localhost:3000/admin/overview
-u komponenti user-button.tsx, u jsx-u dodajemo uslov za kondicionalno renderovanje session?.user?.role === 'admin' && (...)
-otvorimo link: https://next-auth.js.org/getting-started/typescript
-otvorimo link: https://stackoverflow.com/questions/73353973/type-error-property-role-does-not-exist-on-type-implementing-role-base
-u folderu types kreiramo next-auth.d.ts fajl
-u next-auth.d.ts fajl importujemo interfejs DefaultSession iz paketa next-auth
-dodajemo kod iz dokumentacije

95. Get Order Summary
-u order.actions.ts fajl importujemo instancu Prisma iz paketa @prisma/client
-kreiramo i eksportujemo asinhronu funkciju getOrderSummary()
-u funkciji getOrderSummary() kreiramo varijable const ordersCount, const productsCount i const usersCount
-pozivamo funkciju await prisma.order.aggregate()
-vrijednost funkcije await prisma.order.aggregate() pohranjujemo u varijablu const totalSales
-pozivamo funkciju await prisma.$queryRaw
-vrijednost funkcije await prisma.$queryRaw pohranjujemo u varijablu const salesDataRaw
-kreiramo tip SalesDataType 
-pozivamo funkciju salesDataRaw?.map()
-vrijednost funkcije salesDataRaw?.map() pohranjujemo u varijablu const salesData
-varijabli const salesData dodajemo tip SalesDataType
-pozivamo funkciju  await prisma.order.findMany()
-vrijednost funkcije await prisma.order.findMany() pohranjujemo u varijablu const latestOrders
-dodajemo izjavu objekt ruturn i varijable ordersCount, productsCount, usersCount, totalSales, latestOrders i salesData

96. Admin Overview Display Data
-u komponentu overview/page.tsx importujemo funkciju auth iz auth.ts fajla
-funkciji AdminOverviewPage() dodajemo asinhronost
-u funkciji AdminOverviewPage() pozivamo funkciju await auth()
-vrijednost funkcije await auth() pohranjujemo u varijablu const session
-dodajemo uslov if (session?.user?.role !== 'admin')
-importujemo funkciju getOrderSummary iz order.actions.ts fajla
-pozivamo funkciju await getOrderSummary()
-vrijednost funkcije await getOrderSummary() pohranjujemo u varijablu const summary
-importujemo komponente Card, CardContent, CardHeader i CardTitle iz komponente ui/card.tsx
-importujemo React ikonice BadgeDollarSign, Barcode, CreditCard i Users iz paketa lucide-react
-importujemo komponente za tabelu iz komponente ui/table.tsx
-importujemo komponentu Link iz paketa next/link
-u jsx-u dodajemo roditelj div elementu klasu space-y-2
-u roditelj div elementu kreiramo h2 element sa Tailwind CSS klasom h2-bold
-u roditelj div elementu kreiramo div element sa Tailwind CSS Grid klasama za komponente Card
-u div element za komponente Card dodajemo cetiri komponente Card
-u lib/utils.ts fajlu kreiramo i eksportujemo funkciju formatNumber()
-kreiramo varijablu const NUMBER_FORMATTER 
-u komponentu overview/page.tsx importujemo funkcije formatCurrency, formatDateTime i formatNumber
-u div elementu za komponente Card prva komponenta Card je za prikazivanje ukupne zarade
-druga komponenta Card je za prikazivanje ukupnog broja prodaja
-treca komponenta Card je za prikazivanje ukupnog broja kupaca
-cetvrta komponenta Card je za prikazivanje ukupnog broja artikala
-kreiramo div element sa Tailwind CSS Grid klasama za dvije komponente Card
-u prvoj komponenti Card cemo dodati grafikon
-u drugu komponentu Card dodajemo komponente za tabelu
-u komponentu Card dodajemo komponentu Table
-u komponentu Table dodajemo komponente TableHeader i TableBody
-u komponenti TableBody pozivamo funkciju summary?.latestOrders?.map()
-u komponenti TableBody prikazujemo podatke o zadnjim narudzbama

97. Monthly Sales Chart
-otvorimo web stranicu: https://recharts.org/en-US/
-u terminalu ukucamo komandu: npm i recharts
-u folderu app/overview kreiramo komponentu charts.tsx
-u komponentu charts.tsx dodajemo direktivu 'use client'
-kreiramo i eksportujemo funkciju Charts() kao default
-importujemo komponente Bar, BarChart, ResponsiveContainer, XAxis i YAxis iz paketa recharts
-funkciji Charts() dodajemo parametar destruktuirani prop objekt data
-u jsx-u dodajemo komponentu ResponsiveContainer kao roditelj element sa otvorenim i zatvorenim tagom
-u komponentu ResponsiveContainer dodajemo komponente BarChart
-u komponentu BarChart dodajemo komponente XAxis, YAxis i Bar
-u komponentu overview/page.tsx importujemo komponentu Charts iz komponente charts.tsx
-u jsx-u, u div element za grafikon dodajemo komponentu Charts sa samozatvarajucim tagom
-komponenti Charts dodajemo prop objekt data

98. Protecting Admin Routes
-otvorimo link: https://www.youtube.com/watch?v=kbCzZzXTjuw
-u folderu lib kreiramo auth-guard.ts fajl
-u auth-guard.ts fajl importujemo funkcije auth i redirect
-kreiramo i eksportujemo asinhronu funkciju requireAdmin()
-u funkciji requireAdmin() pozivamo funkciju await auth()
-vrijednost funkcije await auth() pohranjujemo u varijablu const session
-dodajemo uslov if (session?.user?.role !== 'admin')
-u uslovu if pozivamo funkciju redirect('/unauthorized')
-dodajemo izjavu return session
-u folderu app kreiramo folder unauthorized i komponentu page.tsx
-u komponenti unauthorized/page.tsx kreiramo i eksportujemo funkciju UnauthorizedPage() kao default
-otvorimo rutu: http://localhost:3000/unauthorized
-importujemo tip Metadata iz paketa next
-importujemo komponentu Link iz paketa next/link
-importujemo komponentu Button iz komponente ui/button.tsx
-kreiramo i eksportujemo varijablu const metadata sa tipom Metadata
-u jsx-u roditelj div elementu dodajemo Tailwind CSS flex klase
-u komponentu overview/page.tsx importujemo funkciju iz auth-guard.ts fajla
-u funkciji AdminOverviewPage() pozivamo funkciju await requireAdmin()
-otvorimo rutu: http://localhost:3000/admin/overview sa korisnikom koji nije admin

99. Admin Orders Page & Action
-u order.actions.ts fajlu kreiramo i eksportujemo asinhronu funkciju getAllOrders()
-funkciji getAllOrders() dodajemo destruktuirane parametre limit i page
-parametrima dodajemo tipove
-u funkciji getAllOrders() pozivamo funkciju await prisma.order.findMany()
-vrijednost funkcije await prisma.order.findMany() pohranjujemo u varijablu const data
-pozivamo funkciju await prisma.order.count()
-vrijednost funkcije await prisma.order.count() pohranjujemo u varijablu const dataCount
-dodajemo izjavu objekt return varijable data i totalPages
-u folderu app/admin kreiramo folder orders i komponentu page.tsx
-u komponenti orders/page.tsx kreiramo i eksportujemo asinhronu funkciju AdminOrdersPage() kao default
-importujemo tip Metadata iz paketa next
-importujemo funkcije requireAdmin i getAllOrders iz foldera lib
-kreiramo i eksportujemo varijablu const metadata sa tipom Metadata
-funkciji AdminOrdersPage() dodajemo parametar props
-u funkciji AdminOrdersPage() pozivamo funkciju await requireAdmin()
-pozivamo funkciju await props.searchParams()
-vrijednost funkcije await props.searchParams() pohranjujemo u destruktuiranu varijablu const { page = '1' } 
-pozivamo funkciju await getAllOrders()
-vrijednost funkcije await getAllOrders() pohranjujemo u varijablu const orders
-importujemo funkcije formatCurrency, formatDateTime i formatId iz lib/utils.ts fajla
-importujemo komponente za tablue iz komponente ui/table.tsx
-importujemo komponentu Button iz komponente ui/button.tsx
-importujemo komponentu Pagination iz komponente shared/pagination.tsx
-kod za jsx kopiramo iz komponente user/orders/page.tsx i dodajemo ga u komponentu admin/orders/page.tsx
-u zadnjoj komponenti TableCell u komponenti TableRow dodajemo komponentu Button sa prop asChild, variant i size
-u komponentu Button dodajemo komponentu Link sa prop dinamicki href
-u komponenti user/orders/page.tsx uradimo isti postupak za komponentu TableCell u kojoj se nalazi komponenta Button
-otvorimo rutu: http://localhost:3000/admin/orders

Cart Persist On Sign Out Fix
-u user.actions.ts fajl importujemo funkciju getMyCart iz cart.actions.ts fajla
-u funkciji signOutUser() pozivamo funkciju await getMyCart()
-vrijednost funkcije await getMyCart() pohranjujemo u varijablu const currentCart
-pozivamo funkciju await prisma.cart.delete()

100. Delete Orders
-u user.actions.ts fajl, u funkciju signOutUser() dodajemo uslov if (currentCart)
-u order.actions.ts fajlu kreiramo i eksportujemo asinhronu funkciju  deleteOrder()
-funkciji deleteOrder() dodajemo parametar id sa tipom string
-dodajemo blokove koda try - catch
-u blok koda catch dodajemo izjavu return objekt sa key - value parovima success i message
-u bloku koda try pozivamo funkciju await prisma.order.delete()
-pozivamo funkciju revalidatePath('/admin/orders')
-dodajemo izjavu return objekt sa key - value parovima success i message
-otvorimo link: https://ui.shadcn.com/docs/components/dialog
-u terminalu ukucamo komandu: npx shadcn@latest add dialog
-otvorimo link: https://ui.shadcn.com/docs/components/alert-dialog
-u terminalu ukucamo komandu: npx shadcn@latest add alert-dialog
-u folderu components/shared kreiramo komponentu delete-dialog.tsx
-u komponentu delete-dialog.tsx dodajemo direktivu 'use client'
-kreiramo i eksportujemo funkciju DeleteDialog() kao default
-funkciji DeleteDialog() dodajemo parametre destruktuirane prop id i action
-parametrima id i action dodajemo tipove
-u komponentu admin/orders/page.tsx importujemo komponentu DeleteDialog iz komponente delete-dialog.tsx
-importujemo funkciju deleteOrder iz order.actions.ts fajla
-u jsx-u, u komponentu TableCell gdje se nalazi komponenta Button dodajemo komponentu DeleteDialog sa samozatvarajucim tagom
-komponenti DeleteDialog dodajemo prop id i action
-u komponentu delete-dialog.tsx importujemo funkcije useState i useTransition iz paketa react
-importujemo funkciju useToast iz use-toast.ts fajla
-importujemo komponentu Button iz komponente ui/button.tsx
-u funkciji DeleteDialog kreiramo state varijablu const open i set funkciju setOpen
-kreiramo varijablu const isPending i funkciju startTransition
-pozivamo funkciju useToast()
-vrijednost funkcije useToast() pohranjujemo u destruktuiranu varijablu const { toast }
-importujemo komponente alert iz komponente ui/alert-dialog.tsx
-u jsx-u dodajemo komponentu AlertDialog kao roditelj komponentu
-komponenti AlertDialog dodajemo prop open i onOpenChange
-u komponentu AlertDialog dodajemo komponente AlertDialogTrigger i AlertDialogContent
-u komponentu AlertDialogTrigger dodajemo komponentu Button
-u komponentu AlertDialogContent dodajemo komponente AlertDialogHeader i AlertDialogFooter
-u komponentu AlertDialogHeader dodajemo komponente AlertDialogTitle i AlertDialogDescription
-u komponentu AlertDialogFooter dodajemo komponente AlertDialogCancel i Button
-komponenti Button dodajemo prop variant, size, disabled i dogadaj onClick
-u prop disabled proslijedujemo varijablu isPending
-u komponentu Button dodajemo ternarni operator za varijablu isPending
-kreiramo funkciju handleDeleteOrder()
-u funkciji handleDeleteOrder() pozivamo funkciju startTransition()
-u dogadaj onClick proslijedujemo funkciju handleDeleteOrder

101. Update Order Actions (Cash On Delivery)
-u order.actions.ts fajlu kreiramo i eksportujemo asinhronu funkciju updateOrderToPaidCOD()
-funkciji updateOrderToPaidCOD() dodajemo parametar orderId sa tipom string
-u funkciju updateOrderToPaidCOD() dodajemo blokove koda try - catch
-u bloku koda try pozivamo funkciju await updateOrderToPaid({ orderId })
-pozivamo funkciju revalidatePath(`/order/${orderId}`)
-dodajemo izjavu objekt ruturn sa porukom da je narudzba oznacena kao placena
-u blok koda catch dodajemo izjavu objekt return sa key - value parovima success i message
-kreiramo i eskportujemo funkciju deliverOrder()
-funkciji deliverOrder() dodajemo parametar orderId sa tipom string
-dodajemo blokove koda try - catch
-u bloku koda try pozivamo funkciju await prisma.order.findFirst()
-vrijednost funkcije await prisma.order.findFirst() pohranjujemo u varijablu const order
-dodajemo uslov if (!order)
-dodajemo uslov if (!order.isPaid) 
-pozivamo funkciju await prisma.order.update()
-pozivamo funkciju revalidatePath(`/order/${orderId}`)
-dodajemo izjavu ojekt return sa porukom da je narudzba oznacena kao uspjesno isporucena
-u blok koda catch dodajemo izjavu objekt return sa key - value parovima success i message

102. Update Order Buttons (Cash on Delivery)
-u komponentu (root)/order/[id]/page.tsx importujemo funkciju auth iz auth.ts fajla
-u funkciji OrderDetailsPage() pozivamo funkciju await auth()
-vrijednost funkcije await auth() pohranjujemo u varijablu const session
-u jsx-u komponenti OrderDetailsTable dodajemo prop isAdmin
-u komponenti order-details-table.tsx, funkciji OrderDetailsTable() dodajemo parametar isAdmin sa tipom boolean
-importujemo funkcije updateOrderToPaidCOD i deliverOrder iz order.actions.ts fajla
-importujemo funkciju useTransition iz paketa react
-importujemo komponentu Button iz komponente ui/button.tsx
-importujemo funkciju useToast iz use-toast.ts fajla
-u funkciji OrderDetailsTable() pozivamo funkciju useToast()
-vrijednost funkcije useToast() pohranjujemo u destruktuiranu varijablu const { toast } 
-kreiramo funkcije MarkAsPaidButton() i MarkAsDeliveredButton()
-u jsx-u dodajemo uslov za kondicionalno renderovanje isAdmin && !isPaid && paymentMethod === 'CashOnDelivery' && ()
-dodajemo uslov za kondicionalno renderovanje isAdmin && isPaid && !isDelivered && ()


Section 11: Admin Products & Image Upload

103. Section Intro

104. Get Products For Admin Page
-u folderu admin kreiramo folder products i komponentu page.tsx
-u komponenti products/page.tsx kreiramo i eksportujemo funkciju AdminProductsPage() kao default
-u jsx-u kreiramo HTML elemente sa Tailwind CSS klasama
-u pretrazivacu otvorimo rutu: http://localhost:3000/admin/products
-funkciji AdminProductsPage() dodajemo parametar props
-funkcije AdminProductsPage() dodajemo asinhronost
-kreiramo varijable const searchParams, const page, const searchText i const category
-funkciji AdminProductsPage() dodajemo asinhronost
-importujemo funkciju requireAdmin iz auth-guard.ts fajla
-pozivamo funkciju await requireAdmin()
-u product.actions.ts fajl importujemo varijablu PAGE_SIZE iz constants/index.ts fajla
-kreiramo i eksportujemo asinhronu funkciju getAllProducts()
-funkciji getAllProducts() dodajemo parametre query, limit, page i category
-pozivamo funkciju await prisma.product.findMany()
-vrijednost funkcije await prisma.product.findMany() pohranjujemo u varijablu const data
-pozivamo funkciju await prisma.product.count()
-vrijednost funkcije await prisma.product.count() pohranjujemo u varijablu const dataCount
-dodajemo izjavu objekt return i varijable data, totalPages
-u komponentu admin/products/page.tsx importujemo funkciju getAllProducts iz product.actions.ts fajla
-importujemo funkcije formatCurrency i formatId iz lib/utils.ts fajla
-importujemo komponentu Link iz paketa next/link
-u funkciji AdminProductsPage() pozivamo funkciju await getAllProducts()
-vrijednost funkcije await getAllProducts() pohranjujemo u varijablu const products

105. Display Products
-u komponentu admin/products/page.tsx importujemo komponentu Button iz komponenti ui/button.tsx
-u jsx-u, u div element sa klasom flex-between dodajemo komponentu Button sa prop asChild i variant
-importujemo komponente za tabelu iz komponente ui/table.tsx
-importujemo komponentu Pagination iz komponente shared/pagination.tsx
-u roditelj div elementu kreiramo div element za komponentu Table
-u komponentu Table dodajemo komponente TableHeader i TableBody
-u komponentu TableHeader dodajemo komponentu TableRow
-u komponentu TableRow dodajemo sedam komponenti TableHead
-u komponentu TableBody dodajemo funkciju products?.data?.map()
-u funkciju map() dodajemo komponentu TableRow
-u komponentu TableRow dodajemo sedam komponenti TableCell u kojima dinamicki prikazujemo podatke o proizvodima
-u div elementu za tabelu dodajemo uslov za kondicionalno renderovanje products?.totalPages && products.totalPages > 1 && ()
-u uslov za kondicionalno renderovanje dodajemo komponentu Pagination
-komponenti Pagination dodajemo prop page i totalPages
-u pretrazivacu otvorimo rutu: http://localhost:3000/admin/products

106. Delete Products
-u product.actions.ts fajl importujemo funkciju revalidatePath iz paketa next/cache
-importujemo funkciju formatError iz utils.ts fajla
-kreiramo i eksportujemo asinhronu funkciju deleteProduct()
-funkciji deleteProduct() dodajemo parametar id sa tipom string
-dodajemo blokove koda try - catch
-u bloku koda catch dodajemo izjavu return objekt sa porukom da je doslo do greske prilikom brisanja artikla
-u bloku koda try pozivamo funkciju await prisma.product.findFirst()
-vrijednost funkcije await prisma.product.findFirst() pohranjujemo u varijablu const productExists
-dodajemo uslov if (!productExists)
-u uslovu if (!productExists) pozivamo funkciju throw new Error()
-pozivamo funkciju await prisma.product.delete()
-pozivamo funkciju revalidatePath('/admin/products')
-dodajemo izjavu return objekt sa porukom da je artikl uspjesno obrisan
-u komponentu admin/products/page.tsx importujemo funkciju deleteProduct iz product.actions.ts fajla
-importujemo komponentu DeleteDialog iz komponente shared/delete-dialog.tsx
-u jsx-u, u zadnju komponentu TableCell dodajemo komponentu DeleteDialog sa prop id i action

107. Create and Update Actions
-u validators.ts fajlu kreiramo i eksportujemo varijablu const updateProductSchema
-u constants/index.ts fajlu kreiramo i eksportujemo varijablu const productDefaultValues
-u product.actions.ts fajl importujemo instancu z iz paketa zod
-importujemo varijablu insertProductSchema iz validators.ts fajla
-kreiramo i eksportujemo asinhronu funkciju createProduct()
-funkciji createProduct() dodajemo parametar data
-parametru data dodajemo tip z.infer<typeof insertProductSchema>
-dodajemo blokove koda try - catch
-u blok koda catch dodajemo izjavu return objekt sa porukom da je doslo do greske prilikom kreiranja artikla
-u bloku koda try pozivamo funkciju insertProductSchema.parse(data)
-vrijednost funkcije insertProductSchema.parse(data) pohranjujemo u varijablu const product
-pozivamo funkciju await prisma.product.create()
-pozivamo funkciju evalidatePath('/admin/products')
-dodajemo izjavu return objekt poruku da je artikl uspjesno kreiran
-importujemo varijablu updateProductSchema iz validators.ts fajla
-kreiramo i eksportujemo asinhronu funkciju updateProduct()
-funkciji updateProduct() dodajemo parametar data
-parametru data dodajemo tip z.infer<typeof updateProductSchema>
-dodajemo blokove koda try - catch
-u blok koda catch dodajemo izjavu return objekt sa porukom da je doslo do greske prilikom azuriranja artikla
-u bloku koda try pozivamo funkciju updateProductSchema.parse(data)
-vrijednost funkcije updateProductSchema.parse(data) pohranjujemo u varijablu const product
-pozivamo funkciju await prisma.product.findFirst()
-vrijednost funkcije await prisma.product.findFirst() pohranjujemo u varijablu const productExists
-dodajemo uslov if (!productExists)
-u uslovu if (!productExists) pozivamo funkciju throw new Error()
-pozivamo funkciju await prisma.product.update()
-pozivamo funkciju revalidatePath('/admin/products')
-dodajemo izjavu return objekt poruku da je artikl uspjesno azuriran

108. Create Product Page & Form
-u folderu admin/products kreiramo folder create i komponentu page.tsx
-u folderu create/page.tsx kreiramo i eksportujemo asinhronu funkciju CreateProductPage() kao default
-importujemo tip Metadata iz paketa next
-kreiramo i eksportujemo varijablu const metadata sa tipom Metadata
-u funkciji CreateProductPage() pozivamo funkciju await requireAdmin()
-u jsx-u kreiramo HTML elemente h2 i div sa Tailwind CSS klasama
-importujemo funkciju requireAdmin iz auth-guard.ts fajla
-u pretrazivacu otvorimo rutu: http://localhost:3000/admin/products/create
-u folderu create kreiramo komponentu product-form.tsx
-u komponenti product-form.tsx kreiramo i eksportujemo funkciju ProductForm() kao default
-dodajemo direktivu 'use client'
-u komponentu create/page.tsx importujemo komponentu ProductForm iz komponente product-form.tsx
-u jsx-u, u div element dodajemo komponentu ProductForm
-komponenti ProductForm dodajemo prop type
-u komponentu product-form.tsx importujemo tip Product iz types/index.ts fajla
-funkciji ProductForm() dodajemo parametre destruktuirane prop type, product i productId sa tipovima
-importujemo i pozivamo funkciju useRouter()
-vrijednost funkcije useRouter() pohranjujemo u varijablu const router
-importujemo i pozivamo funkciju useToast()
-vrijednost funkcije useToast() pohranjujemo u destruktuiranu varijablu const { toast }
-importujemo funkciju useForm iz paketa react-hook-form
-importujemo instancu z iz paketa zod
-importujemo varijable insertProductSchema i updateProductSchema iz validators.ts fajla
-importujemo funkciju zodResolver iz paketa @hookform/resolvers/zod
-importujemo varijablu productDefaultValues iz constants/index.ts fajla
-kreiramo varijablu const form
-importujemo komponentu Form iz komponente ui/form.tsx
-u komponenti Form kreiramo form element sa Tailwind CSS klasom space-y-8
-u form elementu kreiramo sedam div elemenata sa Tailwind CSS klasama

109. Form Fields & Slugify
-otvorimo link: https://www.npmjs.com/package/slugify
-u terminalu ukucamo komandu npm install slugify
-u komponentu product-form.tsx importujemo instancu slugify iz paketa slugify
-importujemo komponentu za formu iz komponente ui/form.tsx
-importujemo tip ControllerRenderProps iz paketa react-hook-form
-importujemo komponentu Input iz komponente ui/input.tsx
-importujemo komponentu Button iz komponente ui/button.tsx
-u jsx-u dodajemo komponente FormField za ime i slug artikla
-dodajemo komponente FormField za kategoriju i brand
-dodajemo komponente FormField za cijenu i kolicinu u zalihama
-u komponenti FormField za slug artikla dodajemo komponentu Button
-komponenti Button dodajemo prop type, className i dogadaj onClick
-otvorimo link: https://ui.shadcn.com/docs/components/textarea
-u terminalu ukucamo komandu: npx shadcn@latest add textarea
-importujemo komponentu Textarea iz komponente ui/textarea.tsx
-u zadnji div element dodajemo komponentu Button sa prop type, size, disabled i className
-u komponentu Button dodajemo ternarni uslov za varijablu form.formState.isSubmitting
-u pretrazivac otvorimo rutu: http://localhost:3000/admin/products/create

110. Create Product Form Submission
-u komponentu product-form.tsx importujemo tip SubmitHandler iz paketa react-hook-form
-importujemo funkcije createProduct i updateProduct iz product.actions.ts fajla
-kreiramo asinhronu funkciju onSubmit() sa parametrom values
-form elementu dodajemo atribute method, className i dogadaj onSubmit
-u dogadaj onSubmit proslijedujemo funkciju form.handleSubmit(onSubmit)
-funkciji onSubmit() dodajemo tip SubmitHandler<z.infer<typeof insertProductSchema>>
-dodajemo dva uslova if (type === 'Create') i if (type === 'Update')
-u uslovu if (type === 'Create') pozivamo funkciju await createProduct(values)
-vrijednost funkcije await createProduct(values) pohranjujemo u varijablu const res
-dodajemo uslove if (!res.success) - else
-u uslovu if (!res.success) pozivamo funkciju toast()
-u uslovu else pozivamo funkcije toast() i router.push(`/admin/products`)
-u uslovu if (type === 'Update') dodajemo uslov if (!productId)
-u uslovu if (!productId) pozivamo funkciju router.push(`/admin/products`) i izjavu return
-pozivamo funkciju await updateProduct({ ... })
-vrijednost funkcije await updateProduct({ ... }) pohranjujemo u varijablu const res
-dodajemo uslove if (!res.success) - else
-u uslovu if (!res.success) pozivamo funkciju toast()
-u uslovu else pozivamo funkciju router.push(`/admin/products`)
-u validators.ts fajlu zakomentarisemo polja za images, isFeatured i banner
-u product.actions.ts fajlu, u funkciji getAllProducts(), u funkciju findMany() dodajemo objekt orderBy
-otvorimo rutu: http://localhost:3000/admin/products/create i kreiramo artikl

111. Uploadthing Configuration
-otvorimo web stranicu: https://uploadthing.com/
-otvorimo link: https://www.npmjs.com/package/uploadthing
-otvorimo link: https://www.npmjs.com/package/@uploadthing/react
-u terminalu ukucamo komandu: npm install uploadthing @uploadthing/react
-na web stranici uploadthing kreiramo novu aplikaciju sa imenom prostore
-otvorimo link: https://docs.uploadthing.com/getting-started/appdir
-u .env fajlu kreiramo varijable UPLOADTHING_TOKEN, UPLOADTHING_SECRET i UPLOADTHING_APPID
-u example.env fajl dodajemo primjer varijabli koje je potrebno kreirati
-u folderu api kreiramo folder uploadthing
-u folderu uploadthing kreiramo fajlove core.ts i route.ts fajl
-u folderu lib kreiramo uploadthing.ts fajl
-u kreirane fajlove dodajemo kod iz dokumentacije
-u next.config.ts fajl dodajemo objekt images

112. Add Image Uploads
-na web stranici Vercel, dodajemo env varijable u projekt
-u validators.ts fajlu otkomentarisemo polje za images
-u komponentu product-form.tsx importujemo komponentu UploadButton iz lib/uploadthing.ts fajla
-kreiramo varijablu const images
-importujemo komponente Card i CardContent iz komponente ui/card.tsx
-importujemo komponentu Image iz paketa next/image
-u jsx-u, u div element za slike dodajemo komponentu FormField
-komponenti FormField dodajemo prop control, name i render
-u prop render proslijedujemo anonimnu funkciju
-u anonimnu funkciju proslijedujemo komponentu FormItem kao roditelj element
-u komponentu FormItem dodajemo komponente FormLabel, Card i FormMessage
-u komponentu Card dodajemo komponentu CardContent
-u komponenti CardContent kreiramo div element sa Tailwind CSS klasama
-u div elementu pozivamo funkciju images?.map()
-u funkciju map() dodajemo komponentu Image sa sest prop
-u div element dodajemo komponentu FormControl
-u komponentu FormControl dodajemo komponentu UploadButton sa samozatvarajucim tagom
-komponenti UploadButton dodajemo prop endpoint, onClientUploadComplete i onUploadError
-u globals.css fajl dodajemo CSS stil za klasu upload-field
-u pretrazivacu otvorimo rutu: http://localhost:3000/admin/products/create i kreiramo artikl sa slikom
-otvorimo Prisma Studio tabelu za artikle 
-otvorimo web stranicu uploadthing i folder files
-kreirani artikl treba da ima sliku kao link, npr: https://utfs.io/f/ZYaPZhbDOB8SBRbbNxmVRESjYw3u95LGrKdyPxZicXNvozJ2
-otvorimo link: https://docs.uploadthing.com/api-reference/ut-api#delete-files

113. Product Cleanup
-obrisemo sve postojece artikle i kreiramo nove artikle sa slikama
-u komponenti admin/products/page.tsx dodajemo ternarni uslov products?.data?.length === 0
-umjesto uslova products?.totalPages && products.totalPages > 1 dodajemo samo uslov products?.totalPages > 1 && (...)

114. Is Featured & Banner
-u validators.ts fajlu, otkomentarisemo polja za isFeatured i banner
-otvorimo link: https://ui.shadcn.com/docs/components/checkbox
-u terminalu ukucamo komandu: npx shadcn@latest add checkbox
-u komponenti products/create/product-form.tsx kreiramo varijable const isFeatured i const banner
-u div element za sliku isFeatured dodajemo komponentu Card
-u komponentu Card dodajemo komponentu CardContent
-u komponentu CardContent dodajemo komponentu FormField sa prop name, control i render
-u komponentu CardContent dodajemo uslov za kondicionalno renderovanje isFeatured && banner && ()
-u uslov za kondicionalno renderovanje dodajemo komponentu Image
-dodajemo uslov za kondicionalno renderovanje isFeatured && !banner && ()
-u uslov za kondicionalno renderovanje dodajemo komponentu UploadButton
-otvorimo rutu: http://localhost:3000/admin/products/create i kreiramo artikl sa slikom banner

115. Product Update Form
-u product.actions.ts fajlu kreiramo i eksportujemo asinhronu funkciju getProductById()
-funkciji getProductById() dodajemo parametar productId sa tipom string
-u funkciji getProductById() pozivamo funkciju await prisma.product.findFirst()
-vrijednost funkcije await prisma.product.findFirst() pohranjujemo u varijablu const data
-dodajemo izjavu return convertToPlainObject(data)
-komponentu product-form.tsx premjestamo u folderu products
-u folderu products kreiramo folder [id] i komponentu page.tsx
-u komponenti [id]/page.tsx kreiramo i eksportujemo asinhronu funkciju AdminUpdateProductPage() kao default
-importujemo tip Metadata iz paketa next
-importujemo funkciju notFound iz paketa next/navigation
-importujemo funkciju getProductById iz product.actions.ts fajla
-kreiramo i eksportujemo varijablu const metadata sa tipom Metadata
-importujemo komponentu ProductForm iz komponente product-form.tsx
-funkciji AdminUpdateProductPage() dodajemo parametar props
-u funkciji AdminUpdateProductPage() pozivamo funkciju await props.params
-vrijednost funkcije await props.params pohranjujemo u destruktuiranu varijablu const { id }
-pozivamo funkciju await getProductById(id)
-vrijednost funkcije await getProductById(id) pohranjujemo u varijablu const product
-dodajemo uslov if (!product)
-u uslovu if (!product) pozivamo funkciju return notFound()
-u jsx-u dodajemo roditelj div elementu Tailwind CSS klase
-u div elementu kreiramo h2 element sa Tailwind CSS klasama
-u roditelj div element dodajemo komponentu ProductForm sa prop type, product i productId
-otvorimo rutu: http://localhost:3000/admin/products/fdd0dffc-6e82-47c5-8426-faae481fb40a i izmjenimo podatke o artiklu


Section 12: Admin Users & Search

116. Section Intro

117. Get & Display Users
-u user.actions.ts fajl importujemo varijablu PAGE_SIZE iz constants/index.ts fajla
-kreiramo i eksportujemo asinhronu funkciju getAllUsers()
-funkciji getAllUsers() dodajemo destruktuirane parametre limit i page sa tipom number
-u funkciji getAllUsers() pozivamo funkciju await prisma.user.findMany()
-vrijednost funkcije await prisma.user.findMany() pohranjujemo u varijablu const data
-pozivamo funkciju await prisma.user.count()
-vrijednost funkcije await prisma.user.count() pohranjujemo u varijablu const dataCount
-dodajemo izjavu return objekt sa varijablama data i totalPages
-u folderu admin kreiramo folder users i komponentu page.tsx
-u komponenti users/page.tsx kreiramo i eksportujemo asinhronu funkciju  AdminUsersPage() kao default
-importujemo tip Metadata iz paketa next
-importujemo funkciju getAllUsers iz user.actions.ts fajla
-importujemo funkciju requireAdmin iz auth-guard.ts fajla
-kreiramo varijablu const metadata sa tipom Metadata
-u funkciji AdminUsersPage() pozivamo funkciju await requireAdmin()
-pozivamo funkciju await getAllUsers()
-vrijednost funkcije await getAllUsers() pohranjujemo u varijablu const users
-funkciji AdminUsersPage() dodajemo parametar props
-u funkciji AdminUsersPage() pozivamo funkciju await props.searchParams
-vrijednost funkcije await props.searchParams pohranjujemo u varijablu const searchParams
-iz varijable searchParams destruktuiramo varijablu const { page = '1' }
-importujemo komponente za tabelu iz komponente ui/table.tsx
-importujemo funkciju formatId iz lib/utils.ts fajla
-importujemo komponentu Button iz komponente ui/button.tsx
-importujemo komponentu Link iz komponente next/link
-importujemo komponentu Pagination iz komponente pagination.tsx
-u jsx-u kreiramo h2 element sa klasom h2-bold
-u roditelj div elementu kreiramo div element za komponentu Table
-u komponentu Table dodajemo komponente TableHeader i TableBody
-u komponenti TableBody pozivamo funkciju users?.data?.map()
-u funkciju map() dodajemo komponentu TableRow
-u komponentu TableRow dodajemo pet komponenti TableCell u kojima dinamicki ispisujemo podatke o korisnicima
-u div element u kojoj se nalazi komponente Table dodajemo uslov za kondicionalno renderovanje users.totalPages > 1
-importujemo komponentu Badge iz komponente ui/badge.tsx
-u komponenti TableCell za rolu korisnika dodajemo uslov ternarni operator user.role === 'user'
-otvorimo rutu: http://localhost:3000/admin/users
-otvorimo rutu: http://localhost:3000/admin/users?page=2

118. Delete Users
-u user.actions.ts fajl importujemo funkciju revalidatePath iz paketa next/cache
-kreiramo i eksportujemo asinhronu funkciju deleteUser()
-funkciji deleteUser() dodajemo parametar id sa tipom string
-dodajemo blokove koda try - catch
-u bloku koda catch dodajemo izjavu objekt return poruku da je doslo do greske prilikom brisanja korisnika
-u bloku koda try pozivamo funkciju prisma.user.delete()
-pozivamo funkciju revalidatePath('/admin/users')
-dodajemo izjavu objekt return poruku da je korisnik uspjesno obrisan
-u komponentu admin/users importujemo funkciju deleteUser iz user.actions.ts fajla
-importujemo komponentu DeleteDialog iz komponente shared/delete-dialog.tsx
-u zadnju komponentu TableCell dodajemo komponentu DeleteDialog sa prop id i action
-otvorimo rutu http://localhost:3000/admin/users i obrisemo jednog korisnika

119. User Edit Page
-u folderu admin/users kreiramo folder [id] i komponentu page.tsx
-u komponenti [id]/page.tsx kreiramo i eksportujemo asinhronu funkciju AdminUserUpdatePage() kao default
-u validators.ts fajlu kreiramo i eksportujemo varijablu const updateUserSchema
-u .env fajlu kreiramo varijablu USER_ROLES
-u example.env fajl dodajemo primjer varijable koju je potrebno kreirati
-u constants/index.ts fajlu kreiramo i eksportujemo varijablu const USER_ROLES
-otvorimo link: https://ui.shadcn.com/docs/components/select
-u terminalu ukucamo komandu: npx shadcn@latest add select
-u komponentu users/[id]/page.tsx importujemo tip Metadata iz paketa next
-importujemo funkciju notFound iz paketa next/navigation
-importujemo funkciju getUserById iz user.actions.ts fajla
-kreiramo i eksportujemo varijablu const metadata sa tipom Metadata
-funkciji AdminUserUpdatePage() dodajemo parametar props
-u funkciji AdminUserUpdatePage() pozivamo funkciju await props.params
-vrijednost funkcije await props.params pohranjujemo u destruktuiranu varijablu const { id }
-pozivamo funkciju await getUserById(id)
-vrijednost funkcije await getUserById(id) pohranjujemo u varijablu const user
-dodajemo uslov if (!user)
-u uslovu if (!user) pozivamo funkciju notFound()
-u jsx-u roditelj div elementu dodajemo Tailwind CSS klase
-kreiramo h2 element sa klasom h2-bold
-otvorimo rutu: http://localhost:3000/admin/users/[id]

120. Update User Form
-u folderu users/[id] kreiramo komponentu update-user-form.tsx
-u komponenti update-user-form.tsx kreiramo i eksportujemo funkciju UpdateUserForm() kao default
-dodajemo direktivu 'use client'
-u komponentu [id]/page.tsx importujemo komponentu UpdateUserForm iz komponente update-user-form.tsx
-u roditelj div element dodajemo komponentu UpdateUserForm sa prop user
-u komponenti update-user-form.tsx, funkciji UpdateUserForm() dodajemo destruktuirani parametar user
-importujemo instancu z iz paketa zod
-importujemo varijablu updateUserSchema iz validators.ts fajla
-parametru user dodajemo tip z.infer<typeof updateUserSchema>
-importujemo funkciju useRouter iz paketa next/navigation
-importujemo funkciju useToast iz use-toast.ts fajla
-u funkciji UpdateUserForm() pozivamo funkciju useRouter()
-vrijednost funkcije useRouter() pohranjujemo u varijablu const router
-pozivamo funkciju useToast()
-vrijednost funkcije useToast() pohranjujemo u destruktuiranu varijablu const { toast }
-importujemo funkciju react-hook-form iz paketa react-hook-form
-importujemo funkciju zodResolver iz paketa @hookform/resolvers/zod
-kreiramo varijablu const form
-importujemo komponente za formu iz komponente ui/form.tsx
-u jsx-u dodajemo komponentu Form kao roditelj komponentu
-komponenti Form dodajemo prop {...form}
-u komponenti Form kreiramo form element
-form elementu dodajemo atribut method i dogadaj onSubmit
-kreiramo funkciju onSubmit()
-u dogadaj onSubmit proslijedujemo funkciju form.handleSubmit(onSubmit)
-importujemo tip ControllerRenderProps iz paketa react-hook-form
-importujemo komponentu Input iz komponente ui/input.tsx
-u form elementu kreiramo div element za Email polje
-u div element za Email polje dodajemo komponentu FormField
-kreiramo div element za Name polje
-u div element za Name polje dodajemo komponentu FormField
-importujemo select komponente iz komponente ui/select.tsx
-kreiramo div element za Role polje
-u div element za Rolje polje dodajemo komponentu FormField
-u prop render dodajemo komponentu FormItem
-u komponentu FormItem dodajemo komponente FormLabel, Select i FormMessage
-importujemo varijablu USER_ROLES iz constants/index.ts fajla
-importujemo komponentu Button iz komponente ui/button.tsx
-kreiramo div element za komponentu Button
-komponenti Button dodajemo prop type, className i disabled
-u komponentu Button dodajemo uslov ternarni operator form.formState.isSubmitting

121. Update User Action
-u user.actions.ts fajl importujemo varijablu updateUserSchema iz validators.ts fajla
-kreiramo i eksportujemo asinhronu funkciju updateUser()
-funkciji updateUser() dodajemo parametar user sa tipom z.infer<typeof updateUserSchema
-u funkciju updateUser() dodajemo blokove koda try - catch
-u blok koda catch dodajemo izjavu return objekt sa key - value parovima success i message
-u bloku koda try pozivamo funkciju await prisma.user.update()
-pozivamo funkciju revalidatePath('/admin/users')
-dodajemo izjavu return objekt sa porukom da je korisnik uspjesno azuriran
-u komponenti update-user-form.tsx, funkciji onSubmit() dodajemo asinhronost i parametar values
-parametru values dodajemo tip z.infer<typeof updateUserSchema>
-importujemo funkciju updateUser iz user.actions.ts fajla
-dodajemo blokove koda try - catch
-u bloku koda catch pozivamo funkciju toast()
-u bloku koda try pozivamo funkciju await updateUser()
-vrijednost funkcije await updateUser() pohranjujemo u varijablu const res
-dodajemo uslov if (!res.success)
-u uslovu if (!res.success) pozivamo funkciju return toast()
-nakon uslova if (!res.success) pozivamo funkciju toast()
-pozivamo funkciju form.reset()
-pozivamo funkciju router.push('/admin/users')

122. Admin Search Form
-u folderu app/admin kreiramo komponentu admin-search.tsx
-u komponenti admin-search.tsx kreiramo i eksportujemo funkciju AdminSearch() kao default
-dodajemo direktivu 'use client'
-u komponentu admin/layout.tsx importujemo komponentu AdminSearch iz komponente admin-search.tsx
-u jsx-u, u div element gdje se nalazi komponentu Menu dodajemo komponentu AdminSearch
-u komponentu admin-search.tsx importujemo funkciju usePathname iz paketa next/navigation
-importujemo funkciju useSearchParams iz paketa next/navigation
-importujemo funkcije useEffect i useState iz paketa react
-importujemo komponentu Input iz komponente ui/input.tsx
-u funkciji AdminSearch() pozivamo funkciju usePathname()
-vrijednost funkcije usePathname() pohranjujemo u varijablu const pathname
-kreiramo varijablu formActionUrl
-pozivamo funkciju useSearchParams()
-vrijednost funkcije useSearchParams() pohranjujemo u varijablu const searchParams
-pozivamo funkciju useState()
-vrijednost funkcije useState() pohranjujemo u state varijablu const queryValue i set funkciju setQueryValue
-pozivamo funkciju useEffect() sa dva argumenta
-u funkciji useEffect() prvi argument je anonimna funkcija, dok je drugi argument niz
-u anonimnoj funkciji pozivamo funkciju setQueryValue
-u niz dodajemo varijablu searchParams
-u jsx-u kreiramo form element kao roditelj element
-form elementu dodajemo dogadaj action i atribut method
-u dogadaj action proslijedujemo varijablu formActionUrl
-u form element dodajemo komponentu Input 
-komponenti Input dodajemo prop type, placeholder, name, value, onChange i className
-kreiramo button element sa atributima type i className
-u komponenti admin/products/page.tsx kreiramo div element sa Tailwind CSS klasama flex items-center gap-3
-u div element dodajemo h2 element i uslov za kondicionalno renderovanje searchText

123. Admin Order Search
-u komponenti admin/orders/page.tsx kreiramo komponentu TableHead za polje BUYER
-kreiramo komponentu TableCell za dinamicko prikazivanje informacije o kupcu
-u order.actions.ts fajlu, funkciji getAllOrders() dodajemo destruktuirani parametar query
-parametru query dodajemo tip string
-kreiramo varijablu const queryFilter sa tipom Prisma.OrderWhereInput
-u funkciju prisma.order.findMany() dodajemo objekt where
-u komponenti admin/orders/page.tsx, funkciji AdminOrdersPage() dodajemo parametar query
-parametru query dodajemo tip string
-iz funkcije await props.searchParams destruktuiramo varijablu query: searchText
-funkciji getAllOrders() dodajemo parametar query: searchText
-u jsx-u kreiramo div element sa Tailwind CSS klasama
-u div element sa Tailwind CSS klasama dodajemo h2 element
-dodajemo uslov za kondicionalno renderovanje searchText && (...)
-otvorimo rutu: http://localhost:3000/admin/orders

124. Admin User Search
-u user.actions.ts fajl importujemo instancu Prisma iz paketa @prisma/client
-funkciji getAllUsers() dodajemo destruktuirani parametar query
-parametru query dodajemo tip string
-kreiramo varijablu const queryFilter sa tipom Prisma.UserWhereInput
-u funkciju prisma.order.findMany() dodajemo objekt where
-u komponenti admin/users/page.tsx, funkciji AdminUsersPage() dodajemo parametar query
-parametru query dodajemo tip string
-iz funkcije await props.searchParams destruktuiramo varijablu query: searchText
-funkciji getAllUsers() dodajemo parametar query: searchText
-u roditelj div elementu kreiramo div element sa Tailwind CSS klasama
-u div element sa Tailwind CSS klasama dodajemo h2 element
-dodajemo uslov za kondicionalno renderovanje searchText && (...)
-dodajemo ternarni uslov users?.data?.length > 0
-otvorimo rutu: http://localhost:3000/admin/users
-u product.actions.ts fajl importujemo instancu Prisma iz paketa @prisma/client
-u funkciji getAllProducts() kreiramo varijablu const queryFilter sa tipom Prisma.ProductWhereInput
-u funkciju findMany() dodajemo objekt where
-otvorimo rutu: http://localhost:3000/admin/products

Delete product image(s) - uploadthing
-u core.ts fajl importujemo funkciju UTApi iz paketa uploadthing/server
-pozivamo funkciju new UTApi()
-vrijednost funkcije new UTApi() pohranjujemo u varijablu const utapi
-eskportujemo varijablu const utapi
-u product.actions.ts fajl importujemo varijablu utapi iz core.ts fajla
-u funkciju deleteProduct() dodajemo logiku za brisanje slike ili slika sa web stranice uploadthing nakon brisanja artikla

Update product image(s) - uploadthing
-kreiramo image.actions.ts fajl
-u image.actions.ts fajl dodajemo direktivu 'use server'
-importujemo funkcije UTApi i formatError
-kreiramo i eskportujemo asinhronu funkciju deleteImages()
-u product.actions.ts fajl importujemo funkciju deleteImages()
-u funkciji deleteProduct() pozivamo funkciju deleteImages()
-funkciji updateProduct() dodajemo parametar imagesToBeDeleted
-u funkciju updateProduct() dodajemo uslov if (data.imagesToBeDeleted && data.imagesToBeDeleted.length > 0)
-u uslovu if pozivamo funkciju await deleteImages(data.imagesToBeDeleted)
-u komponentu product-form.tsx dodajemo logiku za brisanje slike i azuriranje nove slike
-importujemo i pozivamo funkciju useState() iz paketa react
-vrijednost funkcije useState pohranjujemo u state varijablu imagesToBeDeleted i set funkciju setImagesToBeDeleted()
-kreiramo asinhronu funkciju handleImageRemove()
-u funkciji handleImageRemove() kreiramo varijablu const imageKey
-pozivamo funkciju setImagesToBeDeleted()
-kreiramo varijablu const filteredImages
-pozivamo funkciju form.setValue()
-funkciji updateProduct() dodajemo destruktuirani argument imagesToBeDeleted


Section 13: Search Filtering, Drawer & Carousel

125. Section Intro

126. Categories Drawer
-u product.actions.ts fajlu kreiramo i eksportujemo asinhronu funkciju getAllCategories()
-u funkciji getAllCategories() pozivamo funkciju await prisma.product.groupBy()
-vrijednost funkcije await prisma.product.groupBy() pohranjujemo u varijablu const data
-dodajemo izjavu return data
-otvorimo link: https://ui.shadcn.com/docs/components/drawer
-u terminalu ukucamo komandu: npx shadcn@latest add drawer
-u folderu components/shared/header kreiramo komponentu categories-drawer.tsx
-u komponenti categories-drawer.tsx kreiramo i eksportujemo asinhronu funkciju CategoriesDrawer.tsx
-importujemo funkciju getAllCategories iz product.actions.ts fajla
-u funkciji CategoriesDrawer() pozivamo funkciju await getAllCategories()
-vrijednost funkcije await getAllCategories() pohranjujemo u varijablu const categories
-importujemo komponente Drawer, DrawerClose, DrawerContent, DrawerHeader, DrawerTitle i DrawerTrigger iz komponente ui/drawer.tsx
-importujemo komponentu Button iz komponente ui/button.tsx
-importujemo React ikonicu MenuIcon iz paketa lucide-react
-importujemo komponentu Link iz paketa next/link
-u jsx-u dodajemo komponentu Drawer kao roditelj komponentu
-u komponentu Drawer dodajemo komponente DrawerTrigger i DrawerContent
-u komponentu DrawerTrigger dodajemo komponentu Button
-u komponentu Button dodajemo komponentu MenuIcon
-u komponentu DrawerContent dodajemo komponentu DrawerHeader
-u komponentu DrawerHeader dodajemo komponentu DrawerTitle
-kreiramo div element sa Tailwind CSS klasama
-u div element pozivamo funkciju categories?.map()
-u funkciju map() dodajemo komponentu Button
-komponenti Button dodajemo prop key, className, variant i asChild
-u komponentu Button dodajemo komponentu DrawerClose
-u komponentu DrawerClose dodajemo komponentu Link
-u komponentu shared/header/index.tsx importujemo komponentu CategoriesDrawer iz komponente categories-drawer.tsx
-u div element sa klasom flex-start dodajemo komponentu CategoriesDrawer
-otvorimo rutu: http://localhost:3000/ i kliknemo dugme u gornjem lijevom cosku

127. Featured Products Carousel
-otvorimo web stranicu: https://www.embla-carousel.com/
-otvorimo link: https://ui.shadcn.com/docs/components/carousel
-u terminalu ukucamo komandu: npx shadcn@latest add carousel
-otvorimo link: https://www.npmjs.com/package/embla-carousel-autoplay
-u terminalu ukucamo komandu: npm install embla-carousel-autoplay
-u product.actions.ts fajlu kreiramo i eksportujemo asinhronu funkciju getFeaturedProducts()
-u funkciji getFeaturedProducts() pozivamo funkciju await prisma.product.findMany()
-vrijednost funkcije await prisma.product.findMany() pohranjujemo u varijablu const data
-pozivamo funkciju return convertToPlainObject(data)
-u folderu components/shared/products kreiramo komponentu product-carousel.tsx
-u komponenti product-carousel.tsx kreiramo i eksportujemo funkciju ProductCarousel() kao default
-dodajemo direktivu 'use client'
-u komponentu app/(root)/page.tsx importujemo funkciju getFeaturedProducts iz product.actions.ts fajla
-importujemo komponentu ProductCarousel iz komponente product-carousel.tsx
-u funkciji Homepage() pozivamo funkciju await getFeaturedProducts()
-vrijednost funkcije await getFeaturedProducts() pohranjujemo u varijablu const featuredProducts
-u jsx-u dodajemo uslov za kondicionalno renderovanje featuredProducts.length > 0 && (...)
-u uslov za kondicionalno renderovanje dodajemo komponentu ProductCarousel sa prop data
-u komponenti product-carousel.tsx, funkciji ProductCarousel dodajemo parametar destruktuirani prop data
-importujemo tip Product iz types/index.ts fajla
-parametru data dodajemo tip Product
-importujemo komponente Carousel, CarouselContent, CarouselItem, CarouselNext i CarouselPrevious iz komponente ui/carousel.tsx
-importujemo komponentu Autoplay iz paketa embla-carousel-autoplay
-u jsx-u dodajemo komponentu Carousel kao roditelj element
-importujemo komponente Image i Next iz paketa next
-komponenti Carousel dodajemo prop className, opts i plugins
-u prop plugins dodajemo niz
-u niz dodajemo komponentu Autoplay sa prop delay, stopOnInteraction i stopOnMouseEnter
-u komponentu Carousel dodajemo komponentu CarouselContent
-u komponenti CarouselContent pozivamo funkciju data?.map()
-u funkciju map() dodajemo komponentu CarouselItem
-u komponentu CarouselItem dodajemo komponentu Link
-u komponenti Link kreiramo div element sa Tailwind CSS klasama
-u div element dodajemo komponentu Image i kreiramo div element sa Tailwind CSS klasama
-u komponentu CarouselContent dodajemo komponente CarouselPrevious i CarouselNext
-otvorimo rutu: http://localhost:3000/ da vidimo proizvode koji su oznaceni kao featured

128. Search Component
-u folderu components/shared/header kreiramo komponentu search.tsx
-u komponenti search.tsx kreiramo i eksportujemo asinhronu funkciju Search() kao default
-importujemo funkciju getAllCategories iz product.actions.ts fajla
-importujemo React ikonicu SearchIcon iz paketa lucide-react
-u funkciji Search() pozivamo funkciju await getAllCategories()
-vrijednost funkcije await getAllCategories() pohranjujemo u varijablu const categories
-u jsx-u kreiramo form element kao roditelj element
-form elementu dodajemo dogadaj action i atribut method
-u form elementu kreiramo div element sa Tailwind CSS flex klasama
-importujemo select komponente iz komponente ui/select.tsx
-u div element dodajemo komponentu Select
-u komponentu Select dodajemo komponente SelectTrigger i SelectContent
-u komponentu SelectTrigger dodajemo komponentu SelectValue
-u komponentu SelectContent dodajemo komponentu SelectItem sa prop key i value
-pozivamo funkciju categories?.map()
-u funkciju map() dodajemo komponentu SelectItem sa prop key i value
-u div element dodajemo komponentu Input sa prop name, type, placeholder i className
-u div element dodajemo komponentu Button
-u komponentu Button dodajemo komponentu SearchIcon
-u komponentu header/index.tsx importujemo komponentu Search iz komponente search.tsx
-u jsx-u kreiramo div element sa Tailwind CSS klasama hidden i md:block
-u div element dodajemo komponentu Search
-u folderu (root) kreiramo folder search i komponentu page.tsx
-u komponenti search/page.tsx kreiramo i eksportujemo funkciju SearchPage() kao default
-u komponentu menu.tsx importujemo komponentu Search iz komponente search.tsx
-u komponenti SheetContent kreiramo div element sa Tailwind CSS klasom mt-10
-u div element dodajemo komponentu Search
-otvorimo rutu: http://localhost:3000/search

129. Search Page
-u komponenti search/page.tsx funkciji SearchPage() dodajemo asinhronost
-funkciji SearchPage() dodajemo parametar props
-parametar props destruktuiramo u parametar searchParams sa tipom Promise
-iz parametra searchParams destruktuiramo parametre q, category, price, rating, sort i page
-parametrima dodajemo tip string
-u funkciji SearchPage() pozivamo funkciju await props.searchParams
-vrijednost funkcije await props.searchParams pohranjujemo u sest destruktuiranih varijabli
-importujemo funkciju getAllProducts iz product.actions.ts fajla
-u product.actions.ts fajlu funkciji getAllProducts() dodajemo destruktuirane parametre price, rating i sort
-parametrima dodajemo tip string
-u komponenti search/page.tsx, u jsx-u kreiramo roditelj div element sa Tailwind CSS Grid klasama
-importujemo komponentu ProductCard iz komponente product-card.tsx
-importujemo komponentu Pagination iz komponente pagination.tsx
-u roditelj div elementu kreiramo div element sa klasom filter-links
-u roditelj div elementu kreiramo div element sa Tailwind CSS klasama md:col-span-4 space-y-4
-kreiramo div element sa Tailwind CSS klasama grid grid-cols-1 gap-4 md:grid-cols-3
-dodajemo uslov za kondicionalno renderovanje products?.data?.length === 0 && (...)
-u uslov za kondicionalno renderovanje dodajemo element p sa porukom kako artikl nije pronaden
-pozivamo funkciju products?.data?.map()
-u funkciju map() dodajemo komponentu ProductCard sa prop key i product
-u div element sa Tailwind CSS klasama md:col-span-4 space-y-4 dodajemo uslov za kondicionalno renderovanje products?.totalPages > 1 && (...)
-u uslov za kondicionalno renderovanje dodajemo komponentu Pagination sa prop page i totalPages
-u folderu components kreiramo komponentu view-all-products-button.tsx
-u komponenti view-all-products-button.tsx kreiramo i eksportujemo funkciju ViewAllProductsButton() kao default
-importujemo komponentu Button iz komponente ui/button.tsx
-importujemo komponentu Link iz paketa next/link
-u jsx-u kreiramo roditelj div element sa Tailwind CSS flex klasama
-u div element dodajemo komponentu Button sa prop asChild i className
-u komponentu Button dodajemo komponentu Link sa prop href
-u komponentu (root)/page.tsx importujemo komponentu ViewAllProductsButton iz komponente view-all-products-button.tsx
-u jsx-u ispod komponente ProductList dodajemo komponentu ViewAllProductsButton
-otvorimo rutu: http://localhost:3000 i kliknemo dugme da pogledamo sve artikle

130. Search Filters
-u product.actions.ts fajlu, u funkciji getAllProducts() kreiramo varijablu const categoryFilter
-u funkciju findMany(), u objekt where dodajemo varijablu ...categoryFilter
-otvorimo rutu: http://localhost:3000/search?category=t-shirts&q=
-kreiramo varijablu const priceFilter sa tipom Prisma.ProductWhereInput
-u funkciju findMany(), u objekt where dodajemo varijablu ...priceFilter
-otvorimo rutu: http://localhost:3000/search?price=10-40
-kreiramo varijablu const const ratingFilter
-u funkciju findMany(), u objekt where dodajemo varijablu ...ratingFilter
-otvorimo rutu: http://localhost:3000/search?rating=0
-otvorimo rutu: http://localhost:3000/search?rating=5

131. Get Filter URL Function
-u komponenti search/page.tsx, u funkciji SearchPage() kreiramo funkciju getFilterUrl()
-funkciji getFilterUrl() dodajemo destruktuirane parametre c, s, p, r i pg
-kreiramo tip GetFilterUrlProps
-u funkciji getFilterUrl() destruktuiranim parametrima dodajemo tip GetFilterUrlProps
-kreiramo varijablu const params
-iz varijable params destruktuiramo varijable q, category, price, rating, sort i page 
-dodajemo pet if uslova
-dodajemo izjavu return u kojoj pozivamo funkciju new URLSearchParams(params)
-otvorimo rutu: http://localhost:3000/search i pretrazujemo artikle

132. Category & Price UI Filters
-u komponentu search/page.tsx importujemo funkciju getAllCategories iz product.actions.ts fajla
-u funkciji SearchPage() pozivamo funkciju await getAllCategories()
-vrijednost funkcije getAllCategories() pohranjujemo u varijablu const categories
-importujemo komponentu Link iz paketa next/link
-u jsx-u, u div elementu sa klasom filter-links kreiramo div elemente za prikazivanje filtera kategorije i cijene
-kreiramo folder helpers i prices.ts fajl
-u prices.ts fajlu kreiramo i eksportujemo niz const prices
-u komponentu search/page.tsx importujemo niz prices iz prices.ts fajla
-otvorimo rutu: http://localhost:3000/search i pretrazujemo artikle

133. Rating Filter & Filter Display
-u folderu helpers kreiramo ratings.ts fajl
-ratings.ts fajlu kreiramo i eksportujemo varijablu niz const ratings
-u komponentu search/page.tsx importujemo niz ratings
-importujemo komponentu Button iz komponente ui/button.tsx
-u jsx-u, u div elementu sa klasom filter-links kreiramo div element za prikazivanje filtera za recenzije
-u div element dodajemo logiku za sortiranje artikala na osnovu recenzije
-u div elementu sa Tailwind CSS klasama md:col-span-4 space-y-4 kreiramo div element sa Tailwind CSS flex klasama 
-u div elementu sa Tailwind CSS flex klasama dodajemo logiku za prikazivanje trazenih upita korisniku iznad artikala
-otvorimo rutu: http://localhost:3000/search i pretrazujemo artikle

134. Sorting Products
-u product.actions.ts fajlu, u funkciji getAllProducts(), u funkciju findMany(), u objekt orderBy dodajemo uslov ternarni operator sort === 'lowest'
-u folderu helpers kreirana sort-orders.ts fajl
-u sort-orders.ts fajlu kreiramo i eksportujemo varijablu niz const sortOrders
-u komponentu search/page.tsx importujemo niz sortOrders iz sort-orders.ts fajla
-u jsx-u, u div element za sortiranje pozivamo funkciju sortOrders.map()
-u div elementu kreiramo span i div elemente
-u div elementu pozivamo funkciju sortOrders?.map()
-u funkciju map() dodajemo komponentu Link
-komponenti Link dodajemo prop key, href i className
-otvorimo rutu: http://localhost:3000/search i pretrazujemo artikle

135. Dynamic Metadata
-otvorimo link: https://nextjs.org/docs/app/api-reference/functions/generate-metadata
-u komponenti search/page.tsx kreiramo i eksportujemo funkciju generateMetadata()
-funkciji generateMetadata() dodajemo parametar objekt props
-parametar props destruktuiramo u parametar objekt searchParams
-parametar objektu searchParams dodajemo tip Promise
-u funkciji generateMetadata() pozivamo funkciju await props.searchParams
-vrijednost funkcije await props.searchParams pohranjujemo u destruktuirane varijable q, category, price i rating
-kreiramo cetiri varijable const isQuerySet, const isCategorySet, const isPriceSet i const isRatingSet
-dodajemo uslov if (isQuerySet || isCategorySet || isPriceSet || isRatingSet) - else
-u uslov if dodajemo izjavu return objekt u kojem prikazujemo upite nakon pretrage
-u uslov else dodajemo izjavu return objekt u kojem prikazujemo samo naslov stranice Search Product
-otvorimo rutu: http://localhost:3000/search i pretrazujemo artikle


Section 14: Ratings & Reviews

136. Section Intro

137. Reviews Prisma Schema, Zod & Type
-u schema.prisma fajlu kreiramo model Review
-u modele User i Product dodajemo model Review
-u terminalu ukucamo komandu: npx prisma generate
-u terminalu ukucamo komandu: npx prisma migrate dev --name add-review
-u lib/validators.ts fajlu kreiramo i eksportujemo varijablu const insertReviewSchema
-u constants/index.ts fajl importujemo varijablu insertReviewSchema iz validators.ts fajla
-kreiramo i eksportujemo tip Review
-u lib/constants/index.ts fajlu kreiramo i eksportujemo varijablu objekt const reviewFormDefaultValues

138. Review List Component
-u folderu app/(root)/product/[slug] kreiramo komponentu review-list.tsx
-u komponenti review-list.tsx kreiramo i eksportujemo funkciju ReviewList() kao default
-dodajemo direktivu 'use client'
-funkciji ReviewList() doda parametre destruktuirane prop userId, productId i productSlug
-parametrima dodajemo tipove string
-u komponentu [slug]/page.tsx importujemo funkciju auth iz auth.ts fajla
-importujemo komponentu ReviewList iz komponente review-list.tsx
-u funkciji ProductDetailsPage() pozivamo funkciju await auth()
-vrijednost funkcije await auth() pohranjujemo u varijablu const session
-kreiramo varijablu const userId
-u jsx-u dodajemo prazan fragment kao roditelj element
-u praznom fragmentu kreiramo section element sa Tailwind CSS klasama
-u section elementu kreiramo h2 element
-u section element dodajemo komponentu ReviewList 
-komponenti ReviewList dodajemo prop productId, productSlug i userId
-otvorimo rutu: http://localhost:3000/product/[productSlug]
-u komponentu review-list.tsx importujemo funkciju useState iz paketa react
-importujemo tip Review iz types/index.ts fajla
-importujemo komponentu Link iz paketa next/link
-u funkciji ReviewList() pozivamo funkciju useState() sa tipom Review[]
-vrijednost funkcije useState() pohranjujemo u state varijablu const reviews i set funkciju setReviews
-u jsx-u kreiramo div element sa Tailwind CSS klasom space-y-4
-u div element dodajemo uslov za kondicionalno renderovanje reviews.length === 0 && (...)
-dodajemo uslov ternarni operator za varijablu userId
-u prvi dio ternarnog operatora dodat cemo formu za recenzije
-u drugi dio ternarnog operatora kreiramo div element
-u div elementu kreiramo dva span elementa i dodajemo komponentu Link
-komponenti Link dodajemo prop className i dinamicki prop href
-u roditelj div elementu kreiramo div element sa Tailwind CSS klasama

139. Review Form Dialog Component
-u folderu product/[slug] kreiramo komponentu review-form.tsx
-u komponenti review-form.tsx kreiramo i eksportujemo funkciju ReviewForm() kao default
-dodajemo direktivu 'use client'
-funkciji ReviewForm() dodajemo destruktuirane parametre prop userId, productId i onReviewSubmitted
-destruktuiranim parametrima dodajemo tipove
-u komponentu review-list.tsx importujemo komponentu ReviewForm iz komponente review-form.tsx
-u prvi dio ternarnog uslova za varijablu userId dodajemo komponentu ReviewForm
-komponenti ReviewForm dodajemo prop userId i productId
-u komponentu review-form.tsx importujemo funkciju useState iz paketa react
-u funkciji ReviewForm() pozivamo funkciju useState()
-vrijednost funkcije useState pohranjujemo u state varijablu const open i set funkciju setOpen
-importujemo funkciju useToast iz use-toast.ts fajla
-u funkciji ReviewForm() pozivamo funkciju useToast()
-vrijednost funkcije useToast() pohranjujemo u destruktuiranu varijablu const { toast }
-importujemo funkciju useForm iz paketa react-hook-form
-importujemo instancu z iz paketa zod
-importujemo varijablu insertReviewSchema iz validators.ts fajla
-importujemo funkciju zodResolver iz paketa @hookform/resolvers/zod
-importujemo varijablu reviewFormDefaultValues iz constants/index.ts fajla
-u funkciji ReviewForm() pozivamo funkciju useForm()
-funkciji useForm() dodajemo tip z.infer<typeof insertReviewSchema>
-funkciji useForm() dodajemo konfiguracioni objekt sa key - value parovima resolver i defaultValues
-vrijednost funkcije useForm() pohranjujemo u varijablu const form
-importujemo komponente za dialog iz komponente ui/dialog.tsx
-importujemo komponentu Button iz komponente ui/button.tsx
-u jsx-u dodajemo komponentu Dialog kao roditelj komponentu
-komponenti Dialog dodajemo prop open i onOpenChange
-u komponentu Dialog dodajemo komponentu Button
-komponenti Button dodajemo dogadaj Click i prop variant
-kreiramo funkciju handleOpenForm()
-u funkciju handleOpenForm() proslijedujemo funkciju setOpen(true)
-u dogadaj onClick proslijedujemo funkciju handleOpenForm
-u komponentu Dialog dodajemo komponentu DialogContent
-importujemo komponente za formu iz komponente ui/button.tsx
-importujemo komponentu Input iz komponente ui/input.tsx
-u komponentu DialogContent dodajemo komponentu Form sa prop {...form}
-u komponenti Form kreiramo form element sa atributom method
-u form element dodajemo komponentu DialogHeader
-u komponentu DialogHeader dodajemo komponentu DialogTitle
-u komponentu DialogHeader dodajemo komponentu DialogDescription
-kreiramo div element sa Tailwind CSS Grid klasama
-u div element dodajemo komponentu FormField za naslov recenzije
-importujemo komponentu Textarea iz komponente ui/textarea.tsx
-dodajemo komponentu FormField za opis recenzije
-importujemo komponente select iz komponente ui/select.tsx
-importujemo React ikonicu StarIcon iz paketa lucide-react
-dodajemo komponentu FormField za ocjenu
-u form element dodajemo komponentu DialogFooter
-u komponentu DialogFooter dodajemo komponentu Button
-u komponentu Button dodajemo uslov ternarni operator form.formState.isSubmitting
-otvorimo rutu: -otvorimo rutu: http://localhost:3000/product/[productSlug]

140. Create & Update Review Action
-u komponentu (root)/order/[id]/page.tsx importujemo funkciju redirect iz paketa next/navigation
-dodajemo uslov if da jedan korisnik ne moze da vidi narudzbu drugog korisnika
-u uslovu if pozivamo funkciju return redirect('/unauthorized')
-u folderu actions kreiramo review.actions.ts fajl
-u review.actions.ts fajl dodajemo direktivu 'use server'
-kreiramo i eksportujemo asinhronu funkciju createUpdateReview() sa parametrom data
-importujemo instancu z iz paketa zod
-importujemo varijablu insertReviewSchema iz validators.ts fajla
-parametru data dodajemo tip z.infer<typeof insertReviewSchema>
-dodajemo blokove koda try - catch
-importujemo funkciju formatError iz utils.ts fajla
-u blok koda catch dodajemo izjavu objekt return sa key - value parovima success i message
-importujemo funkciju auth iz auth.ts fajla
-u bloku koda try pozivamo funkciju await auth()
-vrijednost funkcije await auth() pohranjujemo u varijablu const session
-dodajemo uslov if(!session)
-kreiramo varijablu const review
-importujemo funkciju prisma iz prisma.ts fajla
-kreiramo varijablu const product
-dodajemo uslov if (!product)
-kreiramo varijablu const reviewExists
-pozivamo funkciju await prisma.$transaction()
-u funkciji $transaction() pozivamo anonimnu asinhronu funkciju sa parametrom tx
-u anonimnu funkciju dodajemo uslove if (reviewExists) - else
-u uslovu if (reviewExists) pozivamo funkciju await tx.review.update()
-u uslovu else pozivamo funkciju await tx.review.create()
-nakon uslova if (reviewExists) - else kreiramo varijablu const averageRating
-kreiramo varijablu const numReviews
-pozivamo funkciju await tx.product.update()
-pozivamo funkciju revalidatePath(`/product/${product.slug}`)
-dodajemo izjavu return objekt sa key - value parovima success i message

141. Connect Review Form To Action
-u komponentu review-form.tsx importujemo tip SubmitHandler iz paketa react-hook-form
-importujemo funkciju createUpdateReview iz review.actions.ts fajla
-u funkciji ReviewList() kreiramo asinhronu funkciju onSubmit() sa tipom SubmitHandler
-funkciji onSubmit() dodajemo parametar values
-u funkciji onSubmit() pozivamo funkciju await createUpdateReview()
-vrijednost funkcije await createUpdateReview() pohranjujemo u varijablu const res
-dodajemo uslov if (!res.success)
-u uslovu if (!res.success) pozivamo funkciju return toast()
-pozivamo funkcije setOpen(false), onReviewSubmitted() i toast()
-u jsx-u form elementu dodajemo dogadaj onSubmit
-u dogadaj onSubmit proslijedujemo funkciju form.handleSubmit(onSubmit)
-u funkciji handleOpenForm() pozivamo dvije funkcije form.setValue()
-u komponenti review-list.tsx kreiramo asinhronu funkciju reload
-u jsx-u komponenti ReviewForm dodajemo prop onReviewSubmitted
-u prop onReviewSubmitted proslijedujemo funkciju reload
-otvorimo rutu: http://localhost:3000/product/[productSlug]

142. Get Reviews Actions
-u review.actions.ts fajlu kreiramo i eksportujemo asinhronu funkciju getReviews()
-funkciji getReviews() dodajemo destruktuirani parametar productId sa tipom string
-u funkciji getReviews() pozivamo funkciju await prisma.review.findMany()
-vrijednost funkcije await prisma.review.findMany() pohranjujemo u varijablu const data
-u funkciju findMany() dodajemo objekte where, include i orderBy
-dodajemo izjavu return objekt data
-kreiramo i eksportujemo asinhronu funkciju getReviewByProductId()
-funkciji getReviewByProductId() dodajemo destruktuirani parametar productId sa tipom string
-u funkciji getReviewByProductId() pozivamo funkciju await auth()
-vrijednost funkcije await auth() pohranjujemo u varijablu const session
-dodajemo uslov if (!session)
-u uslovu if (!session) pozivamo funkciju throw new Error()
-pozivamo funkciju return await prisma.review.findFirst()
-u funkciju findFirst() dodajemo objekt where

143. Display Reviews
-u types/index.ts fajl, u tip Product dodajemo polje numReviews sa tipom number
-u komponentu review-list.tsx importujemo funkciju useEffect iz paketa react
-importujemo funkciju getReviews iz review.actions.ts fajla
-pozivamo funkciju useEffect() sa dva argumenta
-prvi argument u funkciji useEffect() je anonimna funkcija, dok je drugi argument niz
-u niz dodajemo varijablu productId
-u anonimnoj funkciji kreiramo asinhronu funkciju loadReviews()
-u funkciji loadReviews() pozivamo funkciju await getReviews({ productId })
-vrijednost funkcije getReviews() pohranjujemo u varijablu const res
-pozivamo funkciju setReviews(res.data)
-u anonimnoj funkciji pozivamo funkciju loadReviews()
-importujemo card komponente iz komponente ui/card.tsx
-importujemo React ikonice User i Calendar iz paketa lucide-react
-importujemo funkciju formatDateTime iz utils.ts fajla
-u jsx-u, u roditelj div elementu, u zadnji div element sa Tailwind CSS flex klasama pozivamo funkciju reviews.map()
-u funkciju map() dodajemo komponentu Card kao roditelj element
-u komponentu Card dodajemo komponente CardHeader i CardContent
-u komponenti Card dinamicki prikazujemo podatke o recenzijama
-u folderu components/shared/product kreiramo komponentu rating.tsx
-u komponenti rating kreiramo i eksportujemo funkciju Rating()
-funkciji Rating() dodajemo parametre destruktuirane prop value i caption
-u funkciji Rating() kreiramo tri funkcije Full(), Half() i Empty()
-u jsx-u dodajemo pet ternarnih uslova za varijablu value
-dodajemo uslov za kondicionalno renderovanje caption && (...)
-u komponentu review-list.tsx importujemo komponentu Rating iz komponente rating.tsx
-u komponentu CardContent dodajemo komponentu Rating
-komponenti Rating dodajemo prop value
-u komponentu product/[slug]/page.tsx importujemo komponentu Rating iz komponente rating.tsx
-u jsx-u, u div elemente za detalje artikla dodajemo komponentu Rating sa prop value
-u komponentu product-card.tsx importujemo komponentu komponentu Rating iz komponente rating.tsx
-u jsx-u, u div element sa Tailwind CSS flex klasama dodajemo komponentu Rating sa prop value
-otvorimo rutu: http://localhost:3000/ da vidimo recenzije artikla
-otvorimo rutu: http://localhost:3000/product/[productSlug] da vidimo recenzije artikla

144. Update & Reload Reviews
-u komponentu review-form.tsx importujemo funkciju getReviewByProductId iz review.actions.ts fajla
-funkciji handleOpenForm() dodajemo asinhronost
-pozivamo funkciju await getReviewByProductId({ productId })
-vrijednost funkcije await getReviewByProductId() pohranjujemo u varijablu const review
-dodajemo uslov if (review)
-u uslovu if (review) pozivamo tri funkcije form.setValue()
-nakon uslova if (review) pozivamo funkciju setOpen(true)
-u komponentu review-list.tsx importujemo funkciju useToast iz use-toast.ts fajla
-u funkciji ReviewList() pozivamo funkciju useToast()
-vrijednost funkcije useToast() pohranjujemo u destruktuiranu varijablu const { toast }
-funkciji reload() dodajemo asinhronost
-u funkciju reload() dodajemo blokove koda try - catch
-u bloku koda try pozivamo funkciju await getReviews({ productId })
-vrijednost funkcije await getReviews() pohranjujemo u varijablu const res
-pozivamo funkciju setReviews([...res.data])
-u bloku koda catch pozivamo funkciju toast()
-otvorimo rutu: http://localhost:3000/product/[productSlug] da vidimo recenzije artikla
-otvorimo rutu: http://localhost:3000/ da vidimo recenzije artikla

React Icons package added
-u komponentu rating.tsx importujemo React ikonice iz paketa react-icons
-u komponentu product/[slug]/page.tsx, u span element dodajemo uslov ternarni operator product.numReviews === 1
-otvorimo rutu: http://localhost:3000/ da vidimo recenzije artikla
-otvorimo rutu: http://localhost:3000/product/[productSlug] da vidimo recenzije artikla


Section 15: Stripe Payments

145. Section Intro