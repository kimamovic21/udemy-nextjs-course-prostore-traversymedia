Next.js E-commerce - Build a Shopping Platform From Scratch


Section 01: Introduction

01. Welcome To The Course

02. The Stack

03. The Project

04. The Environment

05. Premium Docs

06. Final Code & Demo


Section 02: App Creation & Basics Layout

07. Section Intro

08. Create Next App & Assets
-preuzemo folder resources
-otvorimo web stranicu: https://nextjs.org/
-u terminalu ukucamo komandu npx create-next-app@latest .
-ukucamo komandu npm run dev 
-u komponentu layout.tsx importujemo funkciju Inter iz paketa next/font/google
-kreiramo varijablu const inter
-u jsx-u, u prop className proslijedujemo dinamicku vrijednost varijable inter
-brisemo globals.css fajl
-kreiramo folder assets
-u folder assets dodajemo starter folder styles sa globals.css fajlom i loader.gif sliku
-u komponentu layout.tsx importujemo globals.css fajl
-u komponenti app/page.tsx kreiramo i eksportujemo funkciju Homepage() kao default
-u folder app dodajemo logo favicon.ico
-u folder public dodajemo folder images

09. ShadCN UI Setup
-otvorimo web stranicu: https://ui.shadcn.com/
-u terminalu ukucamo komandu: npx shadcn@latest init
-odaberemo opciju Use --legacy-peer-deps
-nakon instalacije paketa Shadcn generisan folder lib i utils.ts fajl
-nakon instalacije paketa Shadcn generisan components.json fajl
-ukucamo komandu: npx shadcn@latest add button
-nakon instalacije komponente button generisan folderi components, ui i komponenta button.tsx
-otvorimo link: https://ui.shadcn.com/docs/react-19

10. Root Layout & Constants
-u folderu app kreiramo folder (root) i komponentu layout.tsx
-u komponenti (root)/layout.tsx kreiramo i eksportujemo funkciju RootLayout() kao default
-u jsx-u kreiramo HTML elemente sa Tailwind CSS klasama
-u main element dodajemo prop children
-komponentu app/page.tsx premjestamo u folder (root)
-u folderu lib kreiramo folder constants i index.ts fajl
-u constants/index.ts fajlu kreiramo i eksportujemo varijable const APP_NAME, APP_DESCRIPTION i const SERVER_URL
-kreiramo .env fajl
-u .env fajlu kreiramo tri env varijable NEXT_PUBLIC_APP_NAME, NEXT_PUBLIC_APP_DESCRIPTION i NEXT_PUBLIC_SERVER_URL
-kreiramo example.env fajl u koji dodajemo primjer env varijabli koje je potrebno kreirati
-u komponentu app/layout.tsx importujemo varijable APP_NAME, APP_DESCRIPTION i SERVER_URL iz utils.ts fajla
-u eslint.config.mjs fajl dodajemo objekt rules
-uobjekt rules dodajemo opciju: @typescript-eslint/no-empty-interface": "off"

11. Header & Footer Components
-u eslint.config.mjs fajl dodajemo opciju: @typescript-eslint/no-unused-vars": "warn"
-u folderu components kreiramo foldere shared i header
-u folderu header kreiramo komponentu index.tsx
-u komponentu (root)/layout.tsx importujemo komponentu Header iz komponente header/index.tsx
-u komponenti header/index.tsx kreiramo i eksportujemo funkciju Header() kao default
-otvorimo link: https://www.npmjs.com/package/lucide-react
-u terminalu instaliramo paket Lucide React sa komandom npm i lucide-react
-u komponentu header/index.tsx importujemo React ikonice ShoppingCart i UserIcon iz paketa Lucide React
-importujemo komponentu Image iz paketa next/image
-otvorimo link: https://nextjs.org/docs/pages/api-reference/components/image
-importujemo komponentu Link iz paketa next/link
-otvorimo link: https://nextjs.org/docs/pages/api-reference/components/link
-importujemo komponentu Button iz komponente ui/button.tsx
-otvorimo link: 
-importujemo varijablu APP_NAME iz lib/constants.ts fajla
-u funkciji Header(), u jsx-u kreiramo header element kao roditelj element
-elementu header dodajemo Tailwind CSS klase w-full i border-b
-u header elementu kreiramo div element sa Tailwind CSS klasama wrapper i flex-between
-u div elementu sa klasama wrapper i flex-between kreiramo dva div elementa
-u prvi div element dodajemo komponentu Link
-komponenti Link dodajemo prop href i className
-u komponentu Link dodajemo komponentu Image i kreiramo span element
-komponenti Image dodajemo prop priority, src, width, height i alt
-span elementu dodajemo Tailwind CSS klase
-u drugi div element dodajemo dvije komponente Button
-komponentama Button dodajemo prop asChild i variant
-u komponente Button dodajemo komponente Link sa prop href
-u komponentama Link kreiramo po dva span elementa
-u prvi span element dodajemo React ikonicu, dok u drugi span element dodajemo opis
-u folderu components kreiramo komponentu footer.tsx
-u komponenti footer.tsx kreiramo i eksportujemo funkciju Footer() kao default
-u komponentu (root)/layout.tsx importujemo komponentu Footer iz komponente footer.tsx
-u komponentu footer.tsx importujemo varijablu APP_NAME iz lib/constants.ts fajla
-u funkciji Footer() kreiramo varijablu const currentYear
-u jsx-u kreiramo footer element kao roditelj element
-u footer elementu kreiramo div element sa Tailwind CSS klasama p-5 i flex-center
-u div elementu kreiramo tri span elementa
-u span elementima dinamicki prikazujemo vrijednost varijabli currentYear i APP_NAME

12. Theme Mode Toggle
-otvorimo link: https://ui.shadcn.com/docs/dark-mode/next
-otvorimo link: https://ui.shadcn.com/themes
-otvorimo link: https://www.npmjs.com/package/next-themes
-u globals.css fajl dodajemo kod iz dokumentacije za Shadcn teme
-u globals.css fajl dodajemo direktivu @layer base 
-u direktivu @layer base dodajemo objekte :root i .dark
-u terminalu ukucamo komandu: npm i next-themes
-otvorimo link: https://ui.shadcn.com/docs/components/dropdown-menu
-u terminalu ukucamo komandu: npx shadcn@latest add dropdown-menu
-u komponentu app/layout.tsx importujemo komponentu ThemeProvider iz paketa next-themes
-u jsx-u dodajemo komponentu ThemeProvider sa otvorenim i zatvorenim tagom
-komponenti ThemeProvider dodajemo prop attribute, defaultTheme, enableSystem i disableTransitionOnChange
-u komponentu ThemeProvider dodajemo prop {children}
-html roditelj elementu dodajemo atribut suppressHydrationWarning>
-u folderu components/header kreiramo komponentu mode-toggle.tsx
-u komponenti mode-toggle.tsx kreiramo i eksportujemo funkciju ModeToggle() kao default
-u komponentu header/index.tsx importujemo komponentu ModeToggle iz komponente mode-toggle.tsx
-otvorimo link: https://nextjs.org/docs/app/building-your-application/rendering/client-components
-u komponentu mode-toggle.tsx dodajemo direktivu 'use client'
-importujemo funkciju useTheme iz paketa next-themes
-u funkciji ModeToggle() pozivamo funkciju useTheme()
-vrijednost funkcije useTheme() pohranjujemo u destruktuirane varijable const { theme, setTheme }
-importujemo sest komponenti: 
DropdownMenu, DropdownMenuTrigger, DropdownMenuLabel, DropdownMenuSeparator, DropdownMenuContent i DropdownMenuCheckboxItem iz komponente ui/dropdown-menu.tsx
-importujemo komponentu Button iz komponente ui/button.tsx
-importujemo React ikonice SunIcon, Moon i SunMoon iz paketa lucide-react
-u jsx-u dodajemo komponentu DropdownMenu kao roditelj komponentu
-u komponentu DropdownMenu dodajemo komponentu DropdownMenuTrigger sa prop asChild
-u komponentu DropdownMenuTrigger dodajemo komponentu Button sa prop variant
-u komponentu Button dodajemo uslov ternarni operator theme === 'system'
-importujemo funkcije useState i useEffect iz paketa react
-u funkciji ModeToggle() pozivamo funkciju useState(false)
-vrijednost funkcije useState(false) pohranjujemo u varijable const [mounted, setMounted]
-pozivamo funkciju useEffect()
-u funkciji useEffect() pozivamo funkciju setMounted(true)
-dodajemo uslov if (!mounted) return null
-u komponentu DropdownMenu dodajemo komponentu DropdownMenuContent sa otvorenim i zatvorenim tagom
-u komponentu DropdownMenuContent dodajemo komponentu DropdownMenuLabel sa otvorenim i zatvorenim tagom
-dodajemo komponentu DropdownMenuSeparator sa samozatvarajucim tagom
-dodajemo tri komponente DropdownMenuCheckboxItem sa otvorenim i zatvorenim tagom
-komponentama DropdownMenuCheckboxItem dodajemo prop checked i dogadaj onClick
-u prop checked proslijedujemo dinamicku vrijednost varijable theme
-u dogadaj onClick proslijedujemo funkcije () => setTheme()

13. Loading & Not Found Pages
-otvorimo link: https://nextjs.org/docs/app/building-your-application/routing/loading-ui-and-streaming
-u folderu app kreiramo komponentu loading.tsx
-u komponenti app/loading.tsx kreiramo i eksportujemo funkciju LoadingPage() kao default
-importujemo komponentu Image iz paketa next/image
-importujemo sliku loader iz foldera assets
-u jsx-u roditelj div elementu dodajemo Tailwind CSS Flex klase
-u div element dodajemo komponentu Image sa prop src, alt, width i height
-u komponenti (root)/page.tsx kreiramo funkciju delay()
-otvorimo link: https://nextjs.org/docs/pages/building-your-application/routing/custom-error
-u folderu app kreiramo komponentu not-found.tsx
-u komponenti not-found.tsx kreiramo i eksportujemo funkciju NotFoundPage() kao default
-dodajemo direktivu 'use client'
-importujemo komponentu Image iz paketa next/image
-importujemo varijablu APP_NAME iz lib/constants.ts fajla
-importujemo komponentu Button iz komponente ui/button.tsx
-u jsx-u dodajemo roditelj div elementu Tailwind CSS Flex klase
-u div element dodajemo komponentu Image sa prop src, width, width, height i priority
-kreiramo HTML elemente h2 i p sa Tailwind CSS klasama
-importujemo komponentu Link iz paketa next/link
-u div element dodajemo komponentu Link sa prop href i className

14. Responsive Sheet Menu
-otvorimo link: https://ui.shadcn.com/docs/components/sheet
-u terminalu ukucamo komandu: npx shadcn@latest add sheet
-u folderu header kreiramo komponentu menu.tsx
-u komponenti menu.tsx kreiramo i eksportujemo funkciju Menu() kao default
-u jsx-u roditelj div elementu dodajemo Tailwind CSS klase
-u div elementu kreiramo nav element sa Tailwind CSS klasama
-iz komponente header/index.tsx prebacujemo komponente ModeToggle.tsx i Button u komponentu menu.tsx
-u komponentu header/index.tsx importujemo komponentu Menu iz komponente menu.tsx
-u komponentu menu.tsx importujemo React ikonicu EllipsisVertical iz paketa lucide/react
-importujemo komponente Sheet, SheetContent, SheetTitle i SheetTrigger iz komponente ui/sheet.tsx
-kreiramo jos jedan nav element sa Tailwind CSS klasom md:hidden
-u element nav dodajemo komponentu Sheet sa otvorenim i zatvorenim tagom
-u komponentu Sheet dodajemo komponentu SheetTrigger sa otvorenim i zatvorenim tagom
-u komponentu SheetTrigger dodajemo komponentu React ikonicu EllipsisVertical
-u komponentu Sheet dodajemo komponentu SheetContent sa otvorenim i zatvorenim tagom
-komponenti SheetContent dodajemo Tailwind CSS Flex klase
-u komponentu SheetContent dodajemo komponentu SheetTitle sa otvorenim i zatvorenim tagom
-u komponentu SheetContent dodajemo komponentu ModeToggle
-u komponentu SheetContent dodajemo komponentu Button sa prop asChild i variant
-u komponentu Button dodajemo komponentu Link sa prop href
-u komponentu Link dodajemo React ikonicu ShoppingCart
-u komponentu SheetContent dodajemo komponentu SheetDescription sa otvorenim i zatvorenim tagom
-u komponentu SheetContent dodajemo jos jednu komponentu Button sa prop asChild

15. Sample Products & Product List
-u eslint.config.mjs fajl dodajemo, u objekt rules dodajemo opciju: "@typescript-eslint/no-explicit-any": "off"
-kreiramo folder db i sample-data.ts fajl
-u sample-data.ts fajlu kreiramo i eskportujemo niz sampleData kao default
-u komponentu (root)/page.tsx importujemo niz sampleData
-u folderu components/shared kreiramo folder product i komponentu product-list.tsx
-u komponenti product/product-list.tsx kreiramo i eksportujemo funkciju ProductList() kao default
-u komponentu (root)/page.tsx importujemo komponentu ProductList.tsx iz komponenta product-list.tsx
-u jsx-u dodajemo prazan fragment kao roditelj element
-u element prazan fragment dodajemo komponentu ProductList sa prop data, title i limit
-u komponenti product-list.tsx, funkciji ProductList() dodajemo parametre destruktuirane prop sa tipovima
-u jsx-u div roditelj elementu dodajemo Tailwind CSS klasu my-10
-u div elementu kreiramo h2 element sa Tailwind CSS klasama
-u div elementu dodajemo uslov ternarni operator data?.length > 0
-kreiramo varijablu const limitedData
-u prvi dio ternarnog uslova dodajemo metodu limitedData?.map()
-u drugi dio ternarnog uslova dodajemo elemente div i p sa porukom da proizvodi nisu pronadeni

16. Product Card Component
-otvorimo link: https://ui.shadcn.com/docs/components/card
-u terminalu ukucamo komandu: npx shadcn@latest add card
-u folderu components/product kreiramo komponentu product-card.tsx
-u komponenti product-card.tsx kreiramo i eksportujemo funkciju ProductCard() kao default
-u komponentu product-card.tsx importujemo komponente Link i Image iz paketa next
-importujemo komponente Card, CardHeader i CardContent iz komponente ui/card.tsx
-funkciji ProductCard() dodajemo parametar destruktuirani prop product sa tipom
-u jsx-u dodajemo komponentu Card kao roditelj element sa Tailwind CSS klasama
-u komponentu Card dodajemo komponentu CardHeader sa otvorenim i zatvorenim tagom
-komponenti CardHeader dodajemo Tailwind CSS klase
-u komponentu CardHeader dodajemo komponente Link i Image
-u komponentu Card dodajemo komponentu CardContent sa otvorenim i zatvorenim tagom
-komponenti CardContent dodajemo Tailwind CSS klase
-u komponenti CardContent kreiramo div element
-dodajemo komponentu Link sa prop href 
-u prop href dodajemo dinamicki link
-u komponenti Link kreiramo h2 element sa Tailwind CSS klasama
-u komponentu product-list.tsx importujemo komponentu ProductCard iz komponente product-card.tsx
-u funkciju map() dodajemo komponentu ProductCard umjesto div elementa
-u komponenti CardContent kreiramo div element sa Tailwind CSS klasama
-u div elementu kreiramo p element
-u p elementu kreiramo dva span elementa
-dodajemo uslvo ternarni operator product?.stock > 0
-u prvi dio ternarnog operatora dodajemo p element u kojem dinamicki prikazujemo cijenu artikla
-u drugi dio ternarnog operatora dodajemo p element sa klasom text-destructive u kojem prikazujemo poruku kako artikl nije dostupan

17. Product Price Component
-u folderu components/product kreiramo komponentu product-price.tsx
-u komponenti product-price.tsx kreiramo i eksportujemo funkciju ProductPrice() kao default
-funkciji ProductPrice() dodajemo parametre destruktuirane prop value i className sa tipovima
-u funkciji ProductPrice() kreiramo varijablu const stringValue
-dodajemo metodu stringValue.split('.')
-vrijednost metode stringValue.split('.') pohranjujemo u varijable const [intValue, floatValue]
-importujemo funkciju cn iz lib/utils.ts fajla
-u jsx-u kreiramo p element kao roditelj element
-p elementu dodajemo prop className
-u prop className proslijedujemo funkciju cn()
-u p elementu kreiramo tri span elementa
-u komponentu product-card.tsx importujemo komponentu ProductPrice iz komponente product-price.tsx
-u prvi dio ternarnog uslova dodajemo komponentu ProductPrice umjesto p elementa
-komponenti ProductPrice dodajemo prop value
-u prop value proslijedujemo funkciju Number(product.price)


Section 03: Database, Prisma & Product Display

18. Section Intro

19. PostgreSQL & Prisma Setup
-otvorimo web stranicu: https://vercel.com/
-na web stranici Vercel odaberemo opciju Storage i kreiramo bazu podataka
-otvorimo web stranicu: https://www.prisma.io/
-u terminalu ukucamo komandu: npm install -D prisma @prisma/client
-ukucamo komandu npx prisma init
-nakon komande npx prisma init generise se folder prisma i schema.prisma fajl
-u .env fajlu se generise env varijabla DATABASE_URL
-varijabli DATABASE_URL dodajemo link za konekciju baze podataka (connection string) sa web stranice Vercel
-instaliramo VS Code ekstenziju za Prismu
-u example.env dodajemo primjer za varijablu DATABASE_URL koju je potrebno kreirati 

20. Prisma Models & Migrations
-otvorimo link: https://www.prisma.io/docs/orm/prisma-schema/data-model/models
-u schema.prisma fajlu kreiramo model Product
-u package.json fajl, u objekt scripts dodajemo komandu "postinstall": "prisma generate"
-u terminalu ukucamo komandu: npx prisma generate
-ukucamo komandu: npx prisma migrate dev --name init
-nakon ove komande u folderu prisma se generise folder migrations
-ukucamo komandu: npx prisma studio

21. Seed Sample Data
-otvorimo link: https://www.npmjs.com/package/tsx
-u terminalu instaliramo paket tsx sa komandom npm i tsx
-otvorimo link: https://www.npmjs.com/package/colors
-u terminalu instaliramo paket colors sa komandom npm i colors
-otvorimo link: https://www.prisma.io/docs/orm/reference/prisma-client-reference
-u folderu db kreiramo seed.ts fajl
-u seed.ts fajl importujemo funkciju PrismaClient iz paketa prisma/client
-importujemo nit sampleData iz sample-data.ts fajla
-kreiramo asinhronu funkciju main()
-u funkciji main() pozivamo funkciju new PrismaClient()
-vrijednost funkcije new PrismaClient() pohranjujemo u varijablu const prisma
-pozivamo funkciju await prisma.product.deleteMany()
-pozivamo funkciju await prisma.product.createMany()
-u terminalu ukucamo komandu: npx tsx ./db/seed

22. Load Products From Database
-otvorimo link: https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations
-otvorimo link: https://stackoverflow.com/questions/77091418/warning-only-plain-objects-can-be-passed-to-client-components-from-server-compo
-u folderu lib kreiramo fodler actions
-u folderu actions kreiramo product.actions.ts fajl
-u product.actions.ts fajl dodajemo direktivu 'use server'
-kreiramo i eksportujemo asinhronu funkciju getLatestProducts()
-importujemo funkciju PrismaClient iz paketa prisma/client
-u funkciji getLatestProducts() kreiramo varijablu const prisma
-pozivamo funkciju await prisma.product.findMany()
-vrijednost funkcije await prisma.product.findMany() pohranjujemo u varijablu const data
-dodajemo izjavu return data
-u utils.ts fajlu kreiramo i eskportujemo funkciju convertToPlainObject()
-u product.actions.ts fajl importujemo funkciju convertToPlainObject
-u izjavu return dodajemo funkciju convertToPlainObject(data)
-u komponentu (root)/page.tsx importujemo funkciju getLatestProducts iz product.actions.ts fajla
-u funkciji Homepage() pozivamo funkciju await getLatestProducts()
-vrijednost funkcije await getLatestProducts() pohranjujemo u varijablu const latestProducts
-u prop data proslijedujemo vrijednost varijable latestProducts
-u constants/index.ts fajlu kreiramo i eksportujemo varijablu const LATEST_PRODUCTS_LIMIT
-u .env fajl dodajemo varijablu LATEST_PRODUCTS_LIMIT
-u example.env fajl dodajemo primjer varijable LATEST_PRODUCTS_LIMIT koju je potrebno kreirati
-u product.actions.ts fajl importujemo varijablu LATEST_PRODUCTS_LIMIT iz constants/index.ts fajla

23. Zod Validation & Type Inference
-otvorimo web stranicu: https://zod.dev/
-u terminalu ukucamo komandu: npm i zod
-u folderu lib kreiramo validators.ts fajl
-u validators.ts fajl importujemo instancu z iz paketa zod
-pozivamo funkciju z.object()
-vrijednost funkcije z.object() pohranjujemo u varijablu insertProductSchema
-eksportujemo varijable insertProductSchema
-kreiramo folder types
-u folderu types kreiramo index.ts fajl
-u types/index.ts fajl importujemo instancu z iz paketa zod
-importujemo varijablu insertProductSchema iz lib/validators.ts fajla
-kreiramo i eksportujemo tip Product
-tipu Product dodajemo genericki tip z.infer<typeof insertProductSchema> & { ... }
-u objekt dodajemo opcije id, rating i createdAt
-u lib/utils.ts fajlu kreiramo i eksportujemo funkciju formatNumberWithDecimal()
-u lib/validators.ts fajl importujemo funkciju formatNumberWithDecimal
-kreiramo varijablu const currency
-u objekt z.object({}) dodajemo key - value par price: currency
-u komponentu product-card.tsx importujemo tip Product iz foldera types
-u funkciji ProductCard() destruktuiranom parametru product dodajemo tip Product
-u komponentu product-list.tsx importujemo tip Product iz foldera types
-u funkciji ProductList() destruktuiranom parametru data dodajemo tip Product
-u jsx-u, u funkciji map() parametru product dodajemo tip Product

24. Serverless Environment Config
-otvorimo link: https://www.npmjs.com/package/@neondatabase/serverless
-u terminalu ukucamo komandu: npm i @neondatabase/serverless
-otvorimo link: https://www.npmjs.com/package/@prisma/adapter-neon
-ukucamo komandu: npm i @prisma/adapter-neon
-otvorimo link: https://www.npmjs.com/package/ws
-ukucamo komandu: npm i ws
-otvorimo link: https://www.npmjs.com/package/@types/ws
-ukucamo komandu: npm i -D @types/ws
-otvorimo link: https://www.npmjs.com/package/bufferutil
-ukucamo komandu: npm i -D bufferutil
-u schema.prisma fajlu u objekt generator client dodajemo opciju previewFeatures
-ukucamo komandu npx prisma generate
-otvorimo link: https://neon.tech/docs/serverless/serverless-driver
-otvorimo link: https://www.prisma.io/docs/orm/overview/databases/neon
-u folderu prisma kreiramo prisma.ts fajl
-u prisma.ts fajl kopiramo kod iz dokumentacije
-u product.actions.ts fajl importujemo instancu prisma iz db/prisma.ts fajla
-izbrisemo varijablu const prisma
-izbrisemo folder .next
-u terminalu ukucamo komandu: npm run dev

25. Product Details Page
-u product.actions.ts fajlu kreiramo i eksportujemo asinhronu funkciju getProductBySlug() sa parametrom slug
-parametru slug dodajemo tip string
-u izjavu return dodajemo metodu return await prisma.product.findFirst()
-u funkciju findFirst() dodajemo konfiguracioni objekt
-u konfiguracioni objekt dodajemo objekt where
-u folderu (root) kreiramo foldere product i [slug]
-u folderu product/[slug] kreiramo komponentu page.tsx
-u komponenti [slug]/page.tsx kreiramo i eksportujemo funkciju ProductDetailsPage() kao default
-otvorimo rutu: http://localhost:3000/product/[slug]
-funkciji ProductDetailsPage() dodajemo parametar props sa tipom Promise
-funkciji ProductDetailsPage() dodajemo asinhronost
-u funkciji ProductDetailsPage() dodajemo metodu await props.params
-vrijednost metode await props.params pohranjujemo u destruktuiranu varijablu const { slug }
-importujemo funkciju notFound iz paketa next/navigation
-importujemo funkciju getProductBySlug iz product.actions.ts fajla
-dodajemo metodu getProductBySlug(slug)
-vrijednost metode getProductBySlug(slug) pohranjujemo u varijablu const product
-dodajemo uslov if (!product) notFound()
-otvorimo link: https://ui.shadcn.com/docs/components/badge
-u terminalu ukucamo komandu: npx shadcn@latest add badge
-importujemo komponentu Badge iz komponente ui/components/badge.tsx
-importujemo komponente Card i CardContent iz komponente ui/components/card.tsx
-importujemo komponentu Button iz komponente ui/components/button.tsx
-importujemo komponentu ProductPrice iz komponente product/product-price.tsx
-u jsx-u dodajemo section element kao roditelj element
-u section elementu kreiramo div element sa Tailwind CSS Grid klasama
-u div elementu sa Tailwind CSS Grid klasama kreiramo dva div elementa za sliku i detalje sa Tailwind CSS klasom col-span-2
-u div elementu za detalje kreiramo div element sa Tailwind CSS Flex klasama
-u div elementu kreiramo p dva span elementa u kojima dinamicki prikazujemo marku artikla i kategoriju
-kreiramo h2 element u kojem dinamicki prikazujemo ime artikla
-kreiramo p element i unutar njega cetiri span elementa u kojima dinamicki prikazujemo ocjenu i recenzije artikla
-kreiramo div element sa Tailwind CSS Flex klasama u koji dodajemo komponentu ProductPrice
-komponenti ProductPrice dodajemo prop value i className
-kreiramo div element sa klasom mt-10 u kojem dinamicki prikazujemo opis artikla
-kreiramo div element u koji dodajemo komponentu Card sa otvorenim i zatvorenim tagom
-u komponentu Card dodajemo komponentu CardContent
-u komponenti CardContent kreiramo div element u koji dodajemo komponentu ProductPrice
-kreiramo div element u koji dodajemo komponentu Badge
-dodajemo uslov ternarni operator product?.stock > 0 
-dodajemo uslov za kondicionalno renderovanje komponenta Button product?.stock > 0 &&

26. Product Images Component
-u folderu shared/product kreiramo komponentu product-images.tsx
-u komponenti product-images.tsx kreiramo i eksportujemo funkciju ProductImages() kao default
-funkciji ProductImages() dodajemo parametar destruktuirani prop images sa tipom string[]
-u komponentu [slug]/page.tsx importujemo komponentu ProductImages iz komponente product-images.tsx
-u jsx-u, u div element za sliku dodajemo komponentu ProductImages sa prop images
-u komponentu product-images.tsx dodajemo direktivu 'use client'
-importujemo funkciju useState iz paketa react
-importujemo komponentu Image iz paketa next/image
-importujemo funkciju cn iz lib/utils.ts fajla
-u funkciji ProductImages() kreiramo state varijablu const current i set funkciju setCurrent
-u roditelj div element dodajemo komponentu Image
-komponenti Image dodajemo prop src, alt, width, height i className
-kreiramo div element sa Tailwind klasom flex
-u div element dodajemo metodu images?.map()
-u funkciji map() kreiramo div element
-div elementu dodajemo prop key, className i dogadaj onClick
-u div element dodajemo komponentu Image
-komponenti Image dodajemo prop src, alt, width, height
-u dogadaj onClick proslijedujemo funkciju () => setCurrent(index)
-u prop className proslijedujemo dinamicku klasu cn()

27. Initial Deployment
-u terminalu ukucamo komandu: npm run build
-otvorimo Web stranicu: https://github.com i postavimo kod
-na Web stranici https://vercel.com kreiramo novi projekt
-u kreirani projekt dodajemo env varijable iz .env fajla
-u opciji Install Command dodajemo komandu: npm install --legacy-peer-deps
-promjenimo ime varijable NEXT_PUBLIC_SERVER_URL nakon sto dobijemo Vercel link projekta

28. A Note On ES Lint Errors


Section 04: Authentication With Next Auth

29. Section Intro

30. Prisma User-Related Models
-otvorimo web stranicu: https://authjs.dev/
-otvorimo link: https://authjs.dev/getting-started/adapters/prisma
-u schema.prisma fajlu kreiramo modele User, Account, Session i VerificationToken
-u terminalu ukucamo komandu: npx prisma generate
-ukucamo komandu: npx prisma migrate dev --name add_user_based_tables
-u folderu prisma generisan novi folder za migracije
-ukucamo komandu: npx prisma studio

31. Seed User Data
-u sample-data.ts fajlu kreiramo niz users
-otvorimo link: https://www.npmjs.com/package/bcrypt-ts
-otvorimo link: https://npm.runkit.com/bcrypt-ts-edge
-u terminalu ukucamo komandu: npm install bcrypt-ts-edge
-importujemo funkciju hashSync iz paketa bcrypt-ts-edge
-u nizu users kreiramo dva objekta sa podacima o korisniku
-u objekte dodajemo polja name, email, password i role
-u seed.ts fajl, u funkciju main() dodajemo vise metoda deleteMany()
-dodajemo metodu await prisma.user.createMany() za korisnike
-u terminalu ukucamo komandu: npx tsx ./db/seed
-ukucamo komandu: npx prisma studio

32. Next Auth Setup
-otvorimo link: https://authjs.dev/getting-started
-u terminalu ukucamo komandu: npm install next-auth@5.0.0-beta.25 --legacy-peer-deps
-otvorimo link: https://www.npmjs.com/package/@auth/prisma-adapter
-ukucamo komandu: npm install @auth/prisma-adapter
-ukucamo komandu: openssl rand -base64 32
-u .env fajlu dodajemo env varijable NEXT_AUTH_SECRET, NEXTAUTH_URL i NEXTAUTH_URL_INTERNAL
-u example.env fajl dodajemo primjer varijabli koje je potrebno kreirati
-otvorimo link: https://next-auth.js.org/configuration/options
-kreiramo auth.ts fajl i importujemo funkciju NextAuth iz paketa next-auth
-kreiramo i eskportujemo objekt config
-pozivamo funkciju NextAuth(config)
-vrijednost funkcije NextAuth(config) pohranjujemo u destruktuirane varijable const { handlers, auth, signIn, signOut } 
-eksportujemo destruktuirane varijable
-u objekt config dodajemo objekte pages i session
-importujemo funkciju PrismaAdapter iz paketa auth/prisma-adapter
-importujemo instancu prisma iz db/prisma.ts fajla
-u objekt config dodajemo key-value par adapter i funkciju PrismaAdapter(prisma)
-dodajemo niz providers
-importujemo funkciju CredentialsProvider iz paketa next-auth/providers/credentials
-importujemo funkciju compareSync iz paketa bcrypt-ts-edge
-u nizu providers pozivamo funkciju CredentialsProvider() sa argumentom konfiguracionim objektom
-u konfiguracioni objekt dodajemo objekt credentials
-dodajemo metodu async authorize(credentials)
-u funkciju authorize(credentials) dodajemo uslov if (credentials === null) return null
-kreiramo varijablu const user
-dodajemo uslov if (user && user.password)
-u uslovu if kreiramo varijablu const isMatch
-dodajemo uslov if (isMatch)
-dodajemo izjavu return null ako korisnik ne postoji ili ako se unesena sifra ne slaze sa sifrom u bazi podataka
-importujemo tip NextAuthConfig iz paketa next-auth
-dodajemo objekt callbacks
-u objekt callbacks dodajemo asinhronu funkciju session()
-funkciji session dodajemo parametre { session, user, trigger, token }
-u funkciju session() dodajemo metodu session.user.id = token.sub
-dodajemo uslov if (trigger === 'update') 
-nakon uslova if dodajemo izjavu return session
-objektu config dodajemo tip satisfies NextAuthConfig

33. Next Auth Catch All API Route
-otvorimo link: https://next-auth.js.org/getting-started/example#add-api-route
-u folderu app kreiramo foldere api, auth i [...nextauth]
-u folderu [...nextauth] kreiramo route.ts fajl
-u route.ts fajl dodajemo console.log('Hello World');
-u pretrazivacu otvorimo rutu: http://localhost:3000/api/auth/session
-u route.ts fajl importujemo varijablu handlers iz auth.ts fajla
-eksportujemo funkcije GET i POST
-u pretrazivacu otvorimo rute: /api/auth/signin, /api/auth/signout i /api/auth/session

34. Sign In & Sign Out Action
-u validators.ts fajlu kreiramo i eksportujemo varijablu signInFormSchema
-u folderu lib/actions kreiramo user.actions.ts fajl
-u user.actions.ts fajl dodajemo direktivu 'use server'
-importujemo funkciju signInFormSchema iz validators.ts fajla
-importujemo funkcije signIn i signOut iz auth.ts fajla
-importujemo funkciju isRedirectError iz paketa next
-kreiramo i eksportujemo asinhronu funkciju signInWithCredentials()
-funkciji signInWithCredentials() dodajemo parametre prevState i formData sa tipovima
-dodajemo blokove koda try - catch
-u bloku koda try dodajemo metodu signInFormSchema.parse()
-vrijednost metode signInFormSchema() pohranjujemo u varijablu const user
-pozivamo funkciju await signIn('credentials, user)
-dodajemo izjavu return objekt sa key - value vrijednostima success i message
-u objekt dodajemo vrijednost success: true i poruku da je prijava uspjesna
-u blok koda catch(error) dodajemo uslov if (isRedirectError(error))
-u uslov if dodajemo throw error
-dodajemo izjavu return objekt sa key - value vrijednostima success i message
-u objekt dodajemo vrijednost success: false i poruku da je email ili sifra pogresna
-kreiramo i eksportujemo asinhronu funkciju signOutUser()
-u funkciji signOutUser() pozivamo funkciju await signOut()

35. Auth Layout & Sign In Page
-u folderu app kreiramo folder (auth)
-u folderu (auth) kreiramo komponentu layout.tsx
-u komponenti (auth)/layout.tsx kreiramo i eksportujemo funkciju AuthLayout() kao default
-u funkciji AuthLayout() kreiramo roditelj div element sa Tailwind CSS klasama
-u div element dinamicki prikazujemo vrijednost prop children
-u folderu (auth) kreiramo folder sign-in i komponentu page.tsx
-u komponenti sing-in/page.tsx kreiramo i eksportujemo funkciju SignInPage() kao default
-importujemo tip Metadata iz paketa next
-kreiramo i eksportujemo varijablu const metadata sa tipom Metadata
-u jsx-u roditelj div elementu dodajemo Tailwind CSS klase
-importujemo komponente Card, CardContent, CardDescription, CardHeader i CardTitle iz komponente ui/card.tsx
-u div element dodajemo komponentu Card sa otvorenim i zatvorenim tagom
-u komponentu Card dodajemo komponentu CardHeader sa otvorenim i zatvorenim tagom
-importujemo komponente Link i Image iz paketa next
-importujemo varijablu APP_NAME iz lib/constants.ts fajla
-u komponentu CardHeader dodajemo komponentu Link sa prop href i className
-u komponentu Link dodajemo komponentu Image sa prop src, alt, width, height i priority
-dodajemo komponentu CardTitle sa otvorenim i zatvorenim tagom
-dodajemo komponentu CardDescription sa otvorenim i zatvorenim tagom
-u komponentu Card dodajemo komponentu CardContent sa otvorenim i zatvorenim tagom

36. Credentials Sign In Form
-u folderu sign-in kreiramo komponentu credentials-signin-form.tsx
-u komponenti credentials-signin-form.tsx kreiramo i eksportujemo funkciju CredentialsSignInForm() kao default
-u komponentu sign-in/page.tsx importujemo komponentu CredentialsSignInForm iz komponente credentials-signin-form.tsx
-u jsx-u, u komponentu CardContent dodajemo komponentu CredentialsSignInForm
-u komponentu credentials-signin-form.tsx dodajemo direktivu 'use client'
-otvorimo link: https://ui.shadcn.com/docs/components/label
-otvorimo link: https://ui.shadcn.com/docs/components/input
-u terminalu ukucamo komandu: npx shadcn@latest add input label
-u funkciji CredentialsSignInForm(), u jsx-u kreiramo form element kao roditelj element
-u form elementu kreiramo div element za email polja sa Tailwind CSS klasom space-y-6
-importujemo komponente Label i Input iz foldera components/ui
-u div element dodajemo komponente Label i Input
-komponenti Label dodajemo prop htmlFor
-komponenti Input dodajemo prop id, name, type, required i autoComplete
-u constants/index.ts fajlu kreiramo i eksportujemo varijablu objekt const signInDefaultValues
-u komponentu credentials-signin-form.tsx importujemo varijablu signInDefaultValues
-u jsx-u komponenti Input dodajemo prop defaultValue
-u prop defaultValue proslijedujemo vrijednost varijable signInDefaultValues.email
-kreiramo jos jedan div element za sifru 
-u div element dodajemo komponente Label i Input
-komponenti Input dodajemo prop defaultValue
-u prop defaultValue proslijedujemo vrijednost varijable signInDefaultValues.password
-importujemo komponentu Button iz komponente ui/button.tsx
-kreiramo div element za komponentu Button
-komponenti Button dodajemo prop className i variant
-kreiramo div element za span element i komponentu Link
-komponenti Link dodajemo prop href, target i className

37. Hook Up Sign In Form
-otvorimo link: https://react.dev/reference/react/useActionState
-otvorimo link: https://react.dev/reference/react-dom/hooks/useFormStatus
-u komponentu credentials-signin-form.tsx importujemo funkciju useAction state iz paketa react
-importujemo funkciju useFormStatus iz paketa react-dom
-importujemo funkciju signInWithCredentials iz actions/user.actions.ts fajla
-u funkciji CredentialsSignInForm() pozivamo funkciju useActionState() sa dva argumenta
-u funkciji useActionState() prvi argument je funkcija signInWithCredentials, dok je drugi argument ojekt
-vrijednost funkcije pohranjujemo u varijablu const data i funkciju action
-u jsx-u form elementu dodajemo prop action
-u prop action proslijedujemo vrijednost funkcije action
-dodajemo uslov za kondicionalno renderovanje data && !data.success && ()
-kreiramo funkciju SignInButton()
-u funkciji SignInButton() pozivamo funkciju useFormStatus()
-vrijednost funkcije useFormStatus() pohranjujemo u destruktuiranu varijablu const { pending }
-dodajemo izjavu return
-u izjavi return dodajemo komponentu Button sa prop disabled, className i variant
-u komponentu Button dodajemo uslov ternarni operator za varijablu pending
-u div element dodajemo komponentu SignInButton
-u komponentu app/(auth)/page.tsx importujemo funkciju auth iz auth.ts fajla
-importujemo funkciju redirect iz paketa next/redirect
-funkciji SignInPage() dodajemo asinhronost
-u funkciji SignInPage() pozivamo funkciju await auth()
-vrijednost funkcije await auth() pohranjujemo u varijablu const session
-dodajemo uslov if (session)
-u uslovu if (session) pozivamo funkciju return redirect('/')
-u pretrazivacu otvorimo rutu: http://localhost:3000/ i prijavimo se
-u pretrazivacu otvorimo opciju Devtools -> Application -> Cookies
-otvorimo link: http://localhost:3000/api/auth/session da vidimo podatke o prijavljenom korisniku
-u folderu sign-in kreiramo komponentu signin-button.tsx
-u komponenti signin-button.tsx kreiramo i eskportujemo funkciju SignInButton() kao default
-premjestamo logiku za komponentu SignInButton iz komponente credentials-signin-form.tsx
-u komponentu credentials-signin-form.tsx importujemo komponentu SignInButton iz komponente signin-button.tsx

38. Callback URL Redirect
-otvorimo link: https://nextjs.org/docs/app/api-reference/functions/use-search-params
-u komponenti sign-in/page.tsx, funkciji SignInPage() dodajemo parametar props sa generickim tipom Promise
-u funkciji SignInPage() dodajemo metodu await props.searchParams
-vrijednost metode await props.searchParams pohranjujemo u varijablu const { callbackUrl }
-u uslov if (session) dodajemo izjavu return redirect(callbackUrl || '/')
-u komponentu sign-in-credentials.tsx importujemo funkciju useSearchParams iz paketa next/navigation
-u funkciji CredentialsSignInForm() kreiramo varijable const searchParams i const callbackUrl
-u jsx-u, u form elementu kreiramo input element sa prop type, name i value
-u prop type dodajemo opciju da je element sakriven
-u prop name dodajemo ime callbackUrl
-u prop value proslijedujemo vrijednost varijable callbackUrl
-otvorimo pretrazivac i obrisemo kolacice u aplikaciji 
-otvorimo rutu: http://localhost:3000/sign-in?callbackUrl=http%3A%2F%2Flocalhost%3A3000%2Fshipping-address i prijavimo se
-nakon prijave treba se otvoriti ruta: http://localhost:3000/shipping-address

39. User Button & Sign Out
-u projekt na web stranici Vercel dodajemo tri env varijable: NEXTAUTH_SECRET, NEXTAUTH_URL i NEXTAUTH_URL_INTERNAL
-u folderu header kreiramo komponentu user-button.tsx
-u komponenti user-button.tsx kreiramo i eksportujemo funkciju UserButton() kao default
-u komponentu menu.tsx importujemo komponentu UserButton iz komponente user-button.tsx
-u jsx-u dodajemo dvije komponente UserButton sa samozatvarajucim tagom
-u komponentu user-button.tsx importujemo komponentu Link iz paketa next
-importujemo funkciju auth iz auth.ts fajla
-importujemo komponentu Button iz komponente ui/button.tsx
-importujemo komponente DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuLabel i DropdownMenuTrigger iz komponente ui/dropdown-menu.tsx
-importujemo React ikonicu UserIcon iz paketa lucide-react
-funkciji UserButton() dodajemo asinhronost
-u funkciji UserButton() pozivamo funkciju await auth()
-vrijednost funkcije await auth() pohranjujemo u varijablu const session
-dodajemo uslov if (!session)
-u uslov if (!session) dodajemo komponentu Button za prikazivenje teksta za prijavu ako korisnik nije prijavljen
-kreiramo varijablu const firstInitial
-importujemo funkciju signOutUser iz user.actions.ts fajla
-u jsx-u roditelj div elementu dodajemo Tailwind CSS flex klase
-u div element dodajemo komponentu DropdownMenu sa otvorenim i zatvorenim tagom
-u komponentu DropdownMenu dodajemo komponentu DropdownMenuTrigger sa otvorenim i zatvorenim tagom
-u komponenti DropdownMenuTrigger kreiramo div element sa Tailwind CSS flex klasama
-u div element dodajemo komponentu Button sa prop variant, className
-u komponenti Button dinamicki prikazujemo vrijednost varijable firstInitial
-u komponentu DropdownMenu dodajemo komponentu DropdownMenuContent sa otvorenim i zatvorenim tagom 
-komponenti DropdownMenuContent dodajemo prop className, align i forceMount
-u komponentu DropdownMenuContent dodajemo komponentu DropdownMenuLabel sa otvorenim i zatvorenim tagom
-u komponenti DropdownMenuLabel kreiramo div element sa Tailwind CSS klasama
-u div elementu kreiramo dva p elementa sa Tailwind CSS klasama u kojima dinamicki prikazujemo ime i email prijavljenog korisnika
-u komponentu DropdownMenuContent dodajemo komponentu DropdownMenuItem sa otvorenim i zatvorenim tagom
-u komponenti DropdownMenuContent kreiramo form element sa prop action
-u prop action proslijedujemo funkciju signOutUser
-u form element dodajemo komponentu Button sa tekstom Sign Out