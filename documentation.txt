Next.js E-commerce - Build a Shopping Platform From Scratch


Section 01: Introduction

01. Welcome To The Course

02. The Stack

03. The Project

04. The Environment

05. Premium Docs

06. Final Code & Demo


Section 02: App Creation & Basics Layout

07. Section Intro

08. Create Next App & Assets
-preuzemo folder resources
-otvorimo web stranicu: https://nextjs.org/
-u terminalu ukucamo komandu npx create-next-app@latest .
-ukucamo komandu npm run dev 
-u komponentu layout.tsx importujemo funkciju Inter iz paketa next/font/google
-kreiramo varijablu const inter
-u jsx-u, u prop className proslijedujemo dinamicku vrijednost varijable inter
-brisemo globals.css fajl
-kreiramo folder assets
-u folder assets dodajemo starter folder styles sa globals.css fajlom i loader.gif sliku
-u komponentu layout.tsx importujemo globals.css fajl
-u komponenti app/page.tsx kreiramo i eksportujemo funkciju Homepage() kao default
-u folder app dodajemo logo favicon.ico
-u folder public dodajemo folder images

09. ShadCN UI Setup
-otvorimo web stranicu: https://ui.shadcn.com/
-u terminalu ukucamo komandu: npx shadcn@latest init
-odaberemo opciju Use --legacy-peer-deps
-nakon instalacije paketa Shadcn generisan folder lib i utils.ts fajl
-nakon instalacije paketa Shadcn generisan components.json fajl
-ukucamo komandu: npx shadcn@latest add button
-nakon instalacije komponente button generisan folderi components, ui i komponenta button.tsx
-otvorimo link: https://ui.shadcn.com/docs/react-19
-otvorimo link: https://www.npmjs.com/package/clsx
-u terminalu ukucamo komandu: npx i clsx
-otvorimo link: https://www.npmjs.com/package/tailwind-merge
-u terminalu ukucamo komandu: npm i tailwind-merge
-otvorimo link: https://www.npmjs.com/package/tailwindcss-animate
-u terminalu ukucamo komandu: npx i tailwindcss-animate

10. Root Layout & Constants
-u folderu app kreiramo folder (root) i komponentu layout.tsx
-u komponenti (root)/layout.tsx kreiramo i eksportujemo funkciju RootLayout() kao default
-u jsx-u kreiramo HTML elemente sa Tailwind CSS klasama
-u main element dodajemo prop children
-komponentu app/page.tsx premjestamo u folder (root)
-u folderu lib kreiramo folder constants i index.ts fajl
-u constants/index.ts fajlu kreiramo i eksportujemo varijable const APP_NAME, APP_DESCRIPTION i const SERVER_URL
-kreiramo .env fajl
-u .env fajlu kreiramo tri env varijable NEXT_PUBLIC_APP_NAME, NEXT_PUBLIC_APP_DESCRIPTION i NEXT_PUBLIC_SERVER_URL
-kreiramo example.env fajl u koji dodajemo primjer env varijabli koje je potrebno kreirati
-u komponentu app/layout.tsx importujemo varijable APP_NAME, APP_DESCRIPTION i SERVER_URL iz utils.ts fajla
-u eslint.config.mjs fajl dodajemo objekt rules
-uobjekt rules dodajemo opciju: @typescript-eslint/no-empty-interface": "off"

11. Header & Footer Components
-u eslint.config.mjs fajl dodajemo opciju: @typescript-eslint/no-unused-vars": "warn"
-u folderu components kreiramo foldere shared i header
-u folderu header kreiramo komponentu index.tsx
-u komponentu (root)/layout.tsx importujemo komponentu Header iz komponente header/index.tsx
-u komponenti header/index.tsx kreiramo i eksportujemo funkciju Header() kao default
-otvorimo link: https://www.npmjs.com/package/lucide-react
-u terminalu instaliramo paket Lucide React sa komandom npm i lucide-react
-u komponentu header/index.tsx importujemo React ikonice ShoppingCart i UserIcon iz paketa Lucide React
-importujemo komponentu Image iz paketa next/image
-otvorimo link: https://nextjs.org/docs/pages/api-reference/components/image
-importujemo komponentu Link iz paketa next/link
-otvorimo link: https://nextjs.org/docs/pages/api-reference/components/link
-importujemo komponentu Button iz komponente ui/button.tsx
-otvorimo link: https://ui.shadcn.com/docs/components/button
-importujemo varijablu APP_NAME iz lib/constants.ts fajla
-u funkciji Header(), u jsx-u kreiramo header element kao roditelj element
-elementu header dodajemo Tailwind CSS klase w-full i border-b
-u header elementu kreiramo div element sa Tailwind CSS klasama wrapper i flex-between
-u div elementu sa klasama wrapper i flex-between kreiramo dva div elementa
-u prvi div element dodajemo komponentu Link
-komponenti Link dodajemo prop href i className
-u komponentu Link dodajemo komponentu Image i kreiramo span element
-komponenti Image dodajemo prop priority, src, width, height i alt
-span elementu dodajemo Tailwind CSS klase
-u drugi div element dodajemo dvije komponente Button
-komponentama Button dodajemo prop asChild i variant
-u komponente Button dodajemo komponente Link sa prop href
-u komponentama Link kreiramo po dva span elementa
-u prvi span element dodajemo React ikonicu, dok u drugi span element dodajemo opis
-u folderu components kreiramo komponentu footer.tsx
-u komponenti footer.tsx kreiramo i eksportujemo funkciju Footer() kao default
-u komponentu (root)/layout.tsx importujemo komponentu Footer iz komponente footer.tsx
-u komponentu footer.tsx importujemo varijablu APP_NAME iz lib/constants.ts fajla
-u funkciji Footer() kreiramo varijablu const currentYear
-u jsx-u kreiramo footer element kao roditelj element
-u footer elementu kreiramo div element sa Tailwind CSS klasama p-5 i flex-center
-u div elementu kreiramo tri span elementa
-u span elementima dinamicki prikazujemo vrijednost varijabli currentYear i APP_NAME

12. Theme Mode Toggle
-otvorimo link: https://ui.shadcn.com/docs/dark-mode/next
-otvorimo link: https://ui.shadcn.com/themes
-otvorimo link: https://www.npmjs.com/package/next-themes
-u globals.css fajl dodajemo kod iz dokumentacije za Shadcn teme
-u globals.css fajl dodajemo direktivu @layer base 
-u direktivu @layer base dodajemo objekte :root i .dark
-u terminalu ukucamo komandu: npm i next-themes
-otvorimo link: https://ui.shadcn.com/docs/components/dropdown-menu
-u terminalu ukucamo komandu: npx shadcn@latest add dropdown-menu
-u komponentu app/layout.tsx importujemo komponentu ThemeProvider iz paketa next-themes
-u jsx-u dodajemo komponentu ThemeProvider sa otvorenim i zatvorenim tagom
-komponenti ThemeProvider dodajemo prop attribute, defaultTheme, enableSystem i disableTransitionOnChange
-u komponentu ThemeProvider dodajemo prop {children}
-html roditelj elementu dodajemo atribut suppressHydrationWarning>
-u folderu components/header kreiramo komponentu mode-toggle.tsx
-u komponenti mode-toggle.tsx kreiramo i eksportujemo funkciju ModeToggle() kao default
-u komponentu header/index.tsx importujemo komponentu ModeToggle iz komponente mode-toggle.tsx
-otvorimo link: https://nextjs.org/docs/app/building-your-application/rendering/client-components
-u komponentu mode-toggle.tsx dodajemo direktivu 'use client'
-importujemo funkciju useTheme iz paketa next-themes
-u funkciji ModeToggle() pozivamo funkciju useTheme()
-vrijednost funkcije useTheme() pohranjujemo u destruktuirane varijable const { theme, setTheme }
-importujemo sest komponenti: 
DropdownMenu, DropdownMenuTrigger, DropdownMenuLabel, DropdownMenuSeparator, DropdownMenuContent i DropdownMenuCheckboxItem iz komponente ui/dropdown-menu.tsx
-importujemo komponentu Button iz komponente ui/button.tsx
-importujemo React ikonice SunIcon, Moon i SunMoon iz paketa lucide-react
-u jsx-u dodajemo komponentu DropdownMenu kao roditelj komponentu
-u komponentu DropdownMenu dodajemo komponentu DropdownMenuTrigger sa prop asChild
-u komponentu DropdownMenuTrigger dodajemo komponentu Button sa prop variant
-u komponentu Button dodajemo uslov ternarni operator theme === 'system'
-importujemo funkcije useState i useEffect iz paketa react
-u funkciji ModeToggle() pozivamo funkciju useState(false)
-vrijednost funkcije useState(false) pohranjujemo u varijable const [mounted, setMounted]
-pozivamo funkciju useEffect()
-u funkciji useEffect() pozivamo funkciju setMounted(true)
-dodajemo uslov if (!mounted) return null
-u komponentu DropdownMenu dodajemo komponentu DropdownMenuContent sa otvorenim i zatvorenim tagom
-u komponentu DropdownMenuContent dodajemo komponentu DropdownMenuLabel sa otvorenim i zatvorenim tagom
-dodajemo komponentu DropdownMenuSeparator sa samozatvarajucim tagom
-dodajemo tri komponente DropdownMenuCheckboxItem sa otvorenim i zatvorenim tagom
-komponentama DropdownMenuCheckboxItem dodajemo prop checked i dogadaj onClick
-u prop checked proslijedujemo dinamicku vrijednost varijable theme
-u dogadaj onClick proslijedujemo funkcije () => setTheme()

13. Loading & Not Found Pages
-otvorimo link: https://nextjs.org/docs/app/building-your-application/routing/loading-ui-and-streaming
-u folderu app kreiramo komponentu loading.tsx
-u komponenti app/loading.tsx kreiramo i eksportujemo funkciju LoadingPage() kao default
-importujemo komponentu Image iz paketa next/image
-importujemo sliku loader iz foldera assets
-u jsx-u roditelj div elementu dodajemo Tailwind CSS Flex klase
-u div element dodajemo komponentu Image sa prop src, alt, width i height
-u komponenti (root)/page.tsx kreiramo funkciju delay()
-otvorimo link: https://nextjs.org/docs/pages/building-your-application/routing/custom-error
-u folderu app kreiramo komponentu not-found.tsx
-u komponenti not-found.tsx kreiramo i eksportujemo funkciju NotFoundPage() kao default
-dodajemo direktivu 'use client'
-importujemo komponentu Image iz paketa next/image
-importujemo varijablu APP_NAME iz lib/constants.ts fajla
-importujemo komponentu Button iz komponente ui/button.tsx
-u jsx-u dodajemo roditelj div elementu Tailwind CSS Flex klase
-u div element dodajemo komponentu Image sa prop src, width, width, height i priority
-kreiramo HTML elemente h2 i p sa Tailwind CSS klasama
-importujemo komponentu Link iz paketa next/link
-u div element dodajemo komponentu Link sa prop href i className

14. Responsive Sheet Menu
-otvorimo link: https://ui.shadcn.com/docs/components/sheet
-u terminalu ukucamo komandu: npx shadcn@latest add sheet
-u folderu header kreiramo komponentu menu.tsx
-u komponenti menu.tsx kreiramo i eksportujemo funkciju Menu() kao default
-u jsx-u roditelj div elementu dodajemo Tailwind CSS klase
-u div elementu kreiramo nav element sa Tailwind CSS klasama
-iz komponente header/index.tsx prebacujemo komponente ModeToggle.tsx i Button u komponentu menu.tsx
-u komponentu header/index.tsx importujemo komponentu Menu iz komponente menu.tsx
-u komponentu menu.tsx importujemo React ikonicu EllipsisVertical iz paketa lucide/react
-importujemo komponente Sheet, SheetContent, SheetTitle i SheetTrigger iz komponente ui/sheet.tsx
-kreiramo jos jedan nav element sa Tailwind CSS klasom md:hidden
-u element nav dodajemo komponentu Sheet sa otvorenim i zatvorenim tagom
-u komponentu Sheet dodajemo komponentu SheetTrigger sa otvorenim i zatvorenim tagom
-u komponentu SheetTrigger dodajemo komponentu React ikonicu EllipsisVertical
-u komponentu Sheet dodajemo komponentu SheetContent sa otvorenim i zatvorenim tagom
-komponenti SheetContent dodajemo Tailwind CSS Flex klase
-u komponentu SheetContent dodajemo komponentu SheetTitle sa otvorenim i zatvorenim tagom
-u komponentu SheetContent dodajemo komponentu ModeToggle
-u komponentu SheetContent dodajemo komponentu Button sa prop asChild i variant
-u komponentu Button dodajemo komponentu Link sa prop href
-u komponentu Link dodajemo React ikonicu ShoppingCart
-u komponentu SheetContent dodajemo komponentu SheetDescription sa otvorenim i zatvorenim tagom
-u komponentu SheetContent dodajemo jos jednu komponentu Button sa prop asChild

15. Sample Products & Product List
-u eslint.config.mjs fajl dodajemo, u objekt rules dodajemo opciju: "@typescript-eslint/no-explicit-any": "off"
-kreiramo folder db i sample-data.ts fajl
-u sample-data.ts fajlu kreiramo i eskportujemo niz sampleData kao default
-u komponentu (root)/page.tsx importujemo niz sampleData
-u folderu components/shared kreiramo folder product i komponentu product-list.tsx
-u komponenti product/product-list.tsx kreiramo i eksportujemo funkciju ProductList() kao default
-u komponentu (root)/page.tsx importujemo komponentu ProductList.tsx iz komponenta product-list.tsx
-u jsx-u dodajemo prazan fragment kao roditelj element
-u element prazan fragment dodajemo komponentu ProductList sa prop data, title i limit
-u komponenti product-list.tsx, funkciji ProductList() dodajemo parametre destruktuirane prop sa tipovima
-u jsx-u div roditelj elementu dodajemo Tailwind CSS klasu my-10
-u div elementu kreiramo h2 element sa Tailwind CSS klasama
-u div elementu dodajemo uslov ternarni operator data?.length > 0
-kreiramo varijablu const limitedData
-u prvi dio ternarnog uslova dodajemo metodu limitedData?.map()
-u drugi dio ternarnog uslova dodajemo elemente div i p sa porukom da proizvodi nisu pronadeni

16. Product Card Component
-otvorimo link: https://ui.shadcn.com/docs/components/card
-u terminalu ukucamo komandu: npx shadcn@latest add card
-u folderu components/product kreiramo komponentu product-card.tsx
-u komponenti product-card.tsx kreiramo i eksportujemo funkciju ProductCard() kao default
-u komponentu product-card.tsx importujemo komponente Link i Image iz paketa next
-importujemo komponente Card, CardHeader i CardContent iz komponente ui/card.tsx
-funkciji ProductCard() dodajemo parametar destruktuirani prop product sa tipom
-u jsx-u dodajemo komponentu Card kao roditelj element sa Tailwind CSS klasama
-u komponentu Card dodajemo komponentu CardHeader sa otvorenim i zatvorenim tagom
-komponenti CardHeader dodajemo Tailwind CSS klase
-u komponentu CardHeader dodajemo komponente Link i Image
-u komponentu Card dodajemo komponentu CardContent sa otvorenim i zatvorenim tagom
-komponenti CardContent dodajemo Tailwind CSS klase
-u komponenti CardContent kreiramo div element
-dodajemo komponentu Link sa prop href 
-u prop href dodajemo dinamicki link
-u komponenti Link kreiramo h2 element sa Tailwind CSS klasama
-u komponentu product-list.tsx importujemo komponentu ProductCard iz komponente product-card.tsx
-u funkciju map() dodajemo komponentu ProductCard umjesto div elementa
-u komponenti CardContent kreiramo div element sa Tailwind CSS klasama
-u div elementu kreiramo p element
-u p elementu kreiramo dva span elementa
-dodajemo uslvo ternarni operator product?.stock > 0
-u prvi dio ternarnog operatora dodajemo p element u kojem dinamicki prikazujemo cijenu artikla
-u drugi dio ternarnog operatora dodajemo p element sa klasom text-destructive u kojem prikazujemo poruku kako artikl nije dostupan

17. Product Price Component
-u folderu components/product kreiramo komponentu product-price.tsx
-u komponenti product-price.tsx kreiramo i eksportujemo funkciju ProductPrice() kao default
-funkciji ProductPrice() dodajemo parametre destruktuirane prop value i className sa tipovima
-u funkciji ProductPrice() kreiramo varijablu const stringValue
-dodajemo metodu stringValue.split('.')
-vrijednost metode stringValue.split('.') pohranjujemo u varijable const [intValue, floatValue]
-importujemo funkciju cn iz lib/utils.ts fajla
-u jsx-u kreiramo p element kao roditelj element
-p elementu dodajemo prop className
-u prop className proslijedujemo funkciju cn()
-u p elementu kreiramo tri span elementa
-u komponentu product-card.tsx importujemo komponentu ProductPrice iz komponente product-price.tsx
-u prvi dio ternarnog uslova dodajemo komponentu ProductPrice umjesto p elementa
-komponenti ProductPrice dodajemo prop value
-u prop value proslijedujemo funkciju Number(product.price)


Section 03: Database, Prisma & Product Display

18. Section Intro

19. PostgreSQL & Prisma Setup
-otvorimo web stranicu: https://vercel.com/
-na web stranici Vercel odaberemo opciju Storage i kreiramo bazu podataka
-otvorimo web stranicu: https://www.prisma.io/
-u terminalu ukucamo komandu: npm install -D prisma @prisma/client
-ukucamo komandu npx prisma init
-nakon komande npx prisma init generise se folder prisma i schema.prisma fajl
-u .env fajlu se generise env varijabla DATABASE_URL
-varijabli DATABASE_URL dodajemo link za konekciju baze podataka (connection string) sa web stranice Vercel
-instaliramo VS Code ekstenziju za Prismu
-u example.env dodajemo primjer za varijablu DATABASE_URL koju je potrebno kreirati 

20. Prisma Models & Migrations
-otvorimo link: https://www.prisma.io/docs/orm/prisma-schema/data-model/models
-u schema.prisma fajlu kreiramo model Product
-u package.json fajl, u objekt scripts dodajemo komandu "postinstall": "prisma generate"
-u terminalu ukucamo komandu: npx prisma generate
-ukucamo komandu: npx prisma migrate dev --name init
-nakon ove komande u folderu prisma se generise folder migrations
-ukucamo komandu: npx prisma studio

21. Seed Sample Data
-otvorimo link: https://www.npmjs.com/package/tsx
-u terminalu instaliramo paket tsx sa komandom npm i tsx
-otvorimo link: https://www.npmjs.com/package/colors
-u terminalu instaliramo paket colors sa komandom npm i colors
-otvorimo link: https://www.prisma.io/docs/orm/reference/prisma-client-reference
-u folderu db kreiramo seed.ts fajl
-u seed.ts fajl importujemo funkciju PrismaClient iz paketa prisma/client
-importujemo nit sampleData iz sample-data.ts fajla
-kreiramo asinhronu funkciju main()
-u funkciji main() pozivamo funkciju new PrismaClient()
-vrijednost funkcije new PrismaClient() pohranjujemo u varijablu const prisma
-pozivamo funkciju await prisma.product.deleteMany()
-pozivamo funkciju await prisma.product.createMany()
-u terminalu ukucamo komandu: npx tsx ./db/seed

22. Load Products From Database
-otvorimo link: https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations
-otvorimo link: https://stackoverflow.com/questions/77091418/warning-only-plain-objects-can-be-passed-to-client-components-from-server-compo
-u folderu lib kreiramo folder actions
-u folderu actions kreiramo product.actions.ts fajl
-u product.actions.ts fajl dodajemo direktivu 'use server'
-kreiramo i eksportujemo asinhronu funkciju getLatestProducts()
-importujemo funkciju PrismaClient iz paketa prisma/client
-u funkciji getLatestProducts() kreiramo varijablu const prisma
-pozivamo funkciju await prisma.product.findMany()
-vrijednost funkcije await prisma.product.findMany() pohranjujemo u varijablu const data
-dodajemo izjavu return data
-u utils.ts fajlu kreiramo i eskportujemo funkciju convertToPlainObject()
-u product.actions.ts fajl importujemo funkciju convertToPlainObject
-u izjavu return dodajemo funkciju convertToPlainObject(data)
-u komponentu (root)/page.tsx importujemo funkciju getLatestProducts iz product.actions.ts fajla
-u funkciji Homepage() pozivamo funkciju await getLatestProducts()
-vrijednost funkcije await getLatestProducts() pohranjujemo u varijablu const latestProducts
-u prop data proslijedujemo vrijednost varijable latestProducts
-u constants/index.ts fajlu kreiramo i eksportujemo varijablu const LATEST_PRODUCTS_LIMIT
-u .env fajl dodajemo varijablu LATEST_PRODUCTS_LIMIT
-u example.env fajl dodajemo primjer varijable LATEST_PRODUCTS_LIMIT koju je potrebno kreirati
-u product.actions.ts fajl importujemo varijablu LATEST_PRODUCTS_LIMIT iz constants/index.ts fajla

23. Zod Validation & Type Inference
-otvorimo web stranicu: https://zod.dev/
-u terminalu ukucamo komandu: npm i zod
-u folderu lib kreiramo validators.ts fajl
-u validators.ts fajl importujemo instancu z iz paketa zod
-pozivamo funkciju z.object()
-vrijednost funkcije z.object() pohranjujemo u varijablu insertProductSchema
-eksportujemo varijable insertProductSchema
-kreiramo folder types
-u folderu types kreiramo index.ts fajl
-u types/index.ts fajl importujemo instancu z iz paketa zod
-importujemo varijablu insertProductSchema iz lib/validators.ts fajla
-kreiramo i eksportujemo tip Product
-tipu Product dodajemo genericki tip z.infer<typeof insertProductSchema> & { ... }
-u objekt dodajemo opcije id, rating i createdAt
-u lib/utils.ts fajlu kreiramo i eksportujemo funkciju formatNumberWithDecimal()
-u lib/validators.ts fajl importujemo funkciju formatNumberWithDecimal
-kreiramo varijablu const currency
-u objekt z.object({}) dodajemo key - value par price: currency
-u komponentu product-card.tsx importujemo tip Product iz foldera types
-u funkciji ProductCard() destruktuiranom parametru product dodajemo tip Product
-u komponentu product-list.tsx importujemo tip Product iz foldera types
-u funkciji ProductList() destruktuiranom parametru data dodajemo tip Product
-u jsx-u, u funkciji map() parametru product dodajemo tip Product

24. Serverless Environment Config
-otvorimo link: https://www.npmjs.com/package/@neondatabase/serverless
-u terminalu ukucamo komandu: npm i @neondatabase/serverless
-otvorimo link: https://www.npmjs.com/package/@prisma/adapter-neon
-ukucamo komandu: npm i @prisma/adapter-neon
-otvorimo link: https://www.npmjs.com/package/ws
-ukucamo komandu: npm i ws
-otvorimo link: https://www.npmjs.com/package/@types/ws
-ukucamo komandu: npm i -D @types/ws
-otvorimo link: https://www.npmjs.com/package/bufferutil
-ukucamo komandu: npm i -D bufferutil
-u schema.prisma fajlu u objekt generator client dodajemo opciju previewFeatures
-ukucamo komandu npx prisma generate
-otvorimo link: https://neon.tech/docs/serverless/serverless-driver
-otvorimo link: https://www.prisma.io/docs/orm/overview/databases/neon
-u folderu prisma kreiramo prisma.ts fajl
-u prisma.ts fajl kopiramo kod iz dokumentacije
-u product.actions.ts fajl importujemo instancu prisma iz db/prisma.ts fajla
-izbrisemo varijablu const prisma
-izbrisemo folder .next
-u terminalu ukucamo komandu: npm run dev

25. Product Details Page
-u product.actions.ts fajlu kreiramo i eksportujemo asinhronu funkciju getProductBySlug() sa parametrom slug
-parametru slug dodajemo tip string
-u izjavu return dodajemo metodu return await prisma.product.findFirst()
-u funkciju findFirst() dodajemo konfiguracioni objekt
-u konfiguracioni objekt dodajemo objekt where
-u folderu (root) kreiramo foldere product i [slug]
-u folderu product/[slug] kreiramo komponentu page.tsx
-u komponenti [slug]/page.tsx kreiramo i eksportujemo funkciju ProductDetailsPage() kao default
-otvorimo rutu: http://localhost:3000/product/[slug]
-funkciji ProductDetailsPage() dodajemo parametar props sa tipom Promise
-funkciji ProductDetailsPage() dodajemo asinhronost
-u funkciji ProductDetailsPage() dodajemo metodu await props.params
-vrijednost metode await props.params pohranjujemo u destruktuiranu varijablu const { slug }
-importujemo funkciju notFound iz paketa next/navigation
-importujemo funkciju getProductBySlug iz product.actions.ts fajla
-dodajemo metodu getProductBySlug(slug)
-vrijednost metode getProductBySlug(slug) pohranjujemo u varijablu const product
-dodajemo uslov if (!product) notFound()
-otvorimo link: https://ui.shadcn.com/docs/components/badge
-u terminalu ukucamo komandu: npx shadcn@latest add badge
-importujemo komponentu Badge iz komponente ui/components/badge.tsx
-importujemo komponente Card i CardContent iz komponente ui/components/card.tsx
-importujemo komponentu Button iz komponente ui/components/button.tsx
-importujemo komponentu ProductPrice iz komponente product/product-price.tsx
-u jsx-u dodajemo section element kao roditelj element
-u section elementu kreiramo div element sa Tailwind CSS Grid klasama
-u div elementu sa Tailwind CSS Grid klasama kreiramo dva div elementa za sliku i detalje sa Tailwind CSS klasom col-span-2
-u div elementu za detalje kreiramo div element sa Tailwind CSS Flex klasama
-u div elementu kreiramo p dva span elementa u kojima dinamicki prikazujemo marku artikla i kategoriju
-kreiramo h2 element u kojem dinamicki prikazujemo ime artikla
-kreiramo p element i unutar njega cetiri span elementa u kojima dinamicki prikazujemo ocjenu i recenzije artikla
-kreiramo div element sa Tailwind CSS Flex klasama u koji dodajemo komponentu ProductPrice
-komponenti ProductPrice dodajemo prop value i className
-kreiramo div element sa klasom mt-10 u kojem dinamicki prikazujemo opis artikla
-kreiramo div element u koji dodajemo komponentu Card sa otvorenim i zatvorenim tagom
-u komponentu Card dodajemo komponentu CardContent
-u komponenti CardContent kreiramo div element u koji dodajemo komponentu ProductPrice
-kreiramo div element u koji dodajemo komponentu Badge
-dodajemo uslov ternarni operator product?.stock > 0 
-dodajemo uslov za kondicionalno renderovanje komponenta Button product?.stock > 0 &&

26. Product Images Component
-u folderu shared/product kreiramo komponentu product-images.tsx
-u komponenti product-images.tsx kreiramo i eksportujemo funkciju ProductImages() kao default
-funkciji ProductImages() dodajemo parametar destruktuirani prop images sa tipom string[]
-u komponentu [slug]/page.tsx importujemo komponentu ProductImages iz komponente product-images.tsx
-u jsx-u, u div element za sliku dodajemo komponentu ProductImages sa prop images
-u komponentu product-images.tsx dodajemo direktivu 'use client'
-importujemo funkciju useState iz paketa react
-importujemo komponentu Image iz paketa next/image
-importujemo funkciju cn iz lib/utils.ts fajla
-u funkciji ProductImages() kreiramo state varijablu const current i set funkciju setCurrent
-u roditelj div element dodajemo komponentu Image
-komponenti Image dodajemo prop src, alt, width, height i className
-kreiramo div element sa Tailwind klasom flex
-u div element dodajemo metodu images?.map()
-u funkciji map() kreiramo div element
-div elementu dodajemo prop key, className i dogadaj onClick
-u div element dodajemo komponentu Image
-komponenti Image dodajemo prop src, alt, width, height
-u dogadaj onClick proslijedujemo funkciju () => setCurrent(index)
-u prop className proslijedujemo dinamicku klasu cn()

27. Initial Deployment
-u terminalu ukucamo komandu: npm run build
-otvorimo Web stranicu: https://github.com i postavimo kod
-na Web stranici https://vercel.com kreiramo novi projekt
-u kreirani projekt dodajemo env varijable iz .env fajla
-u opciji Install Command dodajemo komandu: npm install --legacy-peer-deps
-promjenimo ime varijable NEXT_PUBLIC_SERVER_URL nakon sto dobijemo Vercel link projekta

28. A Note On ES Lint Errors


Section 04: Authentication With Next Auth

29. Section Intro

30. Prisma User-Related Models
-otvorimo web stranicu: https://authjs.dev/
-otvorimo link: https://authjs.dev/getting-started/adapters/prisma
-u schema.prisma fajlu kreiramo modele User, Account, Session i VerificationToken
-u terminalu ukucamo komandu: npx prisma generate
-ukucamo komandu: npx prisma migrate dev --name add_user_based_tables
-u folderu prisma generisan novi folder za migracije
-ukucamo komandu: npx prisma studio

31. Seed User Data
-u sample-data.ts fajlu kreiramo niz users
-otvorimo link: https://www.npmjs.com/package/bcrypt-ts
-otvorimo link: https://npm.runkit.com/bcrypt-ts-edge
-u terminalu ukucamo komandu: npm install bcrypt-ts-edge
-importujemo funkciju hashSync iz paketa bcrypt-ts-edge
-u nizu users kreiramo dva objekta sa podacima o korisniku
-u objekte dodajemo polja name, email, password i role
-u seed.ts fajl, u funkciju main() dodajemo vise metoda deleteMany()
-dodajemo metodu await prisma.user.createMany() za korisnike
-u terminalu ukucamo komandu: npx tsx ./db/seed
-ukucamo komandu: npx prisma studio

32. Next Auth Setup
-otvorimo link: https://authjs.dev/getting-started
-u terminalu ukucamo komandu: npm install next-auth@5.0.0-beta.25 --legacy-peer-deps
-otvorimo link: https://www.npmjs.com/package/@auth/prisma-adapter
-ukucamo komandu: npm install @auth/prisma-adapter
-ukucamo komandu: openssl rand -base64 32
-u .env fajlu dodajemo env varijable NEXT_AUTH_SECRET, NEXTAUTH_URL i NEXTAUTH_URL_INTERNAL
-u example.env fajl dodajemo primjer varijabli koje je potrebno kreirati
-otvorimo link: https://next-auth.js.org/configuration/options
-kreiramo auth.ts fajl i importujemo funkciju NextAuth iz paketa next-auth
-kreiramo i eskportujemo objekt config
-pozivamo funkciju NextAuth(config)
-vrijednost funkcije NextAuth(config) pohranjujemo u destruktuirane varijable const { handlers, auth, signIn, signOut } 
-eksportujemo destruktuirane varijable
-u objekt config dodajemo objekte pages i session
-importujemo funkciju PrismaAdapter iz paketa auth/prisma-adapter
-importujemo instancu prisma iz db/prisma.ts fajla
-u objekt config dodajemo key-value par adapter i funkciju PrismaAdapter(prisma)
-dodajemo niz providers
-importujemo funkciju CredentialsProvider iz paketa next-auth/providers/credentials
-importujemo funkciju compareSync iz paketa bcrypt-ts-edge
-u nizu providers pozivamo funkciju CredentialsProvider() sa argumentom konfiguracionim objektom
-u konfiguracioni objekt dodajemo objekt credentials
-dodajemo metodu async authorize(credentials)
-u funkciju authorize(credentials) dodajemo uslov if (credentials === null) return null
-kreiramo varijablu const user
-dodajemo uslov if (user && user.password)
-u uslovu if kreiramo varijablu const isMatch
-dodajemo uslov if (isMatch)
-dodajemo izjavu return null ako korisnik ne postoji ili ako se unesena sifra ne slaze sa sifrom u bazi podataka
-importujemo tip NextAuthConfig iz paketa next-auth
-dodajemo objekt callbacks
-u objekt callbacks dodajemo asinhronu funkciju session()
-funkciji session dodajemo parametre { session, user, trigger, token }
-u funkciju session() dodajemo metodu session.user.id = token.sub
-dodajemo uslov if (trigger === 'update') 
-nakon uslova if dodajemo izjavu return session
-objektu config dodajemo tip satisfies NextAuthConfig

33. Next Auth Catch All API Route
-otvorimo link: https://next-auth.js.org/getting-started/example#add-api-route
-u folderu app kreiramo foldere api, auth i [...nextauth]
-u folderu [...nextauth] kreiramo route.ts fajl
-u route.ts fajl dodajemo console.log('Hello World');
-u pretrazivacu otvorimo rutu: http://localhost:3000/api/auth/session
-u route.ts fajl importujemo varijablu handlers iz auth.ts fajla
-eksportujemo funkcije GET i POST
-u pretrazivacu otvorimo rute: /api/auth/signin, /api/auth/signout i /api/auth/session

34. Sign In & Sign Out Action
-u validators.ts fajlu kreiramo i eksportujemo varijablu signInFormSchema
-u folderu lib/actions kreiramo user.actions.ts fajl
-u user.actions.ts fajl dodajemo direktivu 'use server'
-importujemo funkciju signInFormSchema iz validators.ts fajla
-importujemo funkcije signIn i signOut iz auth.ts fajla
-importujemo funkciju isRedirectError iz paketa next
-kreiramo i eksportujemo asinhronu funkciju signInWithCredentials()
-funkciji signInWithCredentials() dodajemo parametre prevState i formData sa tipovima
-dodajemo blokove koda try - catch
-u bloku koda try dodajemo metodu signInFormSchema.parse()
-vrijednost metode signInFormSchema() pohranjujemo u varijablu const user
-pozivamo funkciju await signIn('credentials, user)
-dodajemo izjavu return objekt sa key - value vrijednostima success i message
-u objekt dodajemo vrijednost success: true i poruku da je prijava uspjesna
-u blok koda catch(error) dodajemo uslov if (isRedirectError(error))
-u uslov if dodajemo throw error
-dodajemo izjavu return objekt sa key - value vrijednostima success i message
-u objekt dodajemo vrijednost success: false i poruku da je email ili sifra pogresna
-kreiramo i eksportujemo asinhronu funkciju signOutUser()
-u funkciji signOutUser() pozivamo funkciju await signOut()

35. Auth Layout & Sign In Page
-u folderu app kreiramo folder (auth)
-u folderu (auth) kreiramo komponentu layout.tsx
-u komponenti (auth)/layout.tsx kreiramo i eksportujemo funkciju AuthLayout() kao default
-u funkciji AuthLayout() kreiramo roditelj div element sa Tailwind CSS klasama
-u div element dinamicki prikazujemo vrijednost prop children
-u folderu (auth) kreiramo folder sign-in i komponentu page.tsx
-u komponenti sign-in/page.tsx kreiramo i eksportujemo funkciju SignInPage() kao default
-otvorimo link: https://nextjs.org/docs/app/building-your-application/optimizing/metadata
-importujemo tip Metadata iz paketa next
-kreiramo i eksportujemo varijablu const metadata sa tipom Metadata
-u jsx-u roditelj div elementu dodajemo Tailwind CSS klase
-importujemo komponente Card, CardContent, CardDescription, CardHeader i CardTitle iz komponente ui/card.tsx
-u div element dodajemo komponentu Card sa otvorenim i zatvorenim tagom
-u komponentu Card dodajemo komponentu CardHeader sa otvorenim i zatvorenim tagom
-importujemo komponente Link i Image iz paketa next
-importujemo varijablu APP_NAME iz lib/constants.ts fajla
-u komponentu CardHeader dodajemo komponentu Link sa prop href i className
-u komponentu Link dodajemo komponentu Image sa prop src, alt, width, height i priority
-dodajemo komponentu CardTitle sa otvorenim i zatvorenim tagom
-dodajemo komponentu CardDescription sa otvorenim i zatvorenim tagom
-u komponentu Card dodajemo komponentu CardContent sa otvorenim i zatvorenim tagom

36. Credentials Sign In Form
-u folderu sign-in kreiramo komponentu credentials-signin-form.tsx
-u komponenti credentials-signin-form.tsx kreiramo i eksportujemo funkciju CredentialsSignInForm() kao default
-u komponentu sign-in/page.tsx importujemo komponentu CredentialsSignInForm iz komponente credentials-signin-form.tsx
-u jsx-u, u komponentu CardContent dodajemo komponentu CredentialsSignInForm
-u komponentu credentials-signin-form.tsx dodajemo direktivu 'use client'
-otvorimo link: https://ui.shadcn.com/docs/components/label
-otvorimo link: https://ui.shadcn.com/docs/components/input
-u terminalu ukucamo komandu: npx shadcn@latest add input label
-u funkciji CredentialsSignInForm(), u jsx-u kreiramo form element kao roditelj element
-u form elementu kreiramo div element za email polja sa Tailwind CSS klasom space-y-6
-importujemo komponente Label i Input iz foldera components/ui
-u div element dodajemo komponente Label i Input
-komponenti Label dodajemo prop htmlFor
-komponenti Input dodajemo prop id, name, type, required i autoComplete
-u constants/index.ts fajlu kreiramo i eksportujemo varijablu objekt const signInDefaultValues
-u komponentu credentials-signin-form.tsx importujemo varijablu signInDefaultValues
-u jsx-u komponenti Input dodajemo prop defaultValue
-u prop defaultValue proslijedujemo vrijednost varijable signInDefaultValues.email
-kreiramo jos jedan div element za sifru 
-u div element dodajemo komponente Label i Input
-komponenti Input dodajemo prop defaultValue
-u prop defaultValue proslijedujemo vrijednost varijable signInDefaultValues.password
-importujemo komponentu Button iz komponente ui/button.tsx
-kreiramo div element za komponentu Button
-komponenti Button dodajemo prop className i variant
-kreiramo div element za span element i komponentu Link
-komponenti Link dodajemo prop href, target i className

37. Hook Up Sign In Form
-otvorimo link: https://react.dev/reference/react/useActionState
-otvorimo link: https://react.dev/reference/react-dom/hooks/useFormStatus
-u komponentu credentials-signin-form.tsx importujemo funkciju useAction state iz paketa react
-importujemo funkciju useFormStatus iz paketa react-dom
-importujemo funkciju signInWithCredentials iz actions/user.actions.ts fajla
-u funkciji CredentialsSignInForm() pozivamo funkciju useActionState() sa dva argumenta
-u funkciji useActionState() prvi argument je funkcija signInWithCredentials, dok je drugi argument ojekt
-vrijednost funkcije pohranjujemo u varijablu const data i funkciju action
-u jsx-u form elementu dodajemo prop action
-u prop action proslijedujemo vrijednost funkcije action
-dodajemo uslov za kondicionalno renderovanje data && !data.success && ()
-kreiramo funkciju SignInButton()
-u funkciji SignInButton() pozivamo funkciju useFormStatus()
-vrijednost funkcije useFormStatus() pohranjujemo u destruktuiranu varijablu const { pending }
-dodajemo izjavu return
-u izjavi return dodajemo komponentu Button sa prop disabled, className i variant
-u komponentu Button dodajemo uslov ternarni operator za varijablu pending
-u div element dodajemo komponentu SignInButton
-u komponentu app/(auth)/page.tsx importujemo funkciju auth iz auth.ts fajla
-importujemo funkciju redirect iz paketa next/redirect
-funkciji SignInPage() dodajemo asinhronost
-u funkciji SignInPage() pozivamo funkciju await auth()
-vrijednost funkcije await auth() pohranjujemo u varijablu const session
-dodajemo uslov if (session)
-u uslovu if (session) pozivamo funkciju return redirect('/')
-u pretrazivacu otvorimo rutu: http://localhost:3000/ i prijavimo se
-u pretrazivacu otvorimo opciju Devtools -> Application -> Cookies
-otvorimo link: http://localhost:3000/api/auth/session da vidimo podatke o prijavljenom korisniku
-u folderu sign-in kreiramo komponentu signin-button.tsx
-u komponenti signin-button.tsx kreiramo i eskportujemo funkciju SignInButton() kao default
-premjestamo logiku za komponentu SignInButton iz komponente credentials-signin-form.tsx
-u komponentu credentials-signin-form.tsx importujemo komponentu SignInButton iz komponente signin-button.tsx
-otvorimo rutu: http://localhost:3000/sign-in i prijavimo se

38. Callback URL Redirect
-otvorimo link: https://nextjs.org/docs/app/api-reference/functions/use-search-params
-u komponenti sign-in/page.tsx, funkciji SignInPage() dodajemo parametar props sa generickim tipom Promise
-u funkciji SignInPage() dodajemo metodu await props.searchParams
-vrijednost metode await props.searchParams pohranjujemo u varijablu const { callbackUrl }
-u uslov if (session) dodajemo izjavu return redirect(callbackUrl || '/')
-u komponentu sign-in-credentials.tsx importujemo funkciju useSearchParams iz paketa next/navigation
-u funkciji CredentialsSignInForm() kreiramo varijable const searchParams i const callbackUrl
-u jsx-u, u form elementu kreiramo input element sa prop type, name i value
-u prop type dodajemo opciju da je element sakriven
-u prop name dodajemo ime callbackUrl
-u prop value proslijedujemo vrijednost varijable callbackUrl
-otvorimo pretrazivac i obrisemo kolacice u aplikaciji 
-otvorimo rutu: http://localhost:3000/sign-in?callbackUrl=http%3A%2F%2Flocalhost%3A3000%2Fshipping-address i prijavimo se
-nakon prijave treba se otvoriti ruta: http://localhost:3000/shipping-address

39. User Button & Sign Out
-u projekt na web stranici Vercel dodajemo tri env varijable: NEXTAUTH_SECRET, NEXTAUTH_URL i NEXTAUTH_URL_INTERNAL
-u folderu header kreiramo komponentu user-button.tsx
-u komponenti user-button.tsx kreiramo i eksportujemo funkciju UserButton() kao default
-u komponentu menu.tsx importujemo komponentu UserButton iz komponente user-button.tsx
-u jsx-u dodajemo dvije komponente UserButton sa samozatvarajucim tagom
-u komponentu user-button.tsx importujemo komponentu Link iz paketa next
-importujemo funkciju auth iz auth.ts fajla
-importujemo komponentu Button iz komponente ui/button.tsx
-importujemo komponente DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuLabel i DropdownMenuTrigger iz komponente ui/dropdown-menu.tsx
-importujemo React ikonicu UserIcon iz paketa lucide-react
-funkciji UserButton() dodajemo asinhronost
-u funkciji UserButton() pozivamo funkciju await auth()
-vrijednost funkcije await auth() pohranjujemo u varijablu const session
-dodajemo uslov if (!session)
-u uslov if (!session) dodajemo komponentu Button za prikazivenje teksta za prijavu ako korisnik nije prijavljen
-kreiramo varijablu const firstInitial
-importujemo funkciju signOutUser iz user.actions.ts fajla
-u jsx-u roditelj div elementu dodajemo Tailwind CSS flex klase
-u div element dodajemo komponentu DropdownMenu sa otvorenim i zatvorenim tagom
-u komponentu DropdownMenu dodajemo komponentu DropdownMenuTrigger sa otvorenim i zatvorenim tagom
-u komponenti DropdownMenuTrigger kreiramo div element sa Tailwind CSS flex klasama
-u div element dodajemo komponentu Button sa prop variant, className
-u komponenti Button dinamicki prikazujemo vrijednost varijable firstInitial
-u komponentu DropdownMenu dodajemo komponentu DropdownMenuContent sa otvorenim i zatvorenim tagom 
-komponenti DropdownMenuContent dodajemo prop className, align i forceMount
-u komponentu DropdownMenuContent dodajemo komponentu DropdownMenuLabel sa otvorenim i zatvorenim tagom
-u komponenti DropdownMenuLabel kreiramo div element sa Tailwind CSS klasama
-u div elementu kreiramo dva p elementa sa Tailwind CSS klasama u kojima dinamicki prikazujemo ime i email prijavljenog korisnika
-u komponentu DropdownMenuContent dodajemo komponentu DropdownMenuItem sa otvorenim i zatvorenim tagom
-u komponenti DropdownMenuContent kreiramo form element sa prop action
-u prop action proslijedujemo funkciju signOutUser
-u form element dodajemo komponentu Button sa tekstom Sign Out

40. Sign Up Zod Schema & Action
-u validators.ts fajlu kreiramo i eksportujemo varijablu const signUpFormSchema
-funkciji z.object({ }) dodajemo metodu refine()
-u user.actions.ts fajl importujemo varijablu signUpFormSchema iz validators.ts fajla
-importujemo funkciju hashSync iz paketa bcrypt-ts-edge
-importujemo instancu prisma iz db/prisma.ts fajla
-kreiramo i eksportujemo asinhronu funkciju signUp() sa dva parametra
-u funkciji signUp() prvi parametar je prevState sa tipom unknown, dok je drugi parametar formData sa tipom FormData
-u funkciji signUp() dodajemo blokove koda try - catch
-u bloku koda try dodajemo metodu signUpFormSchema.parse()
-vrijednost metode signUpFormSchema.parse() pohranjujemo u varijablu const user
-kreiramo varijablu const plainPassword
-dodajemo metodu hashSync(user.password, 10)
-vrijednost metode hashSync(user.password, 10) pohranjujemo u objekt polje user.password
-pozivamo metodu await prisma.user.create()
-u funkciju create() dodajemo konfiguracioni objekt
-u konfiguracioni objekt dodajemo objekt data { ... }
-pozivamo funkciju await signIn() sa dva argumenta
-u funkciji signIn() prvi argument je string credentials, dok je drugi argument objekt koji sadrzi polja o imenu u hasovanoj sifri
-dodajemo objekt izjavu return sa poljima success: true i porukom da je korisnik uspjesno kreiran
-u blok koda catch (error) dodajemo uslov if (isRedirectError(error))
-dodajemo objekt izjavu return sa poljima success: false i porukom da je doslo do greske

41. Sign Up Page & Form
-u folderu (auth) kreiramo folder sign-up i komponentu page.tsx
-u komponenti sign-up/page.tsx kreiramo i eksportujemo funkciju SignUpPage()
-kopiramo vecinu koda iz komponente sign-in/page.tsx u komponentu sign-up/page.tsx
-u folderu sign-up kreiramo komponentu sign-up-form.tsx
-kopiramo vecinu koda iz komponente sign-in/credentials-sign-form.tsx u komponentu sign-up-form.tsx
-u constants/index.ts fajlu kreiramo i eksportujemo varijablu signUpDefaultValues
-u komponentu sign-up-form.tsx importujemo varijablu signUpDefaultValues
-importujemo funkciju signUp iz user.actions.ts fajla
-kreiramo komponentu sign-up-button.tsx 
-u komponenti sign-up-button.tsx kreiramo i eksportujemo funkciju SignUpButton() kao default
-u komponentu sign-up-form.tsx importujemo komponentu SignUpButton iz komponente sign-up-button.tsx
-u komponentu sign-up/page.tsx importujemo komponentu SignUpForm iz komponente sign-up-form.tsx
-otvorimo rutu: http://localhost:3000/sign-up i registrujemo se

42. Sign Up Error Handling
-u komponenti sign-up-form.tsx, komponentama Input brisemo prop required
-komponenti Input za email dodajemo prop type='text'
-otvorimo rutu: http://localhost:3000/sign-up i pokusamo se regitrovati sa netacnim kredencijalima
-u lib/utils.ts fajlu kreiramo i eksportujemo asinhronu funkcija formatError() sa parametrom error
-parametru error dodajemo tip any
-u funkciji formatError() dodajemo uslov if (error.name === 'ZodError')
-dodajemo uslove else if i else
-u uslovu if dodajemo metodu Object.keys(error.errors).map((field) => { ... })
-u funkciji map() kreiramo varijablu const message
-dodajemo izjavu ternarni operator return typeof message === 'string'
-vrijednost metode Object.keys() pohranjujemo u varijablu const fieldErrors
-dodajemo izjavu return fieldErrors.join('. ')
-u user.actions.ts fajl importujemo funkciju formatError iz utils.ts fajla
-funkciju signUp preimenujemo u signUpUser
-u funkciju signUpUser, u izjavu objekt return, u polje message dodajemo funkciju formatError(error)
-u utils.ts fajlu, u funkciji formatError(), u uslovu else if kreiramo varijablu const field
-dodajemo izjavu return poruku da korisnik sa tom email adresom postoji
-u uslov else dodajemo izjavu uslov ternarni operator return typeof error.message === 'string'

43. Customize Token with JWT Callback
-manje izmjene u semama za prijavu i registraciju korisnika u validators.ts fajlu
-otvorimo link: https://next-auth.js.org/configuration/callbacks
-u auth.ts fajlu kreiramo asinhronu funkciju jtw() sa parametrima destruktuiranom prop { token, user, trigger, session }
-parametrima dodajemo tip any
-u funkciju jwt() dodajemo uslov if (user)
-dodajemo izjavu return token
-u funkciju session() dodajemo vrijednosti session.user.role i session.user.name
-promjenimo uslov if (trigger === 'update') u if (trigger === 'update' && token.name)
-u funkciju jtw() dodajemo uslov if (session?.user.name && trigger === 'update')
-otvorimo rutu: http://localhost:3000/sign-in i prijavio se
-u VS Code terminalu provjerimo vrijednost za token
-otvorimo rutu: http://localhost:3000/api/auth/session da provjerimo informacije za prijavljenog korisnika


Section 05: Add To Cart

44. Section Intro

45. Cart Zod Schema & Prisma Model
-u validators.ts fajlu kreiramo i eksportujemo varijablu cartItemSchema
-kreiramo i eksportujemo varijablu const insertCartSchema
-u types/index.ts fajlu importujemo varijable insertCartSchema i cartItemSchema
-kreiramo i eksportujemo tipove Cart i CartItem
-u schema.prisma kreiramo model Cart
-modelu User dodajemo model Cart
-u terminalu ukucamo komandu: npx prisma generate
-u terminalu ukucamo komandu: npx prisma migrate dev --name add-cart
-u terminalu ukucamo komandu: npx prisma studio
-u folderu prisma/migrations se generise folder add_cart i migration.sql fajl

46. Add To Cart Component
-u folderu shared/product kreiramo komponentu add-to-cart.tsx
-u komponenti add-to-cart.tsx kreiramo i eksportujemo funkciju AddToCart() kao default
-dodajemo direktivu 'use client'
-importujemo tip CartItem iz foldera types
-funkciji AddToCart() dodajemo parametar destruktuirani prop item
-destruktuiranom parametru item dodajemo tip CartItem
-u komponentu product/[slug]/page.tsx importujemo komponentu AddToCart iz komponente add-to-cart.tsx
-izbrisemo import za komponentu Button
-u jsx-u, u uslovu za kondicionalno renderovanje product?.stock > 0 && dodajemo komponentu AddToCart
-komponenti AddToCart dodajemo prop item
-u komponentu add-to-cart.tsx importujemo komponentu Button iz komponente ui/button.tsx
-importujemo funkciju useRouter iz paketa next/navigation
-importujemo React ikonicu Plus iz paketa lucide-react
-otvorimo link: https://ui.shadcn.com/docs/components/toast
-u terminalu ukucamo komandu: npx shadcn@latest add toast
-u folderu components/ui se generisu komponente toast.tsx i toaster.tsx
-generise se folder hooks sa use-toast.ts fajlom
-u komponentu app/layout.tsx importujemo komponentu Toaster iz komponente ui/toaster
-u jsx-u, u komponentu ThemeProvider dodajemo komponentu Toaster sa samozatvarajucim tagom
-u komponentu add-to-cart.tsx importujemo funkciju useToast iz hooks/use-toast.ts fajla
-importujemo komponentu ToastAction iz komponente ui/toast.tsx
-u jsx-u, dodajemo komponentu Button sa prop className, type i onClick
-kreiramo asinhronu funkciju handleAddToCart()
-u folderu lib/actions kredencijalima cart.actions.ts fajl
-u cart.actions.ts fajl dodajemo direktivu 'use server'
-importujemo tip CartItem iz foldera types
-kreiramo i eksportujemo asinhronu funkciju addItemToCart() sa parametrom data
-parametru data dodajemo tip CartItem
-u funkciju addItemToCart() dodajemo izjavu objekt return sa key - value parovima success i message
-u komponentu add-to-cart.tsx importujemo funkciju addItemToCart iz foldera lib/actions
-u funkcija AddToCart() pozivamo funkcije useRouter() i useToast()
-vrijednost funkcije useRouter() pohranjujemo u destruktuiranu varijablu const router
-vrijednost funkcije useToast() pohranjujemo u destruktuiranu varijablu const { toast }
-u funkciji handleAddToCart() pozivamo funkciju await addItemToCart(item)
-vrijednost funkcije await addItemToCart(item) pohranjujemo u varijablu const res
-dodajemo uslov if (!res.success)
-u uslovu if (!res.success) pozivamo funkciju toast()
-funkciji toast() dodajemo argument objekt sa key - value parovima variant i description
-nakon funkcije toast() dodajemo izjavu return
-nakon uslova if (!res.success) pozivamo funkciju toast()
-funkciji toast() dodajemo argument objekt sa key - value parovima description i action
-u prop action dodajemo komponentu ToastAction sa otvorenim i zatvorenim tagom
-komponenti ToastAction dodajemo prop className, altText i dogadaj onClick
-u dogadaj onClick proslijedujemo anonimnu funkciju
-u anonimnu funkciju proslijedujemo funkciju router.push('/cart')
-otvorimo rutu http://localhost:3000/product/[slug] i kliknemo dugme Add To Cart
-importujemo React ikonicu Plus iz paketa lucide-react
-u komponenti Button kreiramo dva span element
-u prvi span element dodajemo komponentu Button, dok u drugi span element dodajemo tekst Add To Cart

47. Session Cart ID Cookie
-otvorimo link: https://vercel.com/docs/functions/limitations#code-size-limit
-otvorimo link: https://gist.github.com/bradtraversy/16e3c89b9b25bc79cf86f5f36e14e83d
-otvorimo link: https://authjs.dev/reference/nextjs#authorized
-kreiramo middleware.ts fajl
-u middleware.ts fajlu eksportujemo funkciju auth kao middleware
-u auth.ts fajl importujemo funkcije cookies i NextResponse iz paketa next
-kreiramo funkciju authorized() sa destruktuirana parametra request i auth
-u funkciju authorized dodajemo uslov if - else
-pozivamo funkciju crypto.randomUUID()
-vrijednost funkcije crypto.randomUUID() pohranjujemo u varijablu const sessionCartId
-pozivamo funkciju new Headers(request.headers)
-vrijednost funkcije new Headers(request.headers) pohranjujemo u varijablu const newRequestHeaders
-pozivamo funkciju NextResponse.next()
-vrijednost funkcije NextResponse.next() pohranjujemo u varijablu const response
-pozivamo funkciju response.cookies.set()
-dodajemo izjavu return response
-u uslov else dodajemo izjavu return true

Vercel Deploy Error Edge Function "middleware" fix
-Error: The Edge Function "middleware" size is 1.02 MB and your plan size limit is 1 MB. Learn More: https://vercel.link/edge-function-size
-otvorimo link: https://gist.github.com/bushblade/73a85d7bb145d17d7dbb6bea68f11f9e
-kreiramo auth.config.ts fajl
-u auth.config.ts fajl importujemo tip NextAuthConfig i funkciju NextResponse iz paketa next
-kreiramo i eksportujemo objekt const authConfig
-u objekt authConfig dodajemo niz providers i objekt callbacks
-u middleware.ts fajl importujemo objekt authConfig
-u auth.ts fajl importujemo objekt authConfig
-u objekt callbacks dodajemo ...authConfig.callbacks

48. Get Item From Cart
-u cart.actions.ts fajl importujemo funkcije cookies i formatError iz foldera utils
-u funkciju addItemToCart() dodajemo blokove koda try - catch
-u blokove koda try - catch dodajemo izjave return i objekte sa key - value parovima success i message
-u funkciji addItemToCart() pozivamo funkciju await cookies()
-vrijednost funkcije await cookies() pohranjujemo u varijablu const sessionCartId 
-dodajemo uslov if (!sessionCartId)
-importujemo funkciju auth iz auth.ts fajla
-pozivamo funkciju await auth()
-vrijednost funkcije await auth() pohranjujemo u varijablu const session
-kreiramo varijablu const userId
-kreiramo i eksportujemo asinhronu funkciju getMyCart()
-importujemo instancu prisma prisma.ts fajla
-u funkciji getMyCart() kreiramo varijablu const sessionCartId
-dodajemo uslov if (!sessionCartId)
-kreiramo varijable const session i const userId
-pozivamo funkciju await prisma.card.findFirst()
-vrijednost funkcije await prisma.card.findFirst() pohranjujemo u varijablu const cart
-dodajemo uslov if (!cart) return undefined
-importujemo funkciju convertToPlainObject iz utils.ts fajla
-dodajemo izjavu return convertToPlainObject()
-u funkciji addItemToCart() pozivamo funkciju await getMyCart()
-vrijednost funkcije await getMyCart() pohranjujemo u varijablu const cart
-importujemo varijablu cartItemSchema iz validators.ts fajla
-kreiramo varijablu const item
-pozivamo funkciju await prisma.product.findFirst()
-vrijednost funkcije await prisma.product.findFirst() pohranjujemo u varijablu const product

49. Price Calc & Add To Database
-u lib/utils.ts fajlu kreiramo i eksportujemo funkciju round2() sa parametrom value
-parametru value dodajemo tipove number | string
-u funkciju round2() dodajemo uslove if - else if - else
-u cart.actions.ts fajl importujemo funkciju round2 iz utils.ts fajla
-kreiramo funkciju calcPrice() sa parametrom items
-parametru items dodajemo tip CartItem[]
-u funkciji calcPrice() pozivamo funkciju round2()
-vrijednost funkcije round2() pohranjujemo u varijablu const itemsPrice
-dodajemo izjavu return objekt sa key - value parovima itemsPrice, shippingPrice, taxPrice i totalPrice
-importujemo varijablu insertCartSchema iz validators.ts fajla
-u funkciju addItemToCart() dodajemo uslov if (!product)
-dodajemo uslov if (!cart)
-u uslovu if (!cart) kreiramo varijablu const newCart
-otvorimo rutu http://localhost:3000/product/[slug] i kliknemo dugme Add To Cart
-pozivamo funkciju await prisma.cart.create()
-importujemo funkciju revalidatePath iz paketa next/cache
-pozivamo funkciju revalidatePath()
-izjavu return objekt sa key - value parovima success i message premjestamo u uslov if (!cart)

50. Handle Quantity & Multiple Products
-u cart.actions.ts fajl importujemo instancu Prisma iz paketa prisma/client
-za uslov if (!cart) dodajemo uslov else
-u uslovu else kreiramo varijablu const existItem
-dodajemo uslov if (existItem) - else
-u uslov if (existItem) dodajemo uslov if (product.stock < existItem.qty + 1) 
-u uslov if pozivamo funkciju throw new Error()
-nakon uslova if pozivamo funkciju (cart.items as CartItem[]).find()
-u uslov else dodajemo uslov if (product.stock < 1)
-u uslov if (product.stock < 1) pozivamo funkciju throw new Error()
-nakon uslova if pozivamo funkciju cart.items.push(item)
-pozivamo funkciju await prisma.cart.update()
-pozivamo funkciju revalidatePath()
-dodajemo izjavu return objekt sa key - value parovima success i message
-u komponentu add-to-cart.tsx, u funkciju toast dodajemo description: res.message
-otvorimo rutu: http://localhost:3000/product/[slug] i kliknemo dugme Add To Cart da vidimo poruku

51. Remove Cart Action
-u cart.actions.ts fajlu kreiramo i eksportujemo funkciju removeItemFromCart() sa parametrom productId
-parametru productId dodajemo tip string
-u funkciju removeItemFromCart() dodajemo blokove koda try - catch
-u blok koda catch dodajemo izjavu return objekt sa key - value parovima success i message
-u bloku koda try kreiramo varijablu const sessionCartId
-dodajemo uslov if (!sessionCartId) 
-pozivamo funkciju await prisma.product.findFirst()
-vrijednost funkcije await prisma.product.findFirst() pohranjujemo u varijablu const product
-dodajemo uslov if (!product)
-u uslov if (!product) pozivamo funkciju throw new Error()
-nakon uslova if (!product) pozivamo funkciju await getMyCart()
-vrijednost funkcije await getMyCart() pohranjujemo u varijablu const cart
-dodajemo uslov if (!cart)
-u uslovu if (!cart) pozivamo funkcija throw new Error()
-pozivamo funkciju (cart.items as CartItem[]).find()
-vrijednost funkcije (cart.items as CartItem[]).find() pohranjujemo u varijablu const existItem
-dodajemo uslov if (!existItem) 
-u uslovu if (!existItem) pozivamo funkciju throw new Error()
-dodajemo uslove if (existItem.qty === 1) - else
-nakon uslova if - else pozivamo funkciju await prisma.cart.update()
-pozivamo funkciju revalidatePath()
-dodajemo izjavu return objekt sa key - value parovima success i message

52. Dynamic Cart Button
-u komponentu product/[slug]/page.tsx importujemo funkciju getMyCart iz cart.actions.ts fajla
-u funkciji ProductDetailsPage() pozivamo funkciju getMyCart()
-vrijednost funkcije getMyCart() pohranjujemo u varijablu const cart
-u jsx-u, komponenti AddToCart dodajemo prop cart u koji proslijedujemo varijablu cart
-u komponentu add-to-cart.tsx importujemo funkciju removeItemFromCart
-importujemo tip Cart
-importujemo React ikonicu Minus
-funkciji AddToCart() dodajemo parametar destruktuirani prop cart
-destruktuiranom parametru cart dodajemo tip Cart
-kreiramo varijablu const existItem
-kreiramo funkciju handleRemoveFromCart()
-u jsx-u dodajemo izjavu return ternarni operator za varijablu existItem
-u prvi dio ternarnog operatora kreiramo roditelj div element
-u roditelj div element dodajemo dvije komponente Button
-prvoj komponenti Button dodajemo prop type, variant i dogadaj onClick
-u dogadaj onClick proslijedujemo funkciju handleRemoveFromCart
-u komponentu Button dodajemo React ikonicu Minus
-kreiramo span element sa prop className
-u span elementu dinamicki prikazujemo vrijednost varijable existItem.qty
-drugoj komponenti Button dodajemo prop type, variant i dogadaj onClick
-u dogadaj onClick proslijedujemo funkciju handleAddToCart
-u komponentu Button dodajemo React ikonicu Plus
-u drugi dio ternarnog operatora dodajemo komponentu Button i React ikonicu Plus
-funkciji handleRemoveFromCart() dodajemo asinhronost 
-u funkciji handleRemoveFromCart() pozivamo funkciju await removeItemFromCart(item.productId)
-vrijednost funkcije await removeItemFromCart(item.productId) pohranjujemo u varijablu const res
-pozivamo funkciju toast() sa argumentom objekt
-u objekt dodajemo key - value parove variant i description
-nakon funkcije toast() dodajemo izjavu return

53. Smooth UI With useTransition Hook
-otvorimo link: https://react.dev/reference/react/useTransition
-u komponentu add-to-cart.tsx importujemo funkciju useTransition iz paketa react
-importujemo React ikonicu Loader iz paketa lucide-react
-u funkciji AddToCart() pozivamo funkciju useTransition()
-vrijednost funkcije useTransition() pohranjujemo u destruktuirane varijable const [isPending, startTransition]
-u funkcije handleAddToCart() i handleRemoveFromCart() pozivamo funkciju startTransition()
-u funkcije startTransition() proslijedujemo kao argument anonimne asinhrone funkcije
-u komponente Button dodajemo uslov ternarni operator za varijablu isPending
-u prvi dio ternarnog operatora dodajemo komponentu Loader
-komponenti Loader dodajemo prop className i animate-spin
-u drugi dio ternarnog operatora dodajemo React ikonicu Plus ili Minus 


Section 06: Cart & Shipping Pages

54. Section Intro

55. Cart Page
-u folderu (root)/cart kreiramo komponentu page.tsx
-u komponenti cart/page.tsx kreiramo i eksportujemo funkciju CartPage() kao default
-kreiramo i eskportujemo varijablu const metadata
-kreiramo komponentu cart-table.tsx
-u komponenti cart-table.tsx kreiramo i eskportujemo funkciju CartTable() kao default
-u komponentu cart-table.tsx dodajemo direktivu 'use client'
-importujemo tip Cart iz types/index.ts fajla
-u komponentu cart/page.tsx importujemo komponentu CartTable iz komponente cart-table.tsx
-u komponenti cart-table.tsx funkciji CartTable() dodajemo parametar destruktuirani prop cart sa tipom Cart
-u jsx-u kreiramo h2 element sa Tailwind CSS klasama
-u komponentu cart/page.tsx importujemo funkciju getMyCart iz cart.actions.ts fajla
-funkciji CartPage() dodajemo asinhronost
-u funkciji CartPage() pozivamo funkciju await getMyCart()
-vrijednost funkcije await getMyCart() pohranjujemo u varijablu const cart
-u jsx-u dodajemo komponentu CartTable sa prop cart
-u komponentu cart-table.tsx importujemo funkcije useRouter, useTransition, addItemToCart, removeItemFromCart i useToast
-importujemo React ikonice ArrowRight, Loader, Minus i Plus
-importujemo komponente Link i Image
-pozivamo funkciju useRouter()
-vrijednost funkcije useRouter() pohranjujemo u varijablu const router
-pozivamo funkciju useToast() 
-vrijednost funkcije useToast() pohranjujemo u varijablu const { toast }
-pozivamo funkciju useTransition()
-vrijednost funkcije useTransition() pohranjujemo u varijable const [isPending, startTransition]
-u jsx-u dodajemo ternarni uslov !cart || cart.items.length === 0
-otvorimo rutu: http://localhost:3000/cart

56. ShadCN UI Table
-otvorimo link: https://ui.shadcn.com/docs/components/table
-u terminalu ukucamo komandu npx shadcn@latest add table
-u komponentu cart-table.tsx importujemo komponente Table, TableBody, TableHead,  TableHeader, TableRow i TableCell iz komponente ui/table.tsx
-importujemo komponentu Button iz komponente ui/button.tsx
-u div element sa klasom overflow-x-auto md:col-span-3 dodajemo Table komponente iz komponente ui/table.tsx
-u komponentu TableBody dodajemo funkciju cart.items?.map()
-otvorimo rutu: http://localhost:3000/cart

57. Subtotal Card
-u lib/utils.ts fajlu kreiramo varijablu CURRENCY_FORMATTER
-kreiramo i eksportujemo funkciju formatCurrency() sa parametrom amount
-parametru amount dodajemo tipove number, string i null
-u funkciju formatCurrency() dodajemo uslove if, else if i else
-u komponentu cart-table.tsx importujemo funkciju formatCurrency iz lib/utils.ts fajla
-importujemo komponente Card i CardContent iz komponente ui/card.tsx
-u div element sa klasom grid md:grid-cols-4 md:gap-5 dodajemo komponentu Card
-u komponentu Card dodajemo komponentu CardContent sa prop className
-u komponenti CardContent kreiramo div element sa Tailwind CSS klasama
-u div elementu kreiramo dva span elementa
-u prvi span element dodajemo funkciju cart.items.reduce()
-u drugi span element dodajemo funkciju formatCurrency(cart.itemsPrice)
-u komponentu CardContent dodajemo komponentu Button sa prop className, disabled i onClick
-u komponenti Button kreiramo dva span elementa
-u prvi span element dodajemo uslov ternarni operator isPending 
-u drugi span element dodajemo tekst Proceed to Checkout

58. Shipping Address Zod Schema & Page
-u lib/validators.ts fajlu kreiramo i eksportujemo varijablu shippingAddressSchema
-u types/index.ts fajl importujemo varijablu shippingAddressSchema
-eksportujemo tip ShippingAddress
-u constants/index.ts fajlu kreiramo i eskportujemo varijablu shippingAddressDefaultValues
-u folderu (root) kreiramo folder shipping-address i komponentu page.tsx
-u komponenti shipping-address/page.tsx kreiramo i eksportujemo funkciju ShippingAddressPage() kao default
-u user.actions.ts fajlu kreiramo i eksportujemo asinhronu funkciju getUserById()
-u komponentu shipping-address/page.tsx importujemo funkcije redirect, auth, getMyCart i getUserById
-importujemo tipove Metadata i ShippingAddress
-funkciji ShippingAddressPage() dodajemo asinhronost
-kreiramo i eksportujemo varijablu const metadata
-u funkciji ShippingAddressPage() pozivamo funkciju await getMyCart()
-vrijednost funkcije await getMyCart() pohranjujemo u varijablu const cart
-dodajemo uslov if (!cart || cart.items.length === 0)
-u uslovu if pozivamo funkciju redirect('/cart')
-pozivamo funkciju await auth()
-vrijednost funkcije await auth() pohranjujemo u varijablu const session
-kreiramo varijablu const userId
-dodajemo uslov if (!userId) 
-u uslov if (!userId) dodajemo throw new Error()
-pozivamo funkciju await getUserById(userId)
-vrijednost funkcije await getUserById(userId) pohranjujemo u varijablu const user

59. Shipping Address & Form
-u folderu shipping-address kreiramo komponentu shipping-address-form.tsx
-u komponenti shipping-address-form.tsx kreiramo i eksportujemo funkciju ShippingAddressForm()
-dodajemo direktivu 'use client'
-importujemo tip ShippingAddress iz types/index.ts fajla
-funkciji ShippingAddressForm() dodajemo parametar destruktuirani prop address
-u komponentu shipping-address/page.tsx importujemo komponentu ShippingAddressForm iz komponente shipping-address-form.tsx
-u jsx-u dodajemo prazan fragment kao roditelj element
-u prazan fragment dodajemo komponenta ShippingAddressForm sa prop address
-u prop address proslijedujemo varijablu user.address as ShippingAddress
-u komponentu shipping-address-form.tsx importujemo funkcije useTransition, useRouter i useToast
-importujemo varijablu shippingAddressSchema iz lib/validators.ts fajla
-u funkciji ShippingAddressForm() pozivamo funkciju useRouter()
-vrijednost funkcije useRouter() pohranjujemo u varijablu const router
-pozivamo funkciju useToast() 
-vrijednost funkcije useToast() pohranjujemo u destruktuiranu varijablu const { toast }
-otvorimo link: https://www.npmjs.com/package/react-hook-form
-otvorimo link: https://github.com/react-hook-form/resolvers
-u terminalu ukucamo komandu: npm i react-hook-form @hookform/resolvers
-otvorimo link: https://ui.shadcn.com/docs/components/form
-u terminalu ukucamo komandu: npx shadcn@latest add form
-importujemo funkcije useForm i zodResolver
-importujemo instancu z iz paketa zod
-importujemo varijablu shippingAddressDefaultValues iz lib/constants.ts fajla
-kreiramo varijablu const form
-pozivamo funkciju useTransition()
-vrijednost funkcije useTransition() pohranjujemo u varijable const [isPending, startTransition]
-importujemo komponente Form, FormControl, FormField, FormItem, FormLabel i FormMessage iz komponente ui/form.tsx
-importujemo komponentu Input iz komponente ui/input.tsx
-u jsx-u dodajemo prazan fragment kao roditelj element
-u praznom fragmentu kreiramo div element sa Tailwind CSS klasama
-u div elementu kreiramo elemente h1 i p sa Tailwind CSS klasama
-u div element dodajemo komponentu Form sa otvorenim i zatvorenim tagom
-komponenti Form dodajemo prop {...form}
-u komponenti Form kreiramo form element
-form elementu dodajemo atribute method, className i dogadaj onSubmit
-kreiramo funkciju onSubmit() sa parametrom values
-parametru values dodajemo tip z.infer<typeof shippingAddressSchema>
-u dogadaj onSubmit proslijedujemo funkciju form.handleSubmit(onSubmit)
-u form elementu kreiramo div element sa Tailwind CSS klasama
-u komponentu div dodajemo komponentu FormField za puno ime korisnika sa samozatvarajucim tagom
-komponenti FormField dodajemo prop control, name i render
-u prop render proslijedujemo anonimnu funkciju sa parametrom destruktuiranim prop field
-u anonimnu funkciju dodajemo komponente FormItem, FormLabel, FormControl, Input i FormMessage
-kreiramo div element i komponentu FormField za korisnikovu adresu
-kreiramo div element i komponentu FormField za korisnikov grad
-kreiramo div element i komponentu FormField za korisnikov postanski broj
-kreiramo div element i komponentu FormField za korisnikovu drzavu
-kreiramo div element sa Tailwind CSS klasama flex gap-2
-importujemo komponentu Button iz komponente ui/button.tsx
-u div element dodajemo komponentu Button sa prop type i disabled
-importujemo React ikonice Loader i ArrowRight iz paketa lucide-react
-u komponentu Button dodajemo uslov ternarni operator za varijablu isPending
-otvorimo rutu: http://localhost:3000/shipping-address

60. Update User Address
-u user.actions.ts fajl importujemo funkciju auth iz auth.ts fajla
-importujemo tip ShippingAddress iz types/index.ts fajla
-importujemo varijablu shippingAddressSchema iz validators.ts fajla
-kreiramo i eksportujemo asinhronu funkciju updateUserAddress() sa parametrom data
-parametru data dodajemo tip ShippingAddress
-dodajemo blokove koda try - catch
-u bloku koda try kreiramo varijablu const session
-kreiramo varijablu const currentUser
-dodajemo uslov if (!currentUser)
-kreiramo varijablu const address
-pozivamo funkciju await prisma.user.update()
-dodajemo izjavu objekt return da je korisnikova adresa uspjesno izmjenjena
-u blok koda catch dodajemo izjavu objekt return da je doslo do greske
-u komponentu shipping-address-form.tsx importujemo funkciju updateUserAddress iz user.actions.ts fajla
-importujemo tip SubmitHandler iz paketa react-hook-form
-funkciji onSubmit() dodajemo asinhronost
-funkciji onSubmit() dodajemo tip SubmitHandler<z.infer<typeof shippingAddressSchema>>
-u funkciji onSubmit() pozivamo funkciju startTransition()
-u funkciji startTransition() pozivamo anonimnu asinhronu funkciju
-u anonimnoj asinhronoj funkciji kreiramo varijablu const res
-dodajemo uslov if (!res.success)
-pozivamo funkciju router.push('/payment-method')
-otvorimo rutu: http://localhost:3000/shipping-address

61. Checkout Steps Component
-otvorimo link: https://react.dev/reference/react/Fragment
-u folderu components/shared kreiramo komponentu checkout-steps.tsx
-u komponenti checkout-steps.tsx kreiramo i eksportujemo funkciju CheckoutSteps() kao default
-importujemo komponentu Fragment iz paketa react
-importujemo funkciju cn iz utils.ts fajla
-funkciji CheckoutSteps() dodajemo parametar destruktuirani prop current = 0
-u jsx-u roditelj div elementu dodajemo Tailwind CSS klase
-kreiramo varijablu niz checkoutSteps
-u roditelj div elementu dodajemo funkciju checkoutSteps?.map()
-u funkciju map() proslijedujemo anonimnu funkciju sa parametrima step i index
-u anonimnu funkciju dodajemo komponentu Fragment sa otvorenim i zatvorenim tagom
-komponenti Fragment dodajemo prop key
-u komponenti Fragment kreiramo div element sa prop className
-u prop className proslijedujemo funkciju cn()
-u div elementu dinamicki prikazujemo vrijednost varijable step
-u komponentu Fragment dodajemo uslov za kondicionalno renderovanje step !== 'Place Order' && ()
-u komponentu shipping-address/page.tsx importujemo komponentu CheckoutSteps iz komponente CheckoutSteps.tsx
-u jsx-u dodajemo komponentu CheckoutSteps sa prop current
-otvorimo rutu: http://localhost:3000/shipping-address

62. Persist Session Cart
-u auth.ts fajlu, u funkciju jwt() dodajemo uslov if (trigger === 'signIn' || trigger === 'signUp')
-u uslovu if pozivamo funkciju await cookies()
-vrijednost funkcije await cookies() pohranjujemo u varijablu const cookiesObject
-pozivamo funkciji cookiesObject.get()
-vrijednost funkcije cookiesObject.get() pohranjujemo u varijablu const sessionCartId
-dodajemo uslov if (sessionCartId)
-u uslovu if (sessionCartId) pozivamo funkciju await prisma.cart.findFirst()
-vrijednost funkcije await prisma.cart.findFirst() pohranjujemo u varijablu const sessionCart
-dodajemo uslov if (sessionCart)
-u uslovu if (sessionCart) pozivamo funkciju await prisma.cart.deleteMany()
-pozivamo funkciju await prisma.cart.update()

63. Protecting Paths
-u auth.config.ts fajlu, u funkciji authorized() kreiramo niz const protectedPaths
-iz varijable request.nextUrl destruktuiramo varijablu const { pathname }
-dodajemo uslov if (!auth && protectedPaths.some((path) => path.test(pathname)))
-u uslov if dodajemo izjavu return false
-odjavimo se iz aplikacije i otvorimo rutu: http://localhost:3000/shipping-address
-otvorimo link: https://www.udemy.com/course/nextjs-ecommerce-course/learn/lecture/47571607#questions/22806241/


Section 07: Payment Method & Order Pages

64. Section Intro

65. Payment Method Action & Zod Schema
-u .env fajlu kreiramo varijable PAYMENT_METHODS i DEFAULT_PAYMENT_METHOD
-u example.env fajl dodajemo primjer env varijabli koje je potrebno kreirati
-u constants/index.ts fajlu kreiramo i eksportujemo varijable PAYMENT_METHODS i DEFAULT_PAYMENT_METHOD
-u validators.ts fajl importujemo varijablu PAYMENT_METHODS iz constants/index.ts fajla
-kreiramo i eksportujemo varijablu const paymentMethodSchema
-u user.actions.ts fajl importujemo varijablu paymentMethodSchema iz validators.ts fajla
-importujemo instancu z iz paketa zod
-kreiramo i eksportujemo asinhronu funkciju updateUserPaymentMethod()
-funkciji updateUserPaymentMethod() dodajemo parametar data
-parametru data dodajemo tip z.infer<typeof paymentMethodSchema>
-dodajemo blokove koda try - catch
-u blok koda catch dodajemo izjavu objekt return da je doslo do greske prilikom izmjene metode placanja
-u bloku koda try pozivamo funkciju await auth()
-vrijednost funkcije await auth() pohranjujemo u varijablu const session
-pozivamo funkciju await prisma.user.findFirst()
-vrijednost funkcije await prisma.user.findFirst() pohranjujemo u varijablu const currentUser
-dodajemo uslov if (!currentUser)
-otvorimo link: https://stackoverflow.com/questions/74853013/next-js-error-session-user-is-possibly-undefined-but-im-able-to-acc
-kreiramo varijablu const paymentMethod
-pozivamo funkciju await prisma.user.update()
-dodajemo izjavu objekt return da je izmjena metode placanja uspjesna

66. Payment Method Page
-u folderu app/(root) kreiramo folder payment-method i komponentu page.tsx
-u komponenti payment-method/page.tsx kreiramo i eksportujemo funkciju PaymentMethodPage() kao default
-funkciji PaymentMethodPage() dodajemo asinhronost
-importujemo tip Metadata iz paketa next
-importujemo funkcije auth i getUserById
-kreiramo i eksportujemo varijablu const metadata sa tipom Metadata
-u funkciji PaymentMethodPage() kreiramo varijable const session i const userId
-dodajemo uslov if (!userId) 
-kreiramo varijablu const user
-kreiramo komponentu payment-method-form.tsx
-u komponenti payment-method-form.tsx kreiramo i eksportujemo funkciju PaymentMethodForm() kao default
-dodajemo direktivu 'use client'
-funkciji PaymentMethodForm() dodajemo parametar destruktuirani prop preferredPaymentMethod
-importujemo funkcije useTransition, useRouter, useForm, zodResolver i useToast
-importujemo instancu z iz paketa zod
-importujemo varijablu paymentMethodSchema iz validators.ts fajla
-importujemo varijablu DEFAULT_PAYMENT_METHOD iz constants/index.ts fajla
-importujemo komponentu CheckoutSteps iz komponente CheckoutSteps.tsx
-u funkciji PaymentMethodForm() kreiramo varijablu const router
-pozivamo funkciju useToast()
-vrijednost funkcije useToast pohranjujemo u destruktuiranu varijablu const { toast }
-kreiramo varijablu const form 
-pozivamo funkciju useTransition()
-vrijednost funkcije useTransition() pohranjujemo u destruktuirane varijable const [isPending, startTransition]
-u jsx-u dodajemo komponentu CheckoutSteps sa prop current
-u komponentu payment-method/page.tsx importujemo komponentu PaymentMethodForm
-u jsx-u dodajemo komponentu PaymentMethodForm sa prop preferredPaymentMethod
-otvorimo rutu: http://localhost:3000/payment-method

67. Payment Method Form & Update
-u komponentu payment-method importujemo komponentu CheckoutSteps iz komponente CheckoutSteps.tsx
-u jsx-u dodajemo komponentu CheckoutSteps sa prop current
-u komponentu payment-method-form.tsx importujemo React ikonice ArrowRight i Loader iz paketa lucide-react
-importujemo komponente Form, FormField, FormControl, FormItem, FormLabel i FormMessage iz komponente ui/form.tsx
-importujemo komponentu Button iz komponente ui/button.tsx
-u jsx-u dodajemo prazan fragment kao roditelj element
-u praznom fragmentu kreiramo div element sa Tailwind CSS klasama
-u div elementu kreiramo elemente h2 i p sa Tailwind CSS klasama
-dodajemo komponentu Form
-u komponenti Form kreiramo form element 
-form elementu dodajemo prop method, className i dogadaj onSubmit
-kreiramo asinhronu funkciju onSubmit()
-u dogadaj onSubmit proslijedujemo funkciju form.handleSubmit(onSubmit)
-u form elementu kreiramo dva div elementa sa Tailwind CSS klasama
-u drugi div element dodajemo komponentu Button sa prop type i disabled
-otvorimo link: https://ui.shadcn.com/docs/components/radio-group
-u terminalu ukucamo komandu: npx shadcn@latest add radio-group
-u prvi div element dodajemo komponentu FormField sa samozatvarajucim tagom
-komponenti FormField dodajemo prop control, name i render
-u prop render proslijedujemo anonimnu funkciju sa destruktuiranim parametrom field
-u anonimnu funkciju dodajemo komponentu FormItem sa otvorenim i zatvorenim tagom
-u komponentu FormItem dodajemo komponentu FormControl sa otvorenim i zatvorenim tagom
-importujemo komponente RadioGroup i RadioGroupItem iz komponente ui/radio-group.tsx
-u komponentu FormControl dodajemo komponentu RadioGroup 
-komponenti RadioGroup dodajemo prop onValueChange i className
-importujemo varijablu PAYMENT_METHODS iz constants/index.ts fajla
-kreiramo varijablu const paymentMethods
-u komponentu RadioGroup dodajemo funkciju paymentMethods.map()
-u funkciju map() dodajemo komponentu FormItem sa otvorenim i zatvorenim tagom
-komponenti FormItem dodajemo prop key i className
-u komponentu FormItem dodajemo komponentu FormControl sa otvorenim i zatvorenim tagom
-u komponentu FormControl dodajemo komponentu RadioGroupItem sa samozatvarajucim tagom
-komponenti RadioGroupItem dodajemo prop value i checked
-u komponentu FormItem dodajemo komponentu FormLabel sa otvorenim i zatvorenim tagom
-u prop render, u komponentu FormItem dodajemo komponentu FormMessage sa samozatvarajucim tagom
-importujemo funkciju updateUserPaymentMethod iz user.actions.ts fajla
-asinhronoj funkciji onSubmit() dodajemo parametar values
-parametru values dodajemo tip z.infer<typeof paymentMethodSchema>
-u funkciji onSubmit() pozivamo funkciju startTransition()
-u funkciju startTransition() proslijedujemo anonimnu asinhronu funkciju
-u anonimnoj asinhronoj funkciji pozivamo funkciju await updateUserPaymentMethod(values)
-vrijednost funkcije await updateUserPaymentMethod() pohranjujemo u varijablu const res
-dodajemo uslov if (!res.success) 
-u uslovu if (!res.success) pozivamo funkciju toast()
-nakon funkciji toast() dodajemo izjavu return
-nakon uslova if (!res.success) pozivamo funkciju router.push('/place-order')
-otvorimo rutu: http://localhost:3000/payment-method i odaberemo metodu placanja
-nakon sto odaberemo metodu placanja kliknemo dugme Continue

68. Order & OrderItem Prisma Schema
-u schema.prisma fajlu kreiramo modele Order i OrderItem
-u terminalu ukucamo komandu: npx prisma generate
-u terminalu ukucamo komandu: npx prisma migrate dev --name add-order
-u terminalu ukucamo komandu: npx prisma studio